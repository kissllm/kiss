#!/bin/sh
# shellcheck source=/dev/null
#
# Simple package manager written in POSIX shell for https://kisslinux.org
#
# The MIT License (MIT)
#
# Copyright (c) 2019-2021 Dylan Araps
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# https://stackoverflow.com/questions/70675246/replacing-newlines-with-the-string-n-with-posix-tools
magic() { { cat -u; printf '\n'; } | awk -v ORS= '{print sep $0; sep="\\n"}'; }

# https://stackoverflow.com/questions/12162010/posix-sh-equivalent-for-bash-s-printf-q
esceval() {
    local func_name="$1"
    shift 1
    local result=
    case $# in 0) return 0; esac
    local index=0
    while :
    do
        if null "$result"; then
            result="'"
        else
            result="$result' '"
        fi
        index=$((index + 1))
        debug "$func_name \$@" "\$$index" "$1"
        case "$1" in
            '')
                result="$result$(printf '%s' "")"
                ;;
            *)
                result="$result$(printf '%s' "$1" | sed "s/'/'\\\\''/g")"
        esac
        shift
        case $# in 0) break; esac
    done
    result="$result'"
    printf '%s' "$result"
}

run() {
    # Print the command, then run it.
    printf '%s\n' "$*"
    "$@"
}

# Some maintainers might print debug information in a function's definition,
# but which function has an output.
# This delegation makes it sure of only getting the printf content after the last \n,
# which content comes from a
# function_name() { printf "\n%s" "$output"; }
# local var="$(delegate "function_name" "$@")"
delegate() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    printf "%s" "$("$@" | awk 'BEGIN{ RS = ""; FS = "\n" }{print $NF}')"
}

# Should be subshell function
occurrences() {
    { [ -z "$1" ] || [ -z "$2" ]; } && die "$FUNCNAME" "Wrong parameters for function"
    local s="$1"
    local sub_str="$2"
    count=0
    until
        t=${s#*"$sub_str"}
        [ "$t" = "$s" ]
    do
        count=$((count + 1))
        s=$t
    done
    printf "%s" "$count"
}

# Should be subshell function
standardize() {
    local path="$1"
    ok "$path" && {
        local src_length=${#path}
        [ "$(expr substr $path 1 2)" = '//' ] && {
            path="$(expr substr $path 2 $((src_length - 1)) )"
        }
        src_length=${#path}
        [ "$(expr substr $path $src_length 1)" = '/' ] && {
            path="$(expr substr $path 1 $((src_length - 1)) )"
        }
        src_length=${#path}
        [ "$(expr substr $path $src_length 1)" = '*' ] && {
            path="$(expr substr $path 1 $((src_length - 1)) )"
        }
    }
    [ "$path" != "$1" ] && path="$(standardize "$path")"
    printf "%s" "$path"
}

# $1 string
# $2 sub_str
contains() {
    # Check if a "string list" contains a word.
    case " $1 " in *" $2 "*) return 0; esac; return 1
}

equ() {
    # Check if a string is equal to enother.
    # This replaces '[ "$var" = str ]' and '[ "$var" != str ]'.
    case $1 in "$2") return 0 ;; *) return 1; esac
}

ok() {
    # Check if a string is non-null.
    # This replaces '[ "$var" ]', '[ -n "$var" ]'.
    case $1 in '') return 1 ;; *) return 0; esac
}

null() {
    # Check if a string is null.
    # This replaces '[ -z "$var" ]'.
    case $1 in '') return 0 ;; *) return 1; esac
}

check_errs() {
    # Function. Parameter 1 is the return code
    # Para. 2 is text to display on failure.
    if [ "${1}" -ne "0" ]; then
        echo "ERROR # ${1} : ${2}"
        # as a bonus, make our script exit with the right error code.
        exit ${1}
    fi
}

spaces() {
    local HEADER_WIDTH=$1
    local length_header=$2
    local index=1
    local white_spaces=
    while [ $index -le $((HEADER_WIDTH - length_header)) ]; do
        white_spaces=" ${white_spaces}"
        let "index = index + 1"
    done
    printf "%s" "${white_spaces}"
}

null "$SCOPE_WIDTH"  && SCOPE_WIDTH=20
null "$KEY_WIDTH"    && KEY_WIDTH=17
null "$HEADER_WIDTH" && HEADER_WIDTH=$((SCOPE_WIDTH + 1 + KEY_WIDTH + 1 + 4))

# Print key-value parameter pair with consistent format
# Local variables/contents have to be passed by parameter 3
# $1 scope  : function name
# S2 key    : variable name
# $3 value  : contents
out() {
    # null "$HEADER_WIDTH" && HEADER_WIDTH=28
    local scope="$1"
    local key="$2"
    local contents
    local result

    # if null "$3"; then
    #     # $3 is not set at all
    #     # printf "-z \$3: %s %s %s\n" "$FUNCNAME" '$key' "$key" > /dev/stderr
    #     case "$key" in
    #         *'$'*)
    #             # log 'out' 'fucking $2' "$2"
    #             contents="$(eval echo "$key")"
    #             ;;
    #         *)
    #             contents="$key"
    #             key=""
    #     esac
    # else
        # $3 is empty or something else
        # printf "non -z \$3: %s %s %s\n" "$FUNCNAME" '$key' "$key"
        contents="$3"
    # fi

    # Using "$scope $key" as a combined header
    local length_scope=${#scope}
    num_scope=$((SCOPE_WIDTH - length_scope))
    local length_key=${#key}
    if [ "$num_scope" -lt 0 ]; then
        num_key=$((KEY_WIDTH - length_key + $num_scope))
    else
        num_key=$((KEY_WIDTH - length_key))
    fi
    # local length_header=$((length_scope + 1 + length_key + 1 + 2))
    if [ "$num_scope" -gt 0 ]; then
        result="$(printf "%b%s %${num_scope}.0s" "$c1" "$scope" "")"
    else
        result="$(printf "%b%s " "$c1" "$scope")"
    fi
    case "$contents" in
        *"$newline"*|*"\n"*)
            # contents="$(printf "%b" "$(printf "%s" "$contents" | magic)" | tr "\n" " ")"
            local index=0
            for item in $contents; do
                # if [ ! "$index" -eq 0 ]; then
                #     result="$result $(printf "\n%${HEADER_WIDTH}.0s %s" "" "$item")"
                # else
                #     if [ $length_header -gt $HEADER_WIDTH ] && ok "$item"; then
                #         result="$result $(printf "%b%s%b" "${c3}${key:+$c2}" "$key" "$c3")"
                #         result="$result $(printf "\n%${HEADER_WIDTH}.0s %s" "" "$item")"
                #     else
                        if [ "$num_key" -gt 0 ]; then
                            result="$result $(printf "%b%s %${num_key}.0s %b" "${c3}${key:+$c2}" "$key" "" "$c3")"
                        else
                            result="$result $(printf "%b%s  %b" "${c3}${key:+$c2}" "$key" "$c3")"
                        fi
                        case "$contents" in
                            '') ;;
                            *"'"*"'"*)
                                result="$result $(printf "%s" "$item")"
                                ;;
                            *)
                                result="$result $(printf "%s" "'$item'")"
                        esac
                #     fi
                # fi
                # index=$((index + 1))
            done
            ;;
        *)
            # if [ $length_header -gt $HEADER_WIDTH ] && ok "$contents"; then
            #     result="$result $(printf "%b%s%b" "${c3}${key:+$c2}" "$key" "$c3")"
            #     result="$result $(printf "\n%${HEADER_WIDTH}.0s %s" "" "$contents")"
            # else
            #     # local white_spaces="$(spaces $HEADER_WIDTH $length_header)"
            #     # printf "%b%s %b%s%b %s %s\n" \
            #     #     "$c1" "$scope" "${c3}${key:+$c2}" "$key" "$c3" "$white_spaces" "$contents"
                if [ "$num_key" -gt 0 ]; then
                    result="$result $(printf "%b%s %${num_key}.0s %b" "${c3}${key:+$c2}" "$key" "" "$c3")"
                else
                    result="$result $(printf "%b%s  %b" "${c3}${key:+$c2}" "$key" "$c3")"
                fi
                case "$contents" in
                    '') ;;
                    *"'"*"'"*)
                        result="$result $(printf "%s" "$contents")"
                    ;;
                    *)
                        result="$result $(printf "%s" "'$contents'")"
                esac
            # fi
    esac
    printf "%s" "$result"
}

log() {
    local result="$(out "$1" "$2" "$3")"
    printf "%s\n" "$result" > /dev/stderr
    printf "%s\n" "$result" 2>&1 >> $log_dir/build.log
}

war() {
    # log "${1} WARNING" "$2" "$3"
    local result="$(out "$1 WARNING" "$2" "$3")"
    printf "%s\n" "$result" > /dev/stderr
    printf "%s\n" "$result" 2>&1 >> $log_dir/build.log
}

die() {
    # log "${1} ERROR" "$2" "$3"
    local result="$(out "$1 ERROR" "$2" "$3")"
    printf "%s\n" "$result" > /dev/stderr
    printf "%s\n" "$result" 2>&1 >> $log_dir/build.log
    exit 1
}

# How to debug:
# export KISS_DEBUG=1
# set -exf
# https://bugzilla.redhat.com/show_bug.cgi?id=1596312
# strace -f -eexecve q acl 1
debug() {
    # # https://www.shellscript.sh/exitcodes.html
    # # local check_debug=$(set | grep '^KISS_DEBUG=')
    # local check_debug="$(eval echo '$KISS_DEBUG')"
    # check_errs $? "\$check_debug : $check_debug"
    # # log 'debug' "check_debug=$check_debug"
    # if [ "$?" -ne "0" ]; then
    #     echo "Sorry, cannot find KISS_DEBUG in set"
    #     exit 1
    # else
    #     # Will hang up the shell on busybox 1.35.0-2
    #     # ( [ -n "$KISS_DEBUG" ] && \
    #     #         printf "%s\n" "$(out "$1" "$2" "$3")" 2>&1 >> $log_dir/build.log )
    #     [ -z "$KISS_DEBUG" ] || {
    #        [ 0 -ne "$KISS_DEBUG" ]  && \
    #           printf "%s\n" "$(out "$1" "$2" "$3")" 2>&1 >> $log_dir/build.log
                # export KISS_DEBUG=1

                # https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
                # [ -z ${KISS_DEBUG+x} ] || printf "%s\n" "$(out "$1" "$2" "$3")" 2>&1 >> $log_dir/build.log
                printf "%s\n" "$(out "$1" "$2" "$3")" 2>&1 >> $log_dir/build.log

                # [ "${KISS_DEBUG+set}" != set ] && printf "%s\n" "$(out "$1" "$2" "$3")" 2>&1 >> $log_dir/build.log
    #     }
    # fi
}

# Aquire an empty file in temporary directory for writing into
# it step by step in the future
# $1 scope        : function name
# $2 src_address  : source file full path or file name
slot_aquire() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local scope="$1"
    log "$FUNCNAME" '$scope' "$scope"
    shift 1

    local src_address="$1"
    local src_name="${src_address##*/}"
    [ "$(expr substr $src_address 1 1)" = '/' ] && {
        local src_length=${#src_address}
        src_address="$(expr substr $src_address 2 $((src_length - 1)) )"
    }
    # Create a uniquely named temporary file and store its absolute path
    # in a variable (_stack_topend).
    #
    # To prevent subshell usage and to handle cases where multiple files
    # are needed, this saves the last two temporary files to variables
    # for access by the caller (allowing 3 files at once).
    # _stack_bottom="$_stack_second"
    # _stack_second="$_stack_topend"
    _stack_topend="$tmp_dir/$src_address"
    tmp_list="$(\ls -x "$tmp_dir")"
    for item in $tmp_list; do
        [ "$item" = "$_stack_topend" ] && _stack_topend=""; break
    done

    # { [ -n "$_stack_bottom" ] && [ -n "$_stack_second" ]; } \
    #     && { [ "$_stack_bottom" = "$_stack_second" ] \
    #         || [ "$_stack_bottom" = "$_stack_topend" ] \
    #         || [ "$_stack_topend" = "$_stack_second" ]; } \
    #     && {
    #     log "$FUNCNAME" '$_stack_bottom' "$_stack_bottom"
    #     log "$FUNCNAME" '$_stack_second' "$_stack_second"
    #     log "$FUNCNAME" '$_stack_topend' "$_stack_topend"
    #     die "$FUNCNAME" "$src_address" "Failed to aquire temporary file"
    # }

    null "$_stack_topend" || {
        local dir_topend="${_stack_topend%/*}"
        [ -d "$dir_topend" ] || mkdir -p "$dir_topend"

        : > "$_stack_topend" || war "$FUNCNAME" "$src_address" "Failed to create temporary file"
    }
    printf "\n%s" "$_stack_topend"
}

# Copy an extarnal file to temporary directory in one time
# Won't create empty file
# $1 scope        : function name
# $2 src_address  : source file full path
slot_push() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local scope="$1"
    log "$FUNCNAME" '$scope' "$scope"
    shift 1

    trap 'eval echo "${trace_line}"' ERR

    local src_address="$1"
    local src_name="${src_address##*/}"

    # Create a uniquely named temporary file and make a duplicate of
    # the file in '$1' if it exists.
    [ ! -f "$src_address" ] || {
        log "$FUNCNAME" '$src_address' "$src_address"
        local top="$(delegate "slot_aquire" "$FUNCNAME" "$src_address")"
        ok "$top" && cp -f "$src_address" "$top"
    }
    log "$FUNCNAME" '$top' "$top"
    printf "\n%s" "$top"
}

prompt() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    null "$1" || log "$FUNCNAME" '$1' "$1"

    log "$FUNCNAME" "Continue?: Press Enter to continue or Ctrl+C to abort"

    # korn-shell does not exit on interrupt of read.
    equ "$KISS_PROMPT" 0 || read -r _ || exit 1
}

mkcd() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local scope="$1"
    log "$FUNCNAME" '$scope' "$scope"
    shift 1
    if null "$1"; then
        die "$FUNCNAME" "can not create directories"
    else
        log "$FUNCNAME" '$@' "$@"
        [ "$(dirname "$1")" != "/" ] && mkdir -p "$@" && cd "$1" || log "$FUNCNAME" 'cd' 'trying to cd to /'
    fi
}

replace() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Replace all occurrences of substrings with substrings. This
    # function takes pairs of arguments iterating two at a time
    # until everything has been replaced.
    _fnr="$1"
    shift 1

    while :; do case $_fnr-$# in
        *"$1"*) _fnr=${_fnr%"$1"*}${2}${_fnr##*"$1"} ;;
           *-2) break ;;
             *) shift 2
    esac done
}

# $1 path
am_owner() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Figure out if we need to change users to operate on
    # a given file or directory.
    local inf="$(ls -ld "$1")" ||
        die "$FUNCNAME" "Failed to file information for '$1'"

    log "$FUNCNAME" '$inf' "$inf"
    # Split the ls output into fields.
    read -r _ _ user _ < <(printf "$inf\n")
    log "$FUNCNAME" '$user' "$user"
    equ "$LOGNAME/$user" "$user/$LOGNAME"
}

as_user() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    printf 'Using '%s' (to become %s)\n' "$cmd_su" "$user"

    case ${cmd_su##*/} in
        su) "$cmd_su" -c "$* <&3" "$user" 3<&0 </dev/tty ;;
         *) "$cmd_su" -u "$user" -- "$@"
    esac
}

pkg_owner() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    ok "$2" || { set +f; set -f -- "$1" "$sys_db"/*/manifest; }

    _owns=$(grep -lxF "$@")
    _owns=${_owns%/*}
    _owns=${_owns##*/}

    ok "$_owns"
}

resolve_path() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    _rpath=$KISS_ROOT/${1#/}
    local _parent
    # Attempt to resolve symlinks by using 'cd'.
    # If this fails, fallback to the file's parent
    # directory.
    if cd -P "${_rpath%/*}" 2>/dev/null; then
        _parent=$PWD
        cd "$OLDPWD"
    else
        _parent=${_rpath%/*}
    fi

    _rpath=${_parent#"$KISS_ROOT"}/${_rpath##*/}
}

run_hook() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Run all hooks in KISS_HOOK (a colon separated
    # list of absolute file paths).
    IFS=:

    for hook in ${KISS_HOOK:-}; do case $hook in *?*)
        "$hook" "$@" || die "$FUNCNAME" "$1 hook failed: '$hook'"
    esac done

    unset IFS
}

run_hook_pkg() {
    # Run a hook from the package's database files.
    if [ -x "$sys_db/$2/$1" ]; then
        log "$FUNCNAME" "$2" "Running $1 hook"
        "$sys_db/$2/$1"

    elif [ -f "$sys_db/$2/$1" ]; then
        war "$FUNCNAME" "$2" "skipping $1 hook: not executable"
    fi
}

# $1 tar_file : tar file
decompress() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    log "$FUNCNAME" '$tar_file' "$tar_file[global]"
    local tar_file="$1"
    log "$FUNCNAME" '$pkg' "$pkg"
    if ok "$tar_file"; then
        log "$FUNCNAME " '$tar_file' "$tar_file [local]"
    else
        die "$FUNCNAME " '' "\$tar_file not found [local]"
    fi

    case $tar_file in
        *.tbz|*.bz2) bzip2 -d ;;
        *.lzma)      lzma -dc ;;
        *.lz)        lzip -dc ;;
        *.tar)       cat      ;;
        *.tgz|*.gz)  gzip -d  ;;
        *.xz|*.txz)  xz -dcT0 ;;
        *.zst)       zstd -dc ;;
    esac < "$tar_file"
}

sh256() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Higher level sh256 function which filters out non-existent
    # files (and also directories).
    for f do shift
        [ -d "$f" ] || [ ! -e "$f" ] || set -- "$@" "$f"
    done

    printf '\n%s' "$(delegate "_sh256" "$@")"
}

_sh256() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # There's no standard utility to generate sha256 checksums.
    # This is a simple wrapper around sha256sum, sha256, shasum,
    # openssl, digest, ... which will use whatever is available.
    #
    # All utilities must match 'sha256sum' output.
    #
    # Example: '<checksum>  <file>'
    unset hash

    # Skip generation if no arguments.
    ! equ "$#" 0 || return 0

    # Set the arguments based on found sha256 utility.
    case ${cmd_sha##*/} in
        openssl) set -- dgst -sha256 -r "$@" ;;
         sha256) set -- -r "$@" ;;
         shasum) set -- -a 256 "$@" ;;
         digest) set -- -a sha256 "$@" ;;
    esac

    IFS=$newline

    # Generate checksums for all input files. This is a single
    # call to the utility rather than one per file.
    local sha_list="$("$cmd_sha" "$@")" || die "$FUNCNAME" "Failed to generate checksums"

    # Strip the filename from each element.
    # '<checksum> ?<file>' -> '<checksum>'
    for sum in $sha_list; do
        hash=$hash${hash:+"$newline"}${sum%% *}
    done

    printf '\n%s' "$hash"
    unset IFS
}

# $1 scope
# $2 pkg
# $3
# $4 -d / -x
# $5 $KISS_PATH / $sys_db / $PATH
pkg_version() {
    set -efE
    trap 'Error in function $FUNCNAME at line $LINENO' ERR
    local scope="$1"
    debug "$FUNCNAME" '$scope' "$scope"
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    shift 1
    local pkg="$1"
    debug "$FUNCNAME" '$pkg' "$pkg"
    local select="$2"
    local shell_flag="$3"
    local search_path="$4"

    ver_pre=$repo_ver
    rel_pre=$repo_rel

    local repo_dir="$(delegate "pkg_find" "$@")"
    if [ -d "$repo_dir" ]; then
        debug "$FUNCNAME" '$repo_dir' "$repo_dir"
    else
        die "$FUNCNAME" '$repo_dir' "No such package ($pkg)"
    fi

    IFS=$"(printf ' ')" read -r repo_ver repo_rel 2>/dev/null < "$repo_dir/version" ||
        die "$FUNCNAME" "$pkg" "Failed to read version file ($repo_dir/version)"

    ok "$repo_rel" ||
        die "$FUNCNAME" "$pkg" "Release field not found in version file"

    # This belongs somewhere else, for now it can live here.
    [ -x "$repo_dir/build" ] ||
        die "$FUNCNAME" "$pkg" "Build file not found or not executable"

    debug "$FUNCNAME" '$ver_pre'  "$ver_pre"
    debug "$FUNCNAME" '$rel_pre'  "$rel_pre"
    debug "$FUNCNAME" '$repo_ver' "$repo_ver"
    debug "$FUNCNAME" '$repo_rel' "$repo_rel"

    printf '%s\3%s\3%s\3%s\3%s\n' "$repo_dir" "$ver_pre" "$rel_pre" "$repo_ver" "$repo_rel"

}

# $1 pkg_name
pkg_version_split() {
    set -efE
    trap 'Error in function $FUNCNAME at line $LINENO' ERR
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # https://stackoverflow.com/questions/2488715/idioms-for-returning-multiple-values-in-shell-scripting
    IFS=$'\3' read -r repo_dir _ _ repo_ver _ < <(pkg_version "$FUNCNAME" "$1")
    null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
    null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"
    debug "$FUNCNAME" '$repo_ver' "$repo_ver"

    # Split the version on '.+-_' to obtain individual components.
    IFS=.+-_ read -r repo_major repo_minor repo_patch repo_ident < <(printf "$repo_ver\n")

    [ $? -eq 0 ] && {
        debug "$FUNCNAME" '$repo_dir' "$repo_dir"
        debug "$FUNCNAME" '$repo_major' "$repo_major"
        debug "$FUNCNAME" '$repo_minor' "$repo_minor"
        debug "$FUNCNAME" '$repo_patch' "$repo_patch"
        # [ -z ${repo_ident} ] && repo_ident="0"
        debug "$FUNCNAME" '$repo_ident' "$repo_ident"
    }
    printf '%s\3%s\3%s\3%s\3%s\n' "$repo_dir" "$repo_major" "$repo_minor" "$repo_patch" "$repo_ident"

}

# Query package from /var/db/kiss without being limited by $KISS_PATH
# and install it from the query index (optional)
# $1 target
# $2 index: selected one
pick_up() {
    set -efE
    trap 'Error in function $FUNCNAME at line $LINENO' ERR
    local index=0
    local target="${1}"
    local target_index="${2}"
    local selected=
    local ver_selected=
    local sub_ver_selected=
    local packages="$(find "/var/db/kiss" \( -type d -o -type l \) -name "${target}")"
    for pack in $packages
    do
        [ -d "$pack" ] && [ -f "$pack/version" ] && {
            read -r repo_ver repo_rel 2>/dev/null < "$pack/version" || {
                printf "%s\n" "Failed to read version file ($pack/version)"
                exit 1
            }
            printf "%-4d %-9s %-4s %s\n" $((index)) "$repo_ver" "$repo_rel" "$pack"
            null "$target_index" || [ "$index" != "$target_index" ] || {
                selected="$pack"
                ver_selected="$repo_ver"
                sub_ver_selected="$repo_rel"
            }
            index=$(($index + 1))
        }
    done
    null "$selected" || {
        printf "\n%s\n%-4d %-9s %-4s %s\n\n" "Selected package:" $target_index  "$ver_selected" "$sub_ver_selected" "$selected"
        local dir="$(dirname "$selected")"
        local base="$(basename "$selected")"
        if null "${USE_GMAKE}"; then
            printf "\n%s\n\n" "BSD make used"
        else
            printf "\n%s\n\n" "GNU make used"
            local build_root="${HOME}/.cache/kiss/proc/$base"
            [ ! -d "${build_root}/bin" ] && mkdir -p "${build_root}/bin"
            [ "$(readlink "${build_root}/bin/gunzip")" != "/usr/bin/pigz"  ] && \ln -sf "/usr/bin/pigz"  "${build_root}/bin/gunzip"
            [ "$(readlink "${build_root}/bin/make")"   != "/usr/bin/gmake" ] && \ln -sf "/usr/bin/gmake" "${build_root}/bin/make"
            export PATH="${build_root}/bin:$PATH"
        fi
        export KISS_PATH=$dir
        /usr/bin/kiss c $base 2>&1 > /dev/stderr &&
        /usr/bin/kiss b $base 2>&1 > /dev/stderr &&
        /usr/bin/kiss i $base
    }
}

# Figure out which repository a package belongs to
# or print applications in $PATH
# $1 pkg name
# $2 select option: "all" for repositories and "" for the 1st repository
# $3 shell flag: -d / -x
# $4 $KISS_PATH / $sys_db / $PATH
# $5 result
pkg_find() {
    set -efE
    trap 'Error in function $FUNCNAME at line $LINENO' ERR
    debug "$FUNCNAME" 'enter'
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    debug "$FUNCNAME" '$pkg' "$pkg[global]"
    # Figure out which repository a package belongs to by searching for
    # directories matching the package name in $KISS_PATH/*.
    set -- "$1" "$2" "$3" "${4:-"$KISS_PATH"}"
    local pkg="$1"
    local select="$2"
    null "$select" && pkg="$(standardize "$pkg")" # pkg=${pkg%%\*}
    debug "$FUNCNAME " '$pkg' "$pkg [local]"
    local pkg_name="${pkg##*/}"
    debug "$FUNCNAME " '$pkg_name' "$pkg_name [local]"

    debug "$FUNCNAME" 'set -- ' ""
    debug "$FUNCNAME" '$#' "$#"
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"

    # local condidate_paths=
    # case "$4" in
    #     *"/$pkg_name")
    #         condidate_paths="${4%/*}"
    #         ;;
    #     *)
    #         IFS=:
    #         path_lines=$(printf "$4\n" | sed "s/:/\n/g")

    #         # while IFS=$'\n' read -r path; do
    #         for path in $4; do
    #             [ -d "$path" ] && {
    #                 debug "$FUNCNAME" 'searching $path' "$path"
    #                 [ "$pkg_name" = "$(\ls -1 "$path" | grep "$pkg_name")" ] && {
    #                     if ok "$condidate_paths"; then
    #                         condidate_paths="$path $condidate_paths"
    #                     else
    #                         condidate_paths="$path"
    #                     fi
    #                 }
    #             }
    #         done
    #         # done < <(printf "$path_lines\n")
    #         unset IFS
    # esac

    # log "$FUNCNAME" '$#' "$#"
    debug "$FUNCNAME" '$sys_db' "$sys_db"
    local path_lines=$(printf "$4" | sed "s/:/ /g")
    # debug "$FUNCNAME" '$condidate_paths' "$condidate_paths"
    # Iterate over KISS_PATH, grabbing all directories which match the query.
    # Intentional.
    # shellcheck disable=2086
    # for _found_path in $condidate_paths "$sys_db"; do
    for _found_path in $path_lines $sys_db; do
        debug "$FUNCNAME" '$pkg' "$pkg"
        debug "$FUNCNAME" '$pkg_name' "$pkg_name"
        ok "$_found_path" && {
            _found_path="$(standardize "$_found_path")"
            debug "$FUNCNAME" '$_found_path' "$_found_path"
        }
        set +f
        if null "$select"; then
            local _found_pkg="$_found_path/$pkg_name"
            debug "$FUNCNAME" '$_found_pkg' "$_found_pkg"
            debug "$FUNCNAME" '$#' "$#"
            debug "$FUNCNAME" '${3:--d}' "${3:--d}"
            test "${3:--d}" "$_found_pkg" && {
                set -f -- "$@" "$_found_pkg"
                null "$select" && break
            }
            debug "$FUNCNAME" '$#' "$#"
        else
            local _pkgs="$(\ls -1 "$_found_path" 2>/dev/null | grep "$(standardize "$pkg_name")" | tr "\n" " ")"
            for _found_pkg in $_pkgs; do
                _found_pkg="$_found_path/$_found_pkg"
                _found_pkg="$(standardize "$_found_pkg")"
                test "${3:--x}" "$_found_pkg" && {
                    set -f -- "$@" "$_found_pkg"
                }
            done
        fi
    done

    # debug "$FUNCNAME" '$#' "$#"
    # debug "$FUNCNAME" '$@' "$@"
    log "$FUNCNAME" 'serach done'
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    log "$FUNCNAME" '$2-$#' "$2-$#"

    ok "$repo_dir" && debug "$FUNCNAME" '$repo_dir' "$repo_dir[global]"

    # Figure out which repository a package belongs to by searching for
    # Show all search results if called from 'kiss search', else store the
    # values in variables. If there are 4 arguments, no package has been found.
    local result=
    case $2-$# in
        *-4) ;;
        -*) # null "$select"
            repo_dir="$(standardize "$5")"
            result="$repo_dir"
            repo_name="${5##*/}"
            debug "$FUNCNAME" '$repo_dir' "$repo_dir"
            ;;
        *)  # ok "$select"
            shift 4;
            for item in $@; do
                result="$result $item"
            done
            debug "$FUNCNAME" '$applications' "$result"
    esac
    printf '\n%s' "$result"
}

pkg_list_version() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local scope="$1"
    log "$FUNCNAME" '$scope' "$scope"
    shift 1
    debug "$FUNCNAME" '$#' "$#"

    # List installed packages. As the format is files and directories, this
    # just involves a simple for loop and file read.

    log "$FUNCNAME" '$sys_db' "$sys_db"

    # Optional arguments can be passed to check for specific packages. If no
    # arguments are passed, list all.
    ok "$1" || { set +f; set -f -- "$sys_db"/*; }

    # Loop over each package and print its name and version.
    for pkg_name do
        debug "$FUNCNAME" '$pkg_name'       "$pkg_name"
        debug "$FUNCNAME" '${pkg_name##*/}' "${pkg_name##*/}"
        IFS=$'\3' read -r repo_dir ver_pre rel_pre repo_ver repo_rel < <(pkg_version "$FUNCNAME" "${pkg_name##*/}" "" "" "$sys_db")
        null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
        null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"
        log "$FUNCNAME" "$pkg_name $repo_ver-$repo_rel"
    done
}

# Should be subshell function
# How to use:
# local tar_file="$(_pkg_cache "$pkg")"
# $1 pkg : package name
pkg_cache() {
    set -efE
    trap 'Error in function $FUNCNAME at line $LINENO' ERR
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local arguents="$@"
    local pkg="$1"
    null "$2" || debug "$FUNCNAME" '$2' "$2"
    log "$FUNCNAME" '$bin_dir' "$bin_dir"

    # Find the tarball of a package using a glob. Use the user's set compression
    # method if found or first match of the below glob.

    IFS=$'\3' read -r repo_dir ver_pre rel_pre repo_ver repo_rel < <(pkg_version "$FUNCNAME" "$1")
    null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
    null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"

    log "$FUNCNAME" '$repo_ver' "$repo_ver"
    log "$FUNCNAME" '$repo_rel' "$repo_rel"
    set -- "$arguents"
    set +f -- "${bin_dir}/${1}@${repo_ver}-${repo_rel}.tar."
    set -f -- "${1}$KISS_COMPRESS" "${1}"*

    local tar_file=""

    log "$FUNCNAME" '$1' "$1"
    log "$FUNCNAME" '$2' "$2"

    # If the first match does not exist, use the second. If neither exist,
    # this function returns 1 and the caller handles the error.
    if [ -f "$1" ]; then
        tar_file="$1"
    elif [ -f "$2" ]; then
        tar_file="$2"
    else
        war "$FUNCNAME" '$tar_file' "not found"
    fi

    debug "$FUNCNAME" '$1'        "$1"
    debug "$FUNCNAME" '$2'        "$2"
    debug "$FUNCNAME" '$tar_file' "$tar_file"

    printf "\n%s" "$tar_file"
}

# $1 pkg_name / repo_name  : package name
# $2 src                   : source link
# $3 dest                  : destination / source folder name
# $4 action
pkg_source_resolve() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    local repo_name="$pkg_name"
    local src="$2"
    local dest="$3"
    local action="$4"
    # Given a line of input from the sources file, return an absolute
    # path to the source if it already exists, error if not.
    unset _res _des _fnr

    ok "${2##\#*}" || return 0

    IFS=$'\3' read -r repo_dir _ _ repo_ver repo_rel < <(pkg_version "$FUNCNAME" "$pkg_name")
    null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
    null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"
    IFS=$'\3' read -r repo_dir repo_major repo_minor repo_patch repo_ident < <(pkg_version_split "$pkg_name")
    null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"

    # Surround each replacement with substitutions to handled escaped markers.
    # First substitution turns '\MARKER' into ' ' (can't appear in sources as
    # they're already split on whitespace), second replaces 'MARKER' with its
    # value and the third, turns ' ' into 'MARKER' (dropping \\).
    replace "${2%"${2##*[!/]}"}" \
        \\VERSION \  VERSION "$repo_ver"   \  VERSION \
        \\RELEASE \  RELEASE "$repo_rel"   \  RELEASE \
        \\MAJOR   \  MAJOR   "$repo_major" \  MAJOR \
        \\MINOR   \  MINOR   "$repo_minor" \  MINOR \
        \\PATCH   \  PATCH   "$repo_patch" \  PATCH \
        \\IDENT   \  IDENT   "$repo_ident" \  IDENT \
        \\PACKAGE \  PACKAGE "$repo_name"  \  PACKAGE

    set -- "$1" "$_fnr" "${3%"${3##*[!/]}"}" "$4"

    # Git repository.
    if null "${2##git+*}"; then
        _res=$2
        _des=$src_dir/$1/${3:+"$3/"}${2##*/}
        _des=${_des%[@#]*}/

    # Remote source (cached).
    elif [ -f "$src_dir/$1/${3:+"$3/"}${2##*/}" ]; then
        _res=$src_dir/$1/${3:+"$3/"}${2##*/}

    # Remote source.
    elif null "${2##*://*}"; then
        _res=url+$2
        _des=$src_dir/$1/${3:+"$3/"}${2##*/}

    # Local relative dir.
    elif [ -d "$repo_dir/$2" ]; then
        _res=$repo_dir/$2/.

    # Local absolute dir.
    elif [ -d "/${2##/}" ]; then
        _res=/${2##/}/.

    # Local relative file.
    elif [ -f "$repo_dir/$2" ]; then
        _res=$repo_dir/$2

    # Local absolute file.
    elif [ -f "/${2##/}" ]; then
        _res=/${2##/}

    else
        die "$FUNCNAME" "$1" "No local file '$2'"
    fi

    ok "$action" || log "$FUNCNAME" '$_res' "$_res"

    log "$FUNCNAME" '$_des'   "$_des"
    log "$FUNCNAME" '$action' "$action"

    printf "%s\3%s\n" "$_res" "$_des"
}

# $1 pkg_name   : package name
# $2 action  : action name
pkg_source() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    local action="$2"
    log "$FUNCNAME" '$pkg_name' "$pkg_name"
    log "$FUNCNAME" '$action'   "$action"
    # Download any remote package sources. The existence of local files is
    # also checked.
    IFS=$'\3' read -r repo_dir repo_major repo_minor repo_patch repo_ident < <(pkg_version_split "$pkg_name")
    null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"

    [ "$?" -eq 0 ] && {
        log "$FUNCNAME" '$repo_dir'   "$repo_dir"
        log "$FUNCNAME" '$repo_major' "$repo_major"
        log "$FUNCNAME" '$repo_minor' "$repo_minor"
        log "$FUNCNAME" '$repo_patch' "$repo_patch"
        log "$FUNCNAME" '$repo_ident' "$repo_ident"
    }
    # Support packages without sources. Simply do nothing.
    [ -f "$repo_dir/sources" ] || return 0

    log "$FUNCNAME" "$pkg_name" "Reading sources"

    while read -r src dest || ok "$src"; do
        [ "$src" != '#' ] || continue
        log "$FUNCNAME" '$src'  "$src"
        log "$FUNCNAME" '$dest' "$dest"
        IFS=$'\3' read -r _res _des < <(pkg_source_resolve "$pkg_name" "$src" "$dest" "$action")

        # arg1: pre-source
        # arg2: package name
        # arg3: verbatim source
        # arg4: resolved source
        run_hook pre-source "$pkg_name" "$src" "$_fnr"

        # '$2' is set when this function is called from 'kiss c' and it is used
        # here to skip calling the Git code.
        log "$FUNCNAME" '${_res%%+*}' "${_res%%+*}"
        case ${action}$_res in "${action}url+"*|git+*)
            log "$FUNCNAME" '$_des' "$_des"
            mkcd "$FUNCNAME" "${_des%/*}"
            "pkg_source_${_res%%+*}" "$pkg_name" "$_des" "${_res##"${_res%%+*}+"}"
        esac

        # arg1: post-source
        # arg2: package name
        # arg3: verbatim source
        # arg4: resolved source
        run_hook post-source "$pkg_name" "$src" "${_des:-"$_res"}"
    done < "$repo_dir/sources"
}

pkg_source_url() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local repo_name="$1"
    shift 1
    log "$FUNCNAME" "$repo_name" "Downloading $2"

    # Set the arguments based on found download utility.
    case ${cmd_get##*/} in
        aria2c|axel) set -- -o   "$@" ;;
               curl) set -- -fLo "$@" ;;
         wget|wget2) set -- -O   "$@" ;;
    esac

    "$cmd_get" "$@" || {
        rm -f "$2"
        die "$FUNCNAME" "$repo_name" "Failed to download $3"
    }
}

pkg_source_git() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local repo_name="$1"
    shift 1
    local com=${2##*[@#]}
    com=${com#${2%[#@]*}}

    log "$FUNCNAME" "$repo_name" "Checking out ${com:-FETCH_HEAD}"

    [ -d .git ] || git init

    url="${2%[#@]*}"
    git remote set-url origin "${url}" 2>/dev/null ||
        git remote add origin "${url}"

    log "$FUNCNAME" '$branch' "$com"
    log "$FUNCNAME" '$url'    "${url}"
    log "$FUNCNAME" '$PWD'    "$PWD"

    ( git fetch --depth 1 "${url}" 2>/dev/null ) ||  git fetch "${url}"
    git reset --hard FETCH_HEAD

    git rev-parse --short HEAD
    git describe --always

    git submodule deinit --all -f
    git submodule init
    git submodule sync
    git submodule update --init --remote --recursive --force
}

# $1 $dest
# $2 repo_name
# $3 $_res
pkg_source_tar() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local repo_name="$1"
    shift 1
    local dest="$1"
    local _res="$2"
    log "$FUNCNAME" '$0' "$0"
    log "$FUNCNAME" '$dest' "$dest"
    log "$FUNCNAME" '$_res' "$_res"
    log "$FUNCNAME" '$repo_name' "$repo_name"

    # This is a portable shell implementation of GNU tar's
    # '--strip-components 1'. Use of this function denotes a
    # performance penalty.
    local tarball="$(delegate "slot_aquire" "$FUNCNAME" "$dest/tarball")"
    log "$FUNCNAME" '$tarball' "$tarball"
    local tarball_manifest="$(delegate "slot_aquire" "$FUNCNAME" "$dest/tarball-manifest")"
    log "$FUNCNAME" '$tarball_manifest' "$tarball_manifest"

    decompress "$_res" > "$tarball" ||
        die "$FUNCNAME" "$repo_name" "Failed to decompress $_res"

    tar xf "$tarball" ||
        die "$FUNCNAME" "$repo_name" "Failed to extract $_res"

    # The sort command filters out all duplicate top-level
    # directories from the tarball's manifest. This is an optimization
    # as we avoid looping (4000 times for Python(!)).
    tar tf "$tarball" | sort -ut / -k1,1 > "$tarball_manifest" ||
        die "$FUNCNAME" "$repo_name" "Failed to extract manifest"

    # Iterate over all directories in the first level of the
    # tarball's manifest. Each directory is moved up a level.
    while IFS=/ read -r dir _; do case ${dir#.} in *?*)
        # Skip entries which aren't directories.
        [ -d "$dir" ] || continue

        # Move the parent directory to prevent naming conflicts
        # with the to-be-moved children.
        mv -f "$dir" "$KISS_PID-$dir"

        # Move all children up a directory level. If the mv command
        # fails, fallback to copying the remainder of the files.
        #
        # We can't use '-exec {} +' with any arguments between
        # the '{}' and '+' as this is not POSIX. We must also
        # use '$0' and '$@' to reference all arguments.
        find "$KISS_PID-$dir/." ! -name . -prune \
            -exec sh -c 'mv -f "$0" "$@" .' {} + 2>/dev/null ||

        find "$KISS_PID-$dir/." ! -name . -prune \
            -exec sh -c 'cp -fRp "$0" "$@" .' {} +

        # Remove the directory now that all files have been
        # transferred out of it. This can't be a simple 'rmdir'
        # as we may leave files in here if any were copied.
        rm -rf "$KISS_PID-$dir"
    esac done < "$tarball_manifest"

    # Remove the tarball now that we are done with it.
    rm -f "$tarball"
}

pkg_extract() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    # Extract all source archives to the build directory and copy over any
    # local repository files.
    #
    # NOTE: repo_dir comes from caller.
    log "$FUNCNAME" "$pkg_name" "Extracting sources"

    # arg1: pre-extract
    # arg2: package name
    # arg3: path to DESTDIR
    run_hook pre-extract "$pkg" "$pkg_dir"

    while read -r src dest || ok "$src"; do
        IFS=$'\3' read -r _res _des < <(pkg_source_resolve "$pkg_name" "$src" "$dest") > /dev/null

        # Create the source's directories if not null.
        null "$_res" || mkcd "$FUNCNAME" "$(standardize "$mak_dir/$dest")"

        case $_res in
            git+*)
                rsync -aqz "$_des/." .
            ;;

            *.tar|*.tar.??|*.tar.???|*.tar.????|*.t?z)
                pkg_source_tar "$pkg_name" "$dest" "$_res"
            ;;

            *?*)
                cp -LRf "$_res" .
            ;;
        esac
    done < "$repo_dir/sources" || die "$FUNCNAME" "$pkg_name" "Failed to extract $_res"
}

# $1 pkg : dependence with repo path
# $2 raw/expl: policies
# $3 filter: filter switch
# $4 relation: dependencies pair
# $5 dependency type
pkg_depends() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg="$1"
    log "$FUNCNAME" '$pkg'  "$pkg"
    log "$FUNCNAME" '$deps' "$deps"

    # Resolve all dependencies and generate an ordered list. The deepest
    # dependencies are listed first and then the parents in reverse order.
    ! contains "$deps" "$pkg" || return 0

    # Filter out non-explicit, already installed packages.
    null "$3" || ok "$2" || contains "$explicit" "$pkg" ||
        ! [ -d "$sys_db/$pkg" ] || return 0

    # Detect circular dependencies and bail out.
    # Looks for multiple repeating patterns of (dep dep_parent) (5 is max).
    case " $4 " in
*" ${4##* } "*" ${pkg} "\
*" ${4##* } "*" ${pkg} "\
*" ${4##* } "*" ${pkg} "\
*" ${4##* } "*" ${pkg} "\
*" ${4##* } "*" ${pkg} "*)
        die "$FUNCNAME" "Circular dependency detected
$pkg
<>
${4##* }"
    esac

    log "$FUNCNAME" '$repo_dir' "$repo_dir[global]"
    local repo_dir
    if [ -d "$sys_db/$dep" ]; then
        repo_dir="$sys_db/$dep"
    else
        repo_dir="$(delegate "pkg_find" "$dep")"
        null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
    fi

    if null "$repo_dir"; then
        die "$FUNCNAME" '' "\$repo_dir is not defined"
    else
        log "$FUNCNAME" '$repo_dir' "$repo_dir"
    fi

    if [ -z ${KISS_ROOT+x} ]; then
        log "$FUNCNAME" '' "\$KISS_ROOT is not defined"
    else
        log "$FUNCNAME" '$KISS_ROOT defined' "$KISS_ROOT"
    fi

    log "$FUNCNAME" '$4' "$4"

    # Packages which exist and have depends.
    null "$(delegate "pkg_find" "$pkg")" || ! [ -e "$repo_dir/depends" ] || {

        # Recurse through the dependencies of the child packages.
        while read -r dep dep_type || { :; ok "$dep"; }; do
            ! ok "${dep##\#*}" || {
                :
                log "$FUNCNAME" '$dep' "$dep"
                log "$FUNCNAME" '$dep_type' "$dep_type"
                local found_duplicated=0
                for I in $4; do
                    [ "$I" = "$pkg" ] && {
                        found_duplicated=1
                        break
                    }
                done
                [ $found_duplicated -eq 0 ] && {
                    if [ -z ${KISS_ROOT+x} ]; then
                        pkg_depends "$dep" '' "$3" "$4 $pkg" "$dep_type"
                    else
                        if null "$dep_type"; then
                            pkg_depends "$dep" '' "$3" "$4 $pkg" "$dep_type"
                        else
                            pkg_make_depends "$dep" '' "$3" "$4 $pkg" "$dep_type"
                        fi
                    fi
                }
            }
        done < "$repo_dir/depends" || :
    }
    # Add parent to dependencies list.
    if ! equ "$2" expl || { equ "$5" make && null "$(delegate "pkg_cache" "$pkg")"; }; then
        deps="$deps $1"
    fi

    for item in $deps; do
        log "$FUNCNAME" '$deps' "$item"
    done
}

pkg_make_depends() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg="$1"
    # Only add to list once
    ! contains "$makedeps" "$pkg" || return 0

    # Filter already installed packages on build machine.
    ! [ -d "/var/db/kiss/installed/$pkg" ] || return 0

    # Add to the list
    makedeps="$makedeps $pkg"
}

# "$@" : all packages
pkg_order() {
    # Order a list of packages based on dependence and take into account
    # pre-built tarballs if this is to be called from 'kiss i'.
    unset order redro deps

    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"

    for pkg do case $pkg in
      /*@*.tar.*) deps="$deps $pkg" ;;
       *@*.tar.*) deps="$deps $ppwd/$pkg" ;;
             */*) die "$FUNCNAME" "Not a package' ($pkg)" ;;
               *) pkg_depends "$pkg" raw
    esac done

    for item in $deps; do
        debug "$FUNCNAME" '$deps' "$item"
    done

    local order
    local redro
    # Filter the list, only keeping explicit packages. The purpose of these
    # two loops is to order the argument list based on dependence.
    for pkg in $deps; do case " $* " in *" $pkg "*|*" ${pkg##"$ppwd/"} "*)
        order="$order $pkg"
        redro="$pkg $redro"
    esac done

    log "$FUNCNAME" '$order' "'$order'"
    log "$FUNCNAME" '$redro' "'$redro'"

    unset deps

    printf "%s\3%s\n" "$order" "$redro"
}

pkg_strip() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Strip package binaries and libraries. This saves space on the system as
    # well as on the tarballs we ship for installation.
    [ -f "$mak_dir/nostrip" ] || equ "$KISS_STRIP" 0 && return

    log "$FUNCNAME" "$1" "Stripping binaries and libraries"

    # Strip only files matching the below ELF types. This uses 'od' to print
    # the first 18 bytes of the file. This is the location of the ELF header
    # (up to the ELF type) and contains the type information we need.
    #
    # Static libraries (.a) are in reality AR archives which contain ELF
    # objects. We simply read from the same 18 bytes and assume that the AR
    # header equates to an archive containing objects (.o).
    #
    # Example ELF output ('003' is ELF type):
    # 0000000 177   E   L   F 002 001 001  \0  \0  \0  \0  \0  \0  \0  \0  \0
    # 0000020 003  \0
    # 0000022
    #
    # Example AR output (.a):
    # 0000000   !   <   a   r   c   h   >  \n   /
    # 0000020
    # 0000022
    while read -r file; do [ -h "$pkg_dir$file" ] || case $file in
        # Look only in these locations for files of interest (libraries,
        # programs, etc). This includes all subdirectories. Old behavior
        # would run od on all files (upwards of 4000 for Python).
        */sbin/?*[!/]|*/bin/?*[!/]|*/lib/?*[!/]|\
        */lib??/?*[!/]|*/lib???/?*[!/]|*/lib????/?*[!/])

        case $(od -A o -t c -N 18 "$pkg_dir$file") in
            # REL (object files (.o), static libraries (.a)).
            *177*E*L*F*0000020\ 001\ *|*\!*\<*a*r*c*h*\>*)
                run strip -g -R .comment -R .note "$pkg_dir$file"
            ;;

            # EXEC (binaries), DYN (shared libraries).
            # Shared libraries keep global symbols in a separate ELF section
            # called '.dynsym'. '--strip-all/-s' does not touch the dynamic
            # symbol entries which makes this safe to do.
            *177*E*L*F*0000020\ 00[23]\ *)
                run strip -s -R .comment -R .note "$pkg_dir$file"
            ;;
        esac
    esac done < "$pkg_dir/$pkg_db/$1/manifest" || :
}

# could be subshell function before local version
# $1 repo_name : repository name / package name
pkg_fix_deps() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local repo_name="$1"
    # Dynamically look for missing runtime dependencies by checking each
    # binary and library with 'ldd'. This catches any extra libraries and or
    # dependencies pulled in by the package's build suite.
    log "$FUNCNAME" "$repo_name" "looking for dependencies (using ${cmd_elf##*/})"

    log "$FUNCNAME" '$PWD'    "$PWD"    # "$pkg_dir/$pkg_db/$pkg"
    log "$FUNCNAME" '$sys_db' "$sys_db"
    log "$FUNCNAME" '$pkg'    "$pkg"

    set +f
    set -f -- "$sys_db/"*/manifest

    unset _fdep_seen

    # False positive (not a write).
    # shellcheck disable=2094
    while read -r _file; do [ -h "$_file" ] || case $_file in
        # Look only in these locations for files of interest (libraries,
        # programs, etc). This includes all subdirectories. Old behavior
        # would run ldd on all files (upwards of 4000 for Python).
        */sbin/?*[!/]|*/bin/?*[!/]|*/lib/?*[!/]|\
        */lib??/?*[!/]|*/lib???/?*[!/]|*/lib????/?*[!/])

        log "$FUNCNAME" '$_file' "$_file"

        # The readelf mode requires ldd's output to resolve the library
        # path for a given file. If ldd fails, silently skip the file.
        local ldd="$(ldd -- "$pkg_dir/$_file" 2>/dev/null)" || continue

        # Attempt to get information from readelf. If this fails (or we
        # are in ldd mode), do full ldd mode (which has the downside of
        # listing dependencies of dependencies (and so on)).
        local elf="$("$cmd_elf" -d "$pkg_dir/$_file" 2>/dev/null)" || elf=$ldd

        # Iterate over the output of readelf or ldd, extract file names,
        # resolve their paths and finally, figure out their owner.
        while read -r lib; do case $lib in *NEEDED*\[*\]|*'=>'*)
            # readelf: 0x0000 (NEEDED) Shared library: [libjson-c.so.5]
            lib=${lib##*\[}
            lib=${lib%%\]*}

            # Resolve library path.
            # ldd: libjson-c.so.5 => /lib/libjson-c.so.5 ...
            case $cmd_elf in
                *readelf) lib=${ldd#*"	$lib => "} ;;
                *)        lib=${lib##*=> } ;;
            esac
            lib=${lib%% *}

            # Skip files owned by libc, libc++ and POSIX.
            case ${lib##*/} in
                ld-*           |\
                lib[cm].so*    |\
                libc++.so*     |\
                libc++abi.so*  |\
                libcrypt.so*   |\
                libdl.so*      |\
                libgcc_s.so*   |\
                libmvec.so*    |\
                libpthread.so* |\
                libresolv.so*  |\
                librt.so*      |\
                libstdc++.so*  |\
                libtrace.so*   |\
                libunwind.so*  |\
                libutil.so*    |\
                libxnet.so*    |\
                ldd)
                    continue
            esac

            # Skip files we have seen before.
            case " $_fdep_seen " in
                *" $lib "*) continue ;;
                *) _fdep_seen="$_fdep_seen $lib"
            esac

            resolve_path "$lib"

            # Skip file if owned by current package
            ! pkg_owner -e "$_rpath" manifest ||
                continue

            ! pkg_owner -e "$_rpath" "$@" ||
                printf '%s\n' "$_owns"

        esac done < <([ "$?" -eq 0 ] || :; printf "%s\n" "$elf")
    esac done < manifest |

    [ ! -s "depends" ] || {
        log "$FUNCNAME" 'ls -al depends' "$(eval ls -al depends)"
        local depends_list="$(cat depends)"
        for item in $depends_list; do
            log "$FUNCNAME depends" "to fix" "$item"
        done
        local depends_clone="$(delegate "slot_push" "$FUNCNAME" "depends")"
        log "$FUNCNAME pushed" '$depends' "$depends"

        local depends_fixed="$(delegate "slot_aquire" "$FUNCNAME" "depends-fixed")"
        log "$FUNCNAME pushed" '$depends_fixed' "$depends_fixed"

        # Sort the depends file (including the existing depends file) and
        # remove any duplicate entries. This can't take into account comments
        # so they remain rather than being replaced.
        sort -u -k 1,1 "$depends_clone" /dev/stdout > "$depends_fixed"

        # If the depends file was modified, show a diff and replace it.
        [ ! -s "$depends_fixed" ] || {
            diff -U 3 "$depends_clone" "$depends_fixed" 2>/dev/null || :

            log "$FUNCNAME to be depends" '$depends_fixed' "$depends_fixed"
            # Replace the existing depends file if one exists, otherwise this
            # just moves the file to its final resting place.
            mv -f "$depends_fixed" depends
            local depends_list="$(cat depends)"
            for item in $depends_list; do
                log "$FUNCNAME depends" "fixed" "$item"
            done
            # Generate a new manifest as we may be the creator of the depends
            # file. This could otherwise be implemented by inserting a line
            # at the correct place in the existing manifest.
            pkg_manifest "${PWD##*/}" "$pkg_dir"
        }
    }
}

# could be subshell function before local version
# $1 pkg                : package name
# $2 pkg_dir / tar_dir  : package directory / extracting directory
pkg_manifest() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg="$1"
    local pkg_dir="$2"
    # Generate the package's manifest file. This is a list of each file
    # and directory inside the package. The file is used when uninstalling
    # packages, checking for package conflicts and for general debugging.
    log "$FUNCNAME" "$pkg" "Generating manifest"
    log "$FUNCNAME" '$pkg_dir' "$pkg_dir"

    local manifest="$(delegate "slot_aquire" "$FUNCNAME" "manifest")"

    # Create a list of all files and directories. Append '/' to the end of
    # directories so they can be easily filtered out later. Also filter out
    # all libtool .la files and charset.alias.
    {
        printf '%s\n' "$pkg_dir/$pkg_db/$pkg/manifest"

        ! [ -d "$pkg_dir/etc" ] ||
        printf '%s\n' "$pkg_dir/$pkg_db/$pkg/etcsums"

        find "$pkg_dir" ! -path "$pkg_dir" -type d -exec printf '%s/\n' {} + \
            -o \( ! -type d -a ! -name \*.la -a ! -name charset.alias \) -print

        # Sort the output in reverse. Directories appear after their contents.
    } | sort -ur > "$manifest"

    # Remove the prefix from each line.
    while read -r file; do
        printf '%s\n' "${file#"$pkg_dir"}"
    done < "$manifest" > "$pkg_dir/$pkg_db/$pkg/manifest"
}

# $1 $pkg_name
manifest_validate() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # NOTE: pkg_name comes from caller.
    local pkg_name="$1"
    log "$FUNCNAME" "$pkg_name" "Checking if manifest valid"

    log "$FUNCNAME" '$tar_dir' "$tar_dir"
    log "$FUNCNAME" '$pkg_db/$pkg_name/manifest' "$pkg_db/$pkg_name/manifest"

    shift 1

    while read -r line; do
        [ -e "$tar_dir$line" ] || [ -h "$tar_dir$line" ] || {
            printf '%s\n' "$line"
            set -- "$@" "$line"
        }
    done < "$tar_dir/$pkg_db/$pkg_name/manifest"

    for f do
        log "$FUNCNAME" '$f' "$f"
        die "$FUNCNAME" "$pkg_name" "manifest contains $# non-existent files"
    done
}

manifest_replace() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Replace the matching line in the manifest with the desired replacement.
    # This used to be a 'sed' call which turned out to be a little
    # error-prone in some cases. This new method is a tad slower but ensures
    # we never wipe the file due to a command error.
    local manifest_replace_buffer="$(delegate "slot_aquire" "$FUNCNAME" "manifest-replace-${2##*/}")"

    while read -r line; do
        ! equ "$line" "$2" || line=$3

        printf '%s\n' "$line"
    done < "$sys_db/$1/manifest" | sort -r > "$manifest_replace_buffer"

    mv -f "$manifest_replace_buffer" "$sys_db/$1/manifest"
}

# $@ :
pkg_etcsums() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_dir="$1"
    local pkg_db="$2"
    local pkg="$3"
    # Generate checksums for each configuration file in the package's /etc/
    # directory for use in "smart" handling of these files.
    log "$FUNCNAME" "$pkg" "Generating etcsums"
    shift 3

    # Minor optimization - skip packages without /etc/.
    [ -d "$pkg_dir/etc" ] || return 0

    # Create a list of all files in etc but do it in reverse.
    while read -r etc; do case $etc in /etc/*[!/])
        set -- "$pkg_dir/$etc" "$@"
    esac done < "$pkg_dir/$pkg_db/$pkg/manifest"

    printf "%s\n" "$(delegate "sh256" "$@")" > "$pkg_dir/$pkg_db/$pkg/etcsums"
}

# $1 pkg : package name
pkg_tar() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    log "$FUNCNAME" '$pkg' "$pkg[global]"
    local bin_dir="$1"
    local pkg_dir="$2"
    local pkg="$3"
    local tar_file="$4"
    log "$FUNCNAME" '$pkg' "$pkg[local]"

    # Create a tarball from the built package's files. This tarball also
    # contains the package's database entry.
    #
    # NOTE: repo_ comes from caller.
    log "$FUNCNAME" '$pkg' "$pkg tarball creating"
    # tree "$pkg_dir"

    IFS=$'\3' read -r repo_dir ver_pre rel_pre repo_ver repo_rel < <(pkg_version "$FUNCNAME" "$pkg")
    null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
    null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"
    local tar_file=$bin_dir/$pkg@$repo_ver-$repo_rel.tar.$KISS_COMPRESS
    local repofile="repo.index"

    # Use 'cd' to avoid needing tar's '-C' flag which may not be portable
    # across implementations.
    cd "$pkg_dir"

    # Create a tarball from the contents of the built package.
    tar cf - . | case $KISS_COMPRESS in
        bz2)  bzip2 -z ;;
        gz)   gzip -6  ;;
        lzma) lzma -z  ;;
        lz)   lzip -z  ;;
        xz)   xz -zT0  ;;
        zst)  zstd -z  ;;
    esac > "$tar_file"

    # Remove any instances of this package in the index
    # This will leave only the latest version
    touch $bin_dir/$repofile
    sed -i "/$pkg@/d" $bin_dir/$repofile

    # Write the checksum to the repo file
    local cs=$(delegate "_sh256" "$tar_file")
    echo "$cs  $_tar_fn" >> "$bin_dir/$repofile"
    log "$FUNCNAME" '$pkg' "$pkg repo index updated"

    cd "$OLDPWD"

    log "$FUNCNAME" '$pkg' "$pkg tarball created successfully"
    log "$FUNCNAME" '$tar_file' "$tar_file"

    # arg1: post-package
    # arg2: package name
    # arg3: path to tarball
    run_hook post-package "$pkg" "$tar_file"
}

# $@ packages name
pkg_build_all() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Build packages and turn them into packaged tarballs.
    # Order the argument list and filter out duplicates.

    # Mark packages passed on the command-line explicit.
    # Also resolve dependencies for all explicit packages.
    for pkg do
        tmp_dirs "$pkg" "reset"
        pkg_depends "$pkg" expl filter
        explicit="$explicit $pkg "
    done

    # If this is an update, don't always build explicitly passsed packages
    # and instead install pre-built binaries if they exist.
    ok "$prefer_cache" || explicit_build=$explicit

    # If cross building, make sure the build machine has the correct deps
    set -- $makedeps
    [ "$#" -gt 0 ] && die "$FUNCNAME" "You need the following packages on your build machine: $*"

    set --

    # If an explicit package is a dependency of another explicit package,
    # remove it from the explicit list.
    for pkg in $explicit; do
        contains "$deps" "$pkg" || set -- "$@" "$pkg"
    done
    explicit_cnt=$#
    explicit=$*

    log "$FUNCNAME" "" "Building: explicit $*${deps:+, implicit: ${deps## }}"

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    set -- $deps "$@"

    # Ask for confirmation if extra packages need to be built.
    equ "$#" "$explicit_cnt" || prompt

    log "$FUNCNAME" "" "Checking for pre-built dependencies"

    # Install any pre-built dependencies if they exist in the binary
    # directory and are up to date.
    for pkg in $@; do
        local tar_file="$(delegate "pkg_cache" "$pkg")"
        if ! contains "$explicit_build" "$pkg" && ok "$tar_file"; then
            log "$FUNCNAME" "$pkg" "Found pre-built binary"

            # Intended behavior.
            # shellcheck disable=2030,2031
            (export KISS_FORCE=1; args i "$tar_file")
        else
            set -- "$@" "$pkg"
        fi
        shift
    done

    for pkg do
        pkg_source "$pkg"
        ! [ -f "$repo_dir/sources" ] || pkg_verify "$repo_dir" "$pkg"
    done

    [ -z ${KISS_ROOT+x} ]          || log "$FUNCNAME" '$KISS_ROOT' "$KISS_ROOT"
    [ -z ${KISS_XBUILD_TRIPLE+x} ] || log "$FUNCNAME" 'Building on $KISS_XBUILD_TRIPLE' "$KISS_XBUILD_TRIPLE"
    [ -z ${KISS_XHOST_TRIPLE+x} ]  || log "$FUNCNAME" 'Building for $KISS_XHOST_TRIPLE' "$KISS_XHOST_TRIPLE"
    log "$FUNCNAME" '$bin_dir' "$bin_dir"
    [ -z ${CC+x} ]       || log "$FUNCNAME" '$CC'       "$CC"
    [ -z ${CXX+x} ]      || log "$FUNCNAME" '$CXX'      "$CXX"
    [ -z ${CFLAGS+x} ]   || log "$FUNCNAME" '$CFLAGS'   "$CFLAGS"
    [ -z ${CXXFLAGS+x} ] || log "$FUNCNAME" '$CXXFLAGS' "$CXXFLAGS"
    [ -z ${LDFLAGS+x} ]  || log "$FUNCNAME" '$LDFLAGS'  "$LDFLAGS"

    # Finally build and create tarballs for all passed packages and
    # dependencies.
    for pkg do
        log "$FUNCNAME" "$pkg" "Building package ($((_build_cur+=1))/$#)"

        log "$FUNCNAME" '$repo_dir' "$repo_dir[global]"
        IFS=$'\3' read -r repo_dir repo_major repo_minor repo_patch repo_ident < <(pkg_version_split "$pkg")
        null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"

        # arg1: queue-status
        # arg2: package name
        # arg3: number in queue
        # arg4: total in queue
        run_hook queue "$pkg" "$_build_cur" "$#"

        log "$FUNCNAME" '$repo_dir' "$repo_dir [local]"
        null "$repo_dir" && die "$FUNCNAME" '' "\$repo_dir not found [local]"
        ! [ -f "$repo_dir/sources" ] || pkg_extract "$pkg"

        pkg_build    "$pkg"
        pkg_manifest "$pkg" "$pkg_dir"
        pkg_strip    "$pkg"

        cd "$pkg_dir/$pkg_db/$pkg"
        pkg_fix_deps "$pkg"
        pkg_etcsums  "$pkg_dir" "$pkg_db"  "$pkg"
        pkg_tar      "$bin_dir" "$pkg_dir" "$pkg" "$tar_file"

        if equ "${prefer_cache:=0}" 1 || ! contains "$explicit" "$pkg"; then
            log "$FUNCNAME" "$pkg" "Needed as a dependency or has an update, installing"

            # Intended behavior.
            # shellcheck disable=2030,2031
            (export KISS_FORCE=1; args i "$pkg")
        fi
    done

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    ! equ "${build_install:=1}" 1 || ! equ "${KISS_PROMPT:=1}" 1 ||
        ! prompt "Install built packages? [$explicit]" || (args i $explicit)
}

# could be subshell function before local version
# $1 pkg_name
pkg_build() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg="$1"
    # Install built packages to a directory under the package name to
    # avoid collisions with other packages.

    log "$FUNCNAME" '$pkg_root' "$pkg_root"
    log "$FUNCNAME" '$pkg_dir'  "$pkg_dir"
    log "$FUNCNAME" '$bin_dir'  "$bin_dir"
    log "$FUNCNAME" '$log_dir'  "$log_dir"
    log "$FUNCNAME" '$repo_ver' "$repo_ver"
    log "$FUNCNAME" '$repo_dir' "$repo_dir[global]"
    local repo_dir
    if null "$repo_dir"; then
        repo_dir="$(delegate "pkg_find" "$pkg")"
        null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
    fi
    log "$FUNCNAME" '$repo_dir'        "$repo_dir [local]"
    log "$FUNCNAME" '$1'               "$1"
    log "$FUNCNAME" '$pkg'             "$pkg"
    log "$FUNCNAME" '$pkg_db'          "$pkg_db"
    log "$FUNCNAME" '$pkg_dir/$pkg_db' "$pkg_dir/$pkg_db"

    mkcd "$FUNCNAME" "$mak_dir" "$pkg_dir/$pkg_db"

    log "$FUNCNAME" "$pkg" "Starting build"

    # arg1: pre-build
    # arg2: package name
    # arg3: path to build directory
    run_hook pre-build "$pkg" "$mak_dir"

    # # Attempt to create the log file early so any permissions errors are caught
    # # before the build starts. 'tee' is run in a pipe and POSIX shell has no
    # # pipe-fail causing confusing behavior when tee fails.
    # : > "$log_dir/build.log"

    meson_build=$(find "$pkg_dir" -type f -name "meson.build")
    [ -n "$meson_build" ] && meson setup --wipe

    if null "${USE_GMAKE}"; then
        log "$FUNCNAME" "BSD make used"
    else
        log "$FUNCNAME" "GNU make used"
        [ "$(readlink "${bin_dir}/gunzip")" != "/usr/bin/pigz"  ] && \ln -sf "/usr/bin/pigz"  "${bin_dir}/gunzip"
        [ "$(readlink "${bin_dir}/make")"   != "/usr/bin/gmake" ] && \ln -sf "/usr/bin/gmake" "${bin_dir}/make"
        export PATH="${bin_dir}:$PATH"
    fi

    # Call the build script, log the output to the terminal and to a file.
    # There's no PIPEFAIL in POSIX shell so we must resort to tricks like kill.
    {
        # Give the script a modified environment. Define toolchain program
        # environment variables assuming a generic environment by default.
        #
        # Define DESTDIR and GOPATH to sane defaults as their use is mandatory
        # in anything using autotools, meson, cmake, etc. Define KISS_ROOT as
        # the sanitized value used internally by the package manager. This is
        # safe to join with other paths.
        AR="${AR:-ar}" \
        CC="${CC:-cc}" \
        CXX="${CXX:-c++}" \
        NM="${NM:-nm}" \
        RANLIB="${RANLIB:-ranlib}" \
        DESTDIR="$pkg_dir" \
        RUSTFLAGS="--remap-path-prefix=$PWD=. $RUSTFLAGS" \
        GOFLAGS="-trimpath -modcacherw $GOFLAGS" \
        GOPATH="$PWD/go" \
        PATH="$GOPATH/bin:$PATH" \
        KISS_ROOT="$KISS_ROOT" \
        \
        "$repo_dir/build" "$pkg_dir" "$repo_ver" 2>&1 || {
            log "$FUNCNAME" "$pkg" "Build failed"
            log "$FUNCNAME" "$pkg" "Log stored to $log_dir/build.log"

            # arg1: build-fail
            # arg2: package name
            # arg3: path to build directory
            (run_hook build-fail "$pkg" "$mak_dir") || :

            # pkg_clean
            kill 0
        }
    } | tee "$log_dir/build.log"

    # # Delete the log file if the build succeeded to prevent the directory
    # # from filling very quickly with useless logs.
    # equ "$KISS_KEEPLOG" 1 || rm -f "$log_dir/build.log"

    # Copy the repository files to the package directory.
    cp -LRf "$repo_dir" "$pkg_dir/$pkg_db/"

    log "$FUNCNAME" "$pkg" "Successfully built package"

    # arg1: post-build
    # arg2: package name
    # arg3: path to DESTDIR
    run_hook post-build "$pkg" "$pkg_dir"
}

pkg_checksum() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg="$1"

    pkg_source "$pkg" c

    log "$FUNCNAME" '$repo_dir' "$repo_dir"
    [ -f "$repo_dir/sources" ] || return 0

    local hash="$(delegate "pkg_checksum_gen" "$pkg")"

    if ok "$hash"; then
        printf '%s\n' "$hash" > "$repo_dir/checksums"
        log "$FUNCNAME" "$pkg" "Generated checksums"

    else
        log "$FUNCNAME" "$pkg" "No sources needing checksums"
    fi
}

# $@ :
pkg_checksum_gen() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local repo_name="$1"
    log "$FUNCNAME" '$repo_dir' "$repo_dir"
    # Generate checksums for packages.
    #
    # NOTE: repo_ comes from caller.
    while read -r src dest || ok "$src"; do
        IFS=$'\3' read -r _res _des < <(pkg_source_resolve "$repo_name" "$src" "$dest") > /dev/null

        case ${_res##git+*} in */*[!.])
            set -- "$@" "$_res"
        esac
    done < "$repo_dir/sources"

    printf "\n%s" "$(delegate "sh256" "$@")"
}

# $1 pkg : package name
pkg_verify() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local repo_dir="$1"
    local pkg="$2"
    local repo_name="$pkg"

    # Verify all package checksums. This is achieved by generating a new set
    # of checksums and then comparing those with the old set.
    #
    # NOTE: repo_dir comes from caller.
    log "$FUNCNAME" "$repo_name" "Verifying sources"

    # Generate a new set of checksums to compare against.
    local hash="$(delegate "pkg_checksum_gen" "$pkg")"

    # Intentional, globbing disabled.
    # shellcheck disable=2038,2086
    set -- $hash

    # Check that the first column (separated by whitespace) match in both
    # checksum files. If any part of either file differs, mismatch. Abort.
    null "$1" || while read -r chk _ || ok "$1"; do
        printf '%s\n%s\n' "- ${chk:-missing}" "+ ${1:-no source}"

        equ "$1-${chk:-null}" "$chk-$1" ||
        equ "$1-${chk:-null}" "$1-SKIP" ||
            die "$FUNCNAME" "$repo_name" "Checksum mismatch"

        shift "$(($# != 0))"
    done < "$repo_dir/checksums"
}

# $1 pkg_name : package name
pkg_conflicts() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Check to see if a package conflicts with another.
    # pkg_name comes from the caller.
    local pkg_name="$1"

    log "$FUNCNAME" "$pkg_name" "Checking for package conflicts"

    local manifest_files="$(delegate "slot_aquire" "$FUNCNAME" "manifest-files")"
    local found_conflicts="$(delegate "slot_aquire" "$FUNCNAME" "found-conflicts")"

    # Filter the tarball's manifest and select only files. Resolve all
    # symlinks in file paths as well.
    while read -r file; do case $file in *[!/])
        resolve_path "$file"

        printf '%s\n' "$_rpath"
    esac done < "$tar_dir/$pkg_db/$pkg_name/manifest" > "$manifest_files"

    cd "$tar_dir"
    set +f
    set -f "$sys_db"/*/manifest

    # Remove the current package from the manifest list.
    replace " $* " " $sys_db/$pkg_name/manifest " " "

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    set -- $_fnr

    # Return here if there is nothing to check conflicts against.
    ! equ "$#" 0 || return 0

    # Store the list of found conflicts in a file as we'll be using the
    # information multiple times. Storing things in the cache dir allows
    # us to be lazy as they'll be automatically removed on script end.
    grep -Fxf "$manifest_files" -- "$@" 2>/dev/null > "$found_conflicts" || :

    # Enable alternatives automatically if it is safe to do so.
    # This checks to see that the package that is about to be installed
    # doesn't overwrite anything it shouldn't in '/var/db/kiss/installed'.
    grep -q ":/var/db/kiss/installed/" "$found_conflicts" || safe=1

    if ! equ "$KISS_CHOICE" 1 && equ "$safe" 1 && [ -s "$found_conflicts" ]; then
        # This is a novel way of offering an "alternatives" system.
        # It is entirely dynamic and all "choices" are created and
        # destroyed on the fly.
        #
        # When a conflict is found between two packages, the file
        # is moved to a directory called "choices" and its name
        # changed to store its parent package and its intended
        # location.
        #
        # The package's manifest is then updated to reflect this
        # new location.
        #
        # The 'kiss alternatives' command parses this directory and
        # offers you the CHOICE of *swapping* entries in this
        # directory for those on the filesystem.
        #
        # The alternatives command does the same thing we do here,
        # it rewrites manifests and moves files around to make
        # this work.
        #
        # Pretty nifty huh?
        while IFS=: read -r _ con; do
            printf '%s\n' "Found conflict $con"

            # Create the "choices" directory inside of the tarball.
            # This directory will store the conflicting file.
            mkdir -p "$PWD/$cho_db"

            # Construct the file name of the "db" entry of the
            # conflicting file. (pkg_name>usr>bin>ls)
            replace "$con" '/' '>'

            # Move the conflicting file to the choices directory
            # and name it according to the format above.
            mv -f "$PWD$con" "$PWD/$cho_db/$pkg_name$_fnr" 2>/dev/null || {
                log "$FUNCNAME" "File must be in ${con%/*} and not a symlink to it"
                log "$FUNCNAME" "This usually occurs when a binary is installed to"
                die "$FUNCNAME" "/sbin instead of /usr/bin (example)"
            }
        done < "$found_conflicts"

        log "$FUNCNAME" "$pkg_name" "Converted all conflicts to choices (kiss a)"

        # Rewrite the package's manifest to update its location
        # to its new spot (and name) in the choices directory.
        pkg_manifest "$pkg_name" "$tar_dir"

    elif [ -s "$found_conflicts" ]; then
        log "$FUNCNAME" "Package '$pkg_name' conflicts with another package" "!>"
        log "$FUNCNAME" "Run 'KISS_CHOICE=1 kiss i $pkg_name' to add conflicts" "!>"
        die "$FUNCNAME" "as alternatives." "!>"
    fi
}

# $@ :
pkg_alternatives() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    if equ "$1" -; then
        while read -r pkg path; do
            pkg_swap "$pkg" "$path"
        done

    elif ok "$1"; then
        pkg_swap "$@"

    else
        # Go over each alternative and format the file
        # name for listing. (pkg_name>usr>bin>ls)
        set +f; for pkg in "$sys_ch/"*; do
            replace "${pkg##*/}" '>' '/'
            printf '%s %s\n' "${_fnr%%/*}" "/${_fnr#*/}"
        done
    fi
}

pkg_swap() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Swap between package alternatives.
    [ -d "$sys_db/$1" ] || die "$FUNCNAME" "'$1' not found"

    replace "$1$2" '/' '>'

    [ -f "$sys_ch/$_fnr" ] || [ -h "$sys_ch/$_fnr" ] ||
        die "$FUNCNAME" "" "Alternative '$1 ${2:-null}' doesn't exist"

    if [ -f "$KISS_ROOT$2" ]; then
        pkg_owner "/${2#/}" ||
            die "$FUNCNAME" "" "File '$2' exists on filesystem but isn't owned"

        log "$FUNCNAME" "Swapping '$2' from '$_owns' to '$1'"

        # Convert the current owner to an alternative and rewrite its manifest
        # file to reflect this.
        cp -Pf "$KISS_ROOT$2" "$sys_ch/$_owns>${_fnr#*>}"
        manifest_replace "$_owns" "$2" "/$cho_db/$_owns>${_fnr#*>}"
    fi

    # Convert the desired alternative to a real file and rewrite the manifest
    # file to reflect this. The reverse of above.
    mv -f "$sys_ch/$_fnr" "$KISS_ROOT/$2"
    manifest_replace "$1" "/$cho_db/$_fnr" "$2"
}

file_rwx() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Convert the output of 'ls' (rwxrwx---) to octal. This is simply
    # a 1-9 loop with the second digit being the value of the field.
    #
    # NOTE: This drops setgid/setuid permissions and does not include
    # them in the conversion. This is intentional.
    unset oct o

    rwx=$(ls -ld "$1")

    for c in 14 22 31 44 52 61 74 82 91; do
        rwx=${rwx#?}

        case $rwx in
            [rwx]*) o=$((o + ${c#?})) ;;
             [st]*) o=$((o + 1)) ;;
        esac

        case $((${c%?} % 3)) in 0)
            oct=$oct$o
            o=0
        esac
    done
}

pkg_install_files() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    shift 1
    # Copy files and create directories (preserving permissions).
    # The 'test $1' will run with '-z' for overwrite and '-e' for verify.
    while { read -r file && _file=$KISS_ROOT$file; } do case $file in
        */)
            # Skip directories if they already exist in the file system.
            # (Think /usr/bin, /usr/lib, etc).
            [ -d "$_file" ] || {
                file_rwx "$2/${file#/}"
                mkdir -m "$oct" "$_file"
            }
        ;;

        *)
            # Skip directories and files which exist in verify mode.
            [ -d "$_file" ] || ! test "$1" "$_file" ||
                continue

            case $file in /etc/*[!/])
                # Handle /etc/ files in a special way (via a 3-way checksum) to
                # determine how these files should be installed. Do we overwrite
                # the existing file? Do we install it as $file.new to avoid
                # deleting user configuration? etc.
                #
                # This is more or less similar to Arch Linux's Pacman with the
                # user manually handling the .new files when and if they appear.
                pkg_etc "$pkg_name" || continue
            esac

            if [ -h "$_file" ]; then
                # Copy the file to the destination directory overwriting
                # any existing file.
                cp -fP "$2$file" "${_file%/*}/."

            else
                # Construct a temporary filename which is a) unique and
                # b) identifiable as related to the package manager.
                local __tmp=${_file%/*}/__kiss-tmp-$pkg_name-${file##*/}-$KISS_PID

                # Copy the file to the destination directory with the
                # temporary name created above.
                cp -fP "$2$file" "$__tmp" &&

                # Atomically move the temporary file to its final
                # destination. The running processes will either get
                # the old file or the new one.
                mv -f "$__tmp" "$_file"
            fi
    esac || return 1; done
}

pkg_remove_files() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Remove a file list from the system. This function runs during package
    # installation and package removal. Combining the removals in these two
    # functions allows us to stop duplicating code.
    while read -r file; do
        case $file in /etc/?*[!/])
            local hash="$(delegate "sh256" "$KISS_ROOT/$file")"

            read -r sum_pkg <&3 ||:

            equ "$hash" "$sum_pkg" || {
                printf 'Skipping %s (modified)\n' "$file"
                continue
            }
        esac

        local _file=${KISS_ROOT:+"$KISS_ROOT/"}${file%%/}

        # Queue all directory symlinks for later removal.
        if [ -h "$_file" ] && [ -d "$_file" ]; then
            case $file in /*/*/)
                set -- "$@" "$_file"
            esac

        # Remove empty directories.
        elif [ -d "$_file" ]; then
            rmdir "$_file" 2>/dev/null || :

        # Remove everything else.
        else
            rm -f "$_file"
        fi
    done

    # Remove all broken directory symlinks.
    for sym do
        [ -e "$sym" ] || rm -f "$sym"
    done
}

pkg_etc() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    local hash="$(delegate "sh256" "$tar_dir/$file" "$KISS_ROOT$file")"

    local sum_new=${hash%%"$newline"*}
    local sum_sys=${hash#*"$newline"}

    read -r sum_old <&3 2>/dev/null ||:

    # Compare the three checksums to determine what to do.
    case ${sum_old:-null}${sum_sys:-null}${sum_new} in
        # old = Y, sys = X, new = Y
        "${sum_new}${sum_sys}${sum_old}")
            return 1
        ;;

        # old = X, sys = X, new = X
        # old = X, sys = Y, new = Y
        # old = X, sys = X, new = Y
        "${sum_old}${sum_old}${sum_old}"|\
        "${sum_old:-null}${sum_sys}${sum_sys}"|\
        "${sum_sys}${sum_old}"*)

        ;;

        # All other cases.
        *)
            war "$FUNCNAME" "$pkg_name" "saving $file as $file.new"
            _file=$_file.new
        ;;
    esac
}

pkg_removable() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Check if a package is removable and die if it is not.
    # A package is removable when it has no dependents.
    log "$FUNCNAME" "$pkg" "Checking if package removable"

    cd "$sys_db"
    set +f

    local pkg="$1"

    ! grep -lFx -- "$pkg" */depends ||
        die "$FUNCNAME" "$pkg" "Not removable, has dependents"

    set -f
    cd "$OLDPWD"
}

# $1 pkg : package name
# could be subshell function before local version
pkg_remove() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg="$1"
    # Remove a package and all of its files. The '/etc' directory is handled
    # differently and configuration files are *not* overwritten.
    [ -d "$sys_db/$pkg" ] || die "$FUNCNAME" "'$pkg' not installed"

    # Intended behavior.
    # shellcheck disable=2030,2031
    equ "$KISS_FORCE" 1 || pkg_removable "$pkg"

    # Block being able to abort the script with 'Ctrl+C' during removal.
    # Removes all risk of the user aborting a package removal leaving an
    # incomplete package installed.
    trap '' INT

    # arg1: pre-remove
    # arg2: package name
    # arg3: path to installed database
    run_hook_pkg pre-remove "$pkg"
    run_hook     pre-remove "$pkg" "$sys_db/$pkg"

    log "$FUNCNAME" '$pkg' "$pkg"
    log "$FUNCNAME" "removing package" "$pkg"
    # Make a backup of any etcsums if they exist.
    [ -f "$sys_db/$pkg/manifest" ] && {
        [ ! -s "$sys_db/$pkg/etcsums" ] &&
        pkg_remove_files < "$sys_db/$pkg/manifest" || {
            local etcsums_clone="$(delegate "slot_push" "$FUNCNAME" "$sys_db/$pkg/etcsums")"
            pkg_remove_files < "$sys_db/$pkg/manifest" 3< "$etcsums_clone"
        }
    }
    # Reset 'trap' to its original value. Removal is done so
    # we no longer need to block 'Ctrl+C'.
    trap pkg_clean EXIT INT

    log "$FUNCNAME" "$pkg" "removed successfully"
}

# could be subshell function before local version
# $1 pkg      : package name
# $2 depends  : depends file address
# $3 missing  : missing package(s)
installable() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg="$1"
    local depents="$2"
    local missing="$3"
    # Check if a package is removable and die if it is not.
    # A package is removable when all of its dependencies
    # are satisfied.
    log "$FUNCNAME" "$pkg" "Checking if package installable"

    log "$FUNCNAME" '$PWD'     "$PWD"
    log "$FUNCNAME" '$pkg'     "$pkg"
    log "$FUNCNAME" '$depents' "$depents"

    null "$missing" || log "$FUNCNAME" '$missing' "$missing"

    # False positive.
    # shellcheck disable=2094
    ! [ -f "$depents" ] ||

    while read -r dep dep_type || ok "$dep"; do
        debug "$FUNCNAME" '$dep'    "$dep"
        debug "$FUNCNAME" '$sys_db' "$sys_db"
        case "$dep $dep_type" in [!\#]?*\ )
            { [ ! -d "$sys_db/$dep" ] && log "$FUNCNAME" '$dep not found' "$dep"; } || continue

            debug "$FUNCNAME" '$dep'      "$dep"
            war   "$FUNCNAME" '$dep'      "$dep"
            debug "$FUNCNAME" '$dep_type' "$dep_type"
            war   "$FUNCNAME" '$dep_type' "$dep_type"
            missing=$(($missing + 1))
            set -- "$pkg" "$depents" "$missing"
            # set -- "$1" "$2" "$(($3 + 1))"
        esac
    done < "$depents"
    null "$missing" || log "$FUNCNAME" '$missing' "$missing"
    debug "$FUNCNAME" '$3' "$3"
    debug "$FUNCNAME" '$missing' "$missing"
    case ${missing:-0} in [1-9]*)
        die "$FUNCNAME" "$pkg" "Package not installable, missing $missing package(s)"
    esac
}

# $1 pkg : package name
pkg_install() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg="$1"
    log "$FUNCNAME" '$pkg' "$pkg"
    log "$FUNCNAME" '$repo_dir' "$repo_dir[global]"
    # Install a built package tarball.
    #
    # Package installation works similarly to the method used by Slackware in
    # some of their tooling. It's not the obvious solution to the problem,
    # however it is the best solution at this given time.
    #
    # When an installation is an update to an existing package, instead of
    # removing the old version first we do something different.
    #
    # The new version is installed overwriting any files which it has in
    # common with the previously installed version of the package.
    #
    # A "diff" is then generated between the old and new versions and contains
    # any files existing in the old version but not the new version.
    #
    # The package manager then goes and removes these files which leaves us
    # with the new package version in the file system and all traces of the
    # old version gone.
    #
    # For good measure the package manager will then install the new package
    # an additional time. This is to ensure that the above diff didn't contain
    # anything incorrect.
    #
    # This is the better method as it is "seamless". An update to busybox won't
    # create a window in which there is no access to all of its utilities.
    local tar_file
    local pkg_name
    # Install can also take the full path to a tarball. We don't need to check
    # the repository if this is the case.
    case $pkg in
        *.tar.*)
            log "$FUNCNAME" 'tar $pkg' "$pkg"

            [ -f "$pkg" ] || die "$FUNCNAME" "File '$pkg' does not exist"

            tar_file="$pkg"
            pkg_name="${pkg##*/}"
            pkg_name="${pkg_name%@*}"
            ;;

        *)
            log "$FUNCNAME" 'non tar $pkg' "$pkg"

            tar_file="$(delegate "pkg_cache" "$pkg")"
            { [ "$?" -ne 0 ] || null "$tar_file"; } && die "$FUNCNAME" "$pkg" "not yet built"
            pkg_name="$pkg"
            ;;
    esac

    log "$FUNCNAME" '$pkg_name' "$pkg_name"
    log "$FUNCNAME" '$tar_dir'  "$tar_dir"

    mkcd "$FUNCNAME" "$tar_dir"

    # The tarball is extracted to a temporary directory where its contents are
    # then "installed" to the filesystem. Running this step as soon as possible
    # allows us to also check the validity of the tarball and bail out early
    # if needed.

    if ok "$tar_file"; then
        log "$FUNCNAME " '$tar_file' "$tar_file [local]"
    else
        die "$FUNCNAME " '' "\$tar_file not found [local]"
    fi

    decompress "$tar_file" | tar xf -

    # Naively assume that the existence of a manifest file is all that
    # determines a valid KISS package from an invalid one. This should be a
    # fine assumption to make in 99.99% of cases.
    [ -f "$tar_dir/$pkg_db/$pkg_name/manifest" ] || die "$FUNCNAME" "Not a valid KISS package"

    # Intended behavior.
    # shellcheck disable=2030,2031
    equ "$KISS_FORCE" 1 || {
        manifest_validate "$pkg_name"
        installable "$pkg_name" "$tar_dir/$pkg_db/$pkg_name/depends"
    }
    log "$FUNCNAME" '$PWD' "$PWD"
    # arg1: pre-install
    # arg2: package name
    # arg3: path to extracted package
    run_hook pre-install "$pkg_name" "$tar_dir"

    pkg_conflicts "$pkg_name"

    log "$FUNCNAME" "$pkg_name" "Installing package (${tar_file##*/})"

    # If the package is already installed (and this is an upgrade) make a
    # backup of the manifest and etcsums files.
    local manifest="$(delegate "slot_push" "$FUNCNAME" "$sys_db/$pkg_name/manifest")"
    log "$FUNCNAME" '$manifest' "$manifest"

    local manifest_diff="$(delegate "slot_aquire" "$FUNCNAME" "manifest-diff")"
    log "$FUNCNAME" '$manifest_diff' "$manifest_diff"

    tar_man="$tar_dir/$pkg_db/$pkg_name/manifest"

    # Generate a list of files which exist in the currently installed manifest
    # but not in the newer (to be installed) manifest.
    grep -vFxf "$tar_man" "$manifest" > "$manifest_diff" 2>/dev/null ||:

    # Reverse the manifest file so that we start shallow and go deeper as we
    # iterate over each item. This is needed so that directories are created
    # going down the tree.
    local manifest_reverse="$(delegate "slot_aquire" "$FUNCNAME" "manifest-reverse")"
    sort "$tar_man" > "$manifest_reverse"

    # Block being able to abort the script with Ctrl+C during installation.
    # Removes all risk of the user aborting a package installation leaving
    # an incomplete package installed.
    trap '' INT

    if [ ! -s "$sys_db/$pkg_name/etcsums" ]; then
        # Install the package's files by iterating over its manifest.
        pkg_install_files "$pkg_name" -z "$tar_dir" < "$manifest_reverse" &&

        # This is the aforementioned step removing any files from the old
        # version of the package if the installation is an update. Each file
        # type has to be specially handled to ensure no system breakage occurs.
        pkg_remove_files < "$manifest_diff" &&

        # Install the package's files a second time to fix any mess caused by
        # the above removal of the previous version of the package.
        pkg_install_files "$pkg_name" -e "$tar_dir" < "$manifest_reverse"
        result="$?"
    else
        local etcsums_clone="$(delegate "slot_push" "$FUNCNAME" "$sys_db/$pkg_name/etcsums")"
        log "$FUNCNAME" '$etcsums_clone'  "$etcsums_clone"

        # Install the package's files by iterating over its manifest.
        pkg_install_files "$pkg_name" -z "$tar_dir" < "$manifest_reverse" 3< "$etcsums_clone" &&

        # This is the aforementioned step removing any files from the old
        # version of the package if the installation is an update. Each file
        # type has to be specially handled to ensure no system breakage occurs.
        pkg_remove_files < "$manifest_diff" 3< "$etcsums_clone" &&

        # Install the package's files a second time to fix any mess caused by
        # the above removal of the previous version of the package.
        pkg_install_files "$pkg_name" -e "$tar_dir" < "$manifest_reverse" 3< "$etcsums_clone"
        result="$?"
    fi

    if
        [ "$result" -eq 0 ]
    then
        # Reset 'trap' to its original value. Installation is done so we no longer
        # need to block 'Ctrl+C'.
        # trap pkg_clean EXIT INT

        # arg1: post-install
        # arg2: package name
        # arg3: path to installed package database
        run_hook_pkg post-install "$pkg_name"
        run_hook     post-install "$pkg_name" "$sys_db/$pkg_name"

        log "$FUNCNAME" '$sys_db'   "$sys_db"
        log "$FUNCNAME" '$pkg_db'   "$pkg_db"
        log "$FUNCNAME" '$pkg_name' "$pkg_name"
        log "$FUNCNAME" '$tar_dir'  "$tar_dir"  # /root/.cache/kiss/proc/$pkg_name/extract
        log "$FUNCNAME" '$pkg_dir'  "$pkg_dir"  # /root/.cache/kiss/proc/$pkg_name/pkg
        log "$FUNCNAME" '$repo_dir' "$repo_dir"
        log "$FUNCNAME" '$pkg_dir/$pkg_db/$pkg_name' "$pkg_dir/$pkg_db/$pkg_name"
        log "$FUNCNAME" '$tar_dir/$pkg_db/$pkg_name' "$tar_dir/$pkg_db/$pkg_name"

        [ -d "$pkg_dir/$pkg_db/$pkg_name" ] || echo "Directory does not exist"

        local repo_ver="$(cat "$pkg_dir/$pkg_db/$pkg_name/version" | awk '{print $1 "-" $2}')"
        index=0
        case "$repo_dir" in
            *"${sys_db}"*)
                packages="$(find "$REPO_ROOT" \( -type d -o -type l \) -path "$sys_db" -prune -o -name "${pkg_name}" -print)"
                if [ -n "$packages" ]; then
                    matched=0
                    for pack in $packages; do
                        # Guaranteed performance with step-by-step filtering
                        if diff -bwurB "$sys_db/$pkg_name/version" "$pack/version" > /dev/null 2>&1 &&
                            diff -bwurB "$sys_db/$pkg_name/build" "$pack/build" > /dev/null 2>&1; then

                            found_diff=0
                            temp=
                            diff_list=$(diff -qrN "$sys_db/$pkg_name" "$pack" | awk '{print $2}' | tr "\n" " ")
                            for f in $diff_list; do
                                fn=$(basename $f)
                                [ "keys" != "$fn" ] &&
                                [ "manifest" != "$fn" ] &&
                                [ "etcsums" != "$fn" ] &&
                                [ "depends" != "$fn" ] &&
                                temp="$f $temp"
                            done
                            [ -n "$temp" ] && {
                                found_diff=1
                                for file in $temp; do
                                    log "$FUNCNAME" "diff[$(basename $file)]" "$file"
                                done
                            }
                            [ ${found_diff} -eq 0 ] && {
                                log "$FUNCNAME" "${pkg_name}[$(cat "$pack/version" | awk '{print $1 "-" $2}')]" "$pack"
                                [ -f "$sys_db/$pkg_name/keys" ] && {
                                    while IFS= read -r line || [ -n "$line" ]; do
                                        key="$(echo $line | awk '{print $1}')"
                                        value="$(echo $line | awk '{print $2}')"
                                        [ -n "$key" ] && [ -n "$value" ] &&
                                        [ "$repo_ver" != "$key" ] && [ "$value" != "$pack" ] && {
                                            printf "%-4s %-15s = %s\n" "$index" "$key" "$value" > /dev/stderr
                                            printf "%-15s %s\n" "$key" "$value" >> "$sys_db/$pkg_name/keys-temp"
                                        }
                                    done < "$sys_db/$pkg_name/keys"
                                }
                                printf "%-15s %s\n" "$repo_ver" "$pack" >> "$sys_db/$pkg_name/keys-temp"
                                \mv -f "$sys_db/$pkg_name/keys-temp" "$sys_db/$pkg_name/keys"
                                matched=1
                                break
                            }
                            index=$(($index + 1))
                        fi
                    done
                    [ $matched -eq 0 ] &&
                    echo "No repositories contain this version of package. Please back it up manually."
                else
                    log "$FUNCNAME" "backup $sys_db/$pkg_name to" "$repo_main/extra/"
                    rsync -aqz "$sys_db/$pkg_name" "$repo_main/extra/"
                fi
                ;;
            *)
                [ -f "$sys_db/$pkg_name/keys" ] && {
                    while IFS= read -r line || [ -n "$line" ]; do
                        key="$(echo $line | awk '{print $1}')"
                        value="$(echo $line | awk '{print $2}')"
                        [ -n "$key" ] && [ -n "$value" ] &&
                        [ "$repo_ver" != "$key" ] && [ "$value" != "$repo_dir" ] && {
                            printf "%-4s %-15s = %s\n" "$index" "$key" "$value" > /dev/stderr
                            printf "%-15s %s\n" "$key" "$value" >> "$sys_db/$pkg_name/keys-temp"
                        }
                        index=$(($index + 1))
                    done < "$sys_db/$pkg_name/keys"
                }
                printf "%-15s %s\n" "$repo_ver" "$repo_dir" >> "$sys_db/$pkg_name/keys-temp"
                \mv -f "$sys_db/$pkg_name/keys-temp" "$sys_db/$pkg_name/keys"
                log "$FUNCNAME" "repo[$(cat "$sys_db/$pkg_name/keys" | grep "$repo_ver" | awk '{print $1}')]" \
                    "$(cat "$sys_db/$pkg_name/keys" | grep "$repo_ver" | awk '{print $2}')"
                ;;
        esac

        log "$FUNCNAME" "$pkg_name" "Installed successfully"

    else
        # pkg_clean
        war "$FUNCNAME" "$pkg_name" "Failed to install package."
        die "$FUNCNAME" "$pkg_name" "Filesystem now dirty, manual repair needed."
    fi
}

pkg_update() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    log "$FUNCNAME" "" "Updating repositories"

    # Create a list of all repositories.
    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    { IFS=:; set -- $KISS_PATH; unset IFS; }

    # Update each repository in '$KISS_PATH'.
    for repo do
        local repo_type
        if git -C "$repo" rev-parse 'HEAD@{upstream}' >/dev/null 2>&1; then
            repo_type=git

            # Get the Git repository root directory.
            local subm=$(git -C "$repo" rev-parse --show-superproject-working-tree)
            repo=$(git -C "${subm:-"$repo"}" rev-parse --show-toplevel)

        elif ! [ -d "$repo" ]; then
            continue
        else
            unset repo_type
        fi

        pkg_update_repo $repo_type $repo
    done

    pkg_upgrade
}

# $1 repo_type
# $2 repo
pkg_update_repo() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local repo_type=$1
    local repo=$2
    cd "$repo" || die "$FUNCNAME" "Repository '$repo' inaccessible"

    contains "$repos" "$PWD" || {
        repos="$repos $PWD"

        log "$FUNCNAME" '$PWD' "$PWD"

        am_owner "$PWD" || {
            printf 'Need "%s" to update\n' "$user"
            set -- as_user
        }

        # arg1: pre-update
        # arg2: need su?
        # arg3: owner
        # env:  PWD is path to repository
        run_hook pre-update "$#" "$user"

        case $repo_type in git)
            pkg_update_git "$@"
        esac

        # arg1: post-update
        # env:  PWD is path to repository
        run_hook post-update
    }
}

pkg_update_git() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Display whether or not signature verification is enabled.
    case $(git config --get merge.verifySignatures) in true)
        printf 'Signature verification enabled.\n'
    esac

    "$@" git pull
    "$@" git submodule update --remote --init -f
}

pkg_upgrade() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    log "$FUNCNAME" "Checking for new package versions"
    set +f

    for pkg in "$sys_db/"*; do set -f
        tmp_dirs "$pkg" "reset";
        IFS=$'\3' read -r repo_dir ver_pre rel_pre repo_ver repo_rel < <(pkg_version "$FUNCNAME" "${pkg##*/}" "" "" "$sys_db")
        null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
        null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"
        IFS=$'\3' read -r repo_dir ver_pre rel_pre repo_ver repo_rel < <(pkg_version "$FUNCNAME" "${pkg##*/}")
        null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
        null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"

        # Detect repository orphans (installed packages with no
        # associated repository).
        case $repo_dir in */var/db/kiss/installed/*)
            _repo_orp="$_repo_orp$newline${pkg##*/}"
        esac

        # Compare installed packages to repository packages.
        equ "$ver_pre-$rel_pre" "$repo_ver-$repo_rel" || {
            set -- "$@" "${pkg##*/}"

            printf '%s %s => %s\n' \
                "${pkg##*/}" "$ver_pre-$rel_pre" "$repo_ver-$repo_rel"
        }
    done

    case $_repo_orp in *?*)
        war "$FUNCNAME" "" "Packages without repository$_repo_orp"
    esac

    build_install=0
    prefer_cache=1

    ! contains "$*" kiss || {
        log "$FUNCNAME" "" "Detected package manager update"
        log "$FUNCNAME" "" "The package manager will be updated first"

        prompt
        pkg_build_all kiss

        log "$FUNCNAME" "" "Updated the package manager"
        log "$FUNCNAME" "" "Re-run 'kiss update' to update your system"
        return 0
    }

    for _ do
        IFS=$'\3' read -r order redro < <(pkg_order "$@")

        # Intentional, globbing disabled.
        # shellcheck disable=2046,2086
        set -- $order

        prompt "Packages to update ($#): $*"
        pkg_build_all "$@"
        log "$FUNCNAME" "" "Updated all packages"
        return 0
    done

    log "$FUNCNAME" "" "Nothing to do"
}

trace_line='Error in function $FUNCNAME at line $LINENO'

pkg_clean() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Clean up on exit or error. This removes everything related to the build.
    # If _KISS_LVL is (1) we are the top-level process - the entire cache will
    # be removed. If _KISS_LVL is any other value, remove only the tar directory.

    log "$FUNCNAME" '$pkg'    "$pkg"
    log "$FUNCNAME" '$action' "$action"

    debug "$FUNCNAME" '$tar_dir'    "$tar_dir"
    debug "$FUNCNAME" '$KISS_DEBUG' "$KISS_DEBUG"
    debug "$FUNCNAME" '$_KISS_LVL'  "$_KISS_LVL"

    case $action in
        i|install)
            tmp_clean
    esac

    case ${KISS_DEBUG:-0}-${_KISS_LVL:-1} in
        0-1) [ -n "$proc" ] && [ "$proc/$pkg" != "/$pkg" ] && \rm -rf "$proc/$pkg" ;;
        0-*) [ -n "$tar_dir" ] && [ "$(occurrences "$tar_dir" "/")" -ne "1" ] && \rm -rf "$tar_dir"
    esac
}

# $@ :
pkg_help_ext() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    log "$FUNCNAME" "" 'Installed extensions (kiss-* in PATH)'
    debug "$FUNCNAME" '$#' "$#"

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2030,2031
    set -- $(delegate "pkg_find" kiss-\* all -x "$PATH")
    null "$1" && die "$FUNCNAME" '$repo_dir' "$1"

    local path_list
    # To align descriptions figure out which extension has the longest
    # name by doing a simple 'name > max ? name : max' on the basename
    # of the path with 'kiss-' stripped as well.
    #
    # This also removes any duplicates found in '$PATH', picking the
    # first match.
    for path do
        p=${path#*/kiss-}

        [ -d "$path" ] && continue
        case " $seen " in *" $p "*)
            shift
            continue
            ;;
            *) path_list="$path_list $path"
        esac

        seen=" $seen $p "
        max=$((${#p} > max ? ${#p}+1 : max))
    done
    log "$FUNCNAME" '$#' "$#"
    set -- $path_list
    log "$FUNCNAME" '$#' "$#"
    IFS=\#$IFS

    # Print each extension, grab its description from the second line
    # in the file and align the output based on the above max.
    for path do
        # Open the extension as a file descriptor.
        exec 3< "$path"

        # Grab the second line in the extension.
        { read -r _ && IFS=\#$IFS read -r _ cmt; } <&3

        printf "%b->%b %-${max}s %s\\n" \
            "$c1" "$c3" "${path#*/kiss-}" "$cmt"
    done >&2
}

trap_on() {
    # Catch errors and ensure that build files and directories are cleaned
    # up before we die. This occurs on 'Ctrl+C' as well as success and error.
    trap trap_INT  INT
    trap trap_EXIT EXIT
}

trap_INT() {
    run_hook SIGINT
    exit 1
}

trap_EXIT() {
    pkg_clean
    run_hook SIGEXIT
}

trap_off() {
    # Block being able to abort the script with 'Ctrl+C'. Removes all risk of
    # the user aborting a package install/removal leaving an incomplete package
    # installed.
    trap "" INT EXIT
}

init_dirs() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local ppwd="$1"

    local ppid="$(echo $PPID)"
    local uid="$(id -u)"

    [ ! -d "/tmp/kiss/$uid" ] && mkdir -p "/tmp/kiss/$uid"

    # cd "/tmp/kiss/$uid"
    # list="$(ls -x /tmp/kiss/$uid)"
    # for dir in $list; do
    #     [ "$dir" != "${ppid}" ] && [ "$(expr substr $dir 1 1)" != '/' ] && \rm -rf "$dir";
    # done
    # cd $ppwd

    log_dir_original="/tmp/kiss/$uid"
    mkdir -p "$log_dir_original"
    null "$log_dir" && log_dir="$log_dir_original"
    touch "$log_dir_original/build.log"

    # Root directory.
    KISS_ROOT=${KISS_ROOT%"${KISS_ROOT##*[!/]}"}

    # This allows for automatic setup of a KISS chroot and will
    # do nothing on a normal system.
    mkdir -p "$KISS_ROOT/" 2>/dev/null || :

    # System package database.
    sys_db=$KISS_ROOT/${pkg_db:=var/db/kiss/installed}
    sys_ch=$KISS_ROOT/${cho_db:=var/db/kiss/choices}

    # Top-level cache directory.
    cac_dir=${XDG_CACHE_HOME:-"${HOME%"${HOME##*[!/]}"}/.cache"}
    cac_dir=${cac_dir%"${cac_dir##*[!/]}"}/kiss

    # Persistent cache directories.
    src_dir=$cac_dir/sources


    # Top-level Temporary cache directory.
    proc=${KISS_TMPDIR:="$cac_dir/proc"}
    proc=${proc%"${proc##*[!/]}"}

    log "$FUNCNAME" '${time%-*}' "${time%-*}"
    log "$FUNCNAME" '${time}'    "${time}"
    log "$FUNCNAME" '$sys_db'    "$sys_db"
    log "$FUNCNAME" '$log_dir'   "$log_dir"
    log "$FUNCNAME" '$ppid'      "$ppid"
}

tmp_dirs() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg="$1"
    debug "$FUNCNAME" '$pkg' "$pkg"

    null "$log_dir_original" && die "$FUNCNAME" "\$log_dir_original is not defined"

    pkg_root="$proc/$pkg"

    # Temporary cache directories.
    mak_dir="$pkg_root/build"
    pkg_dir="$pkg_root/pkg"
    tar_dir="$pkg_root/extract"
    tmp_dir="$pkg_root/tmp"
    log_dir="$pkg_root/logs"
    bin_dir="$pkg_root/bin"

    [ -d "${pkg_root}" ] && equ "reset" "$2" && {
        [ "$mak_dir" != "/build" ]   && \rm -rf "$mak_dir";
        [ "$pkg_dir" != "/pkg" ]     && \rm -rf "$pkg_dir";
        [ "$tar_dir" != "/extract" ] && \rm -rf "$tar_dir";
        [ "$tmp_dir" != "/tmp" ]     && \rm -rf "$tmp_dir";
        [ "$bin_dir" != "/bin" ]     && \rm -rf "$bin_dir";
    }

    # set +e will bypass the following exit
    # [ -d "${pkg_root}" ] && equ "reset" "$2" && \rm -rf "$pkg_root"
    # Removing "|| :", and adding the following line will get the same effect
    # [ $? -ne 0 ] && log "$FUNCNAME" "" "[] error occurred"

    mkdir -p "$src_dir" "$log_dir" "$bin_dir" \
        "$mak_dir" "$pkg_dir" "$tar_dir" "$tmp_dir"


    [ "$(readlink "${log_dir}/build.log")" != "${log_dir_original}/build.log" ] &&
    ln -sf "${log_dir_original}/build.log" "${log_dir}/build.log"

    log "$FUNCNAME" '$log_dir_original' "$log_dir_original"

    # [ -z "$time" ] && time=$(date +%Y-%m-%d-%H:%M)

    log "$FUNCNAME" '$log_dir' "$log_dir"
    log "$FUNCNAME" '$bin_dir' "$bin_dir"

    # printf "%s" "$pkg_root"
}

tmp_clean() {
    set -efE
    trap 'Error in function $FUNCNAME at line $LINENO' ERR
    { [ "$log_dir" = "$log_dir_original" ] &&
    [ -f "$log_dir_original/build.log" ]; } || {
        debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
        debug "$FUNCNAME" '$log_dir' "$log_dir"
        debug "$FUNCNAME" '$log_dir_original' "$log_dir_original"
        [ -d "${log_dir}" ] &&
        [ -d "${log_dir_original}" ] &&
        [ -f "${log_dir_original}/build.log" ] && {
            \mv -f "${log_dir_original}/build.log" "${log_dir}/build.log"
        }
    }
}

args() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Parse script arguments manually. This is rather easy to do in our case
    # since the first argument is always an "action" and the arguments that
    # follow are all package names.
    action="$1"
    log "$FUNCNAME" '$action' "$action"

    shift "$(($# != 0))"

    # Ensure that arguments do not contain invalid characters. Wildcards can
    # not be used here as they would conflict with kiss extensions.
    case $action in
        a|alternatives)
            case $1 in *\**|*\!*|*\[*|*\ *|*\]*|*/*|*"$newline"*)
                die "$FUNCNAME" "Invalid argument: '!*[ ]/\\n' ($1)";
            esac
        ;;

        b|build|c|checksum|d|download|i|install|l|list|r|remove)
            for _arg do case ${action%%"${action#?}"}-$_arg in
                i-*\!*|i-*\**|i-*\[*|i-*\ *|i-*\]*|i-*"$newline"*)
                    die "$FUNCNAME" "Invalid argument: '!*[ ]\\n' ('$_arg')"
                    ;;

                [!i]-*\!*|[!i]-*\**|[!i]-*\[*|[!i]-*\ *|\
                [!i]-*\]*|[!i]-*/*|[!i]-*"$newline"*)
                    die "$FUNCNAME" "Invalid argument: '!*[ ]/\\n' ('$_arg')"
                    ;;
            esac done

            # When no arguments are given on the command-line, use the basename
            # of the current directory as the package name and add the parent
            # directory to the running process' KISS_PATH.
            case ${action%%"${action#?}"}-$# in [!l]-0)
                export KISS_PATH=${PWD%/*}:$KISS_PATH
                set -- "${PWD##*/}"
            esac

            # Search the installed database first when removing packages. Dependency
            # files may differ when repositories change. Removal is not dependent on
            # the state of the repository.
            case $action in r|remove)
                export KISS_PATH=$sys_db:$KISS_PATH
            esac

            # Order the argument list based on dependence.
            IFS=$'\3' read -r order redro < <(pkg_order "$@")
            for pkg in $order; do
                tmp_dirs "$pkg"
            done
            # Intentional, globbing disabled.
            # shellcheck disable=2046,2086
            set -- $order
            ;;
    esac

    # Need to increment _KISS_LVL here to ensure we don't wipe the cache
    # early by non-asroot invocations.
    export _KISS_LVL=$((_KISS_LVL + 1))

    # Rerun the script as root with a fixed environment if needed. We sadly
    # can't run singular functions as root so this is needed.
    #
    # Intended behavior.
    # shellcheck disable=2030,2031

    case $action in a|alternatives|i|install|r|remove)
        if ok "$action" && ! am_owner "$KISS_ROOT/"; then
            trap_off
            as_user env \
                LOGNAME="$user" \
                HOME="$HOME" \
                XDG_CACHE_HOME="$XDG_CACHE_HOME" \
                KISS_COMPRESS="$KISS_COMPRESS" \
                KISS_PATH="$KISS_PATH" \
                KISS_FORCE="$KISS_FORCE" \
                KISS_ROOT="$KISS_ROOT" \
                KISS_CHOICE="$KISS_CHOICE" \
                KISS_COLOR="$KISS_COLOR" \
                KISS_TMPDIR="$KISS_TMPDIR" \
                KISS_PID="$KISS_PID" \
                _KISS_LVL="$_KISS_LVL" \
                "$0" "$action" "$@"

            trap_on
            return
        fi
        ;;
    esac

    # Clear temporary files

    # # This will cancell the process on busybox 1.35.0-2, when test variables has definition
    # # and set -e
    # [ -z "$KISS_DEBUG" ] || log "$FUNCNAME" '$KISS_DEBUG' "$KISS_DEBUG"
    # null "$KISS_DEBUG" ||
    # log "$FUNCNAME" '$KISS_DEBUG' "$KISS_DEBUG"
    # This will recover the process
    # [ -z "$KISS_DEBUG" ] || { :; log "$FUNCNAME" '$KISS_DEBUG' "$KISS_DEBUG"; }
    [ -z ${KISS_DEBUG+x} ] ||
    log "$FUNCNAME" '$KISS_DEBUG' "$KISS_DEBUG"

    # Actions can be abbreviated to their first letter. This saves keystrokes
    # once you memorize the commands.
    case $action in
        a|alternatives) pkg_alternatives "$@" ;;
        b|build)        pkg_build_all "$@" ;;
        c|checksum)     for pkg do tmp_dirs "$pkg" "reset"; pkg_checksum "$pkg"; done ;;
        d|download)     for pkg do tmp_dirs "$pkg" "reset"; pkg_source "$pkg"; done ;;
        H|help-ext)     pkg_help_ext "$@" ;;
        i|install)      for pkg do tmp_dirs "$pkg"; pkg_install "$pkg"; done ;;
        l|list)         pkg_list_version "$FUNCNAME" "$@" ;;
        p|pick)         pick_up "$1" "$2" ;;
        r|remove)       for pkg in $redro; do pkg_remove "$pkg"; done ;;
        s|search)       for pkg do for item in $(delegate "pkg_find" "$pkg" all); do log "$pkg" "$item"; done; done ;;
        u|update)       pkg_update ;;
        U|upgrade)      pkg_upgrade ;;
        v|version)      # printf '5.5.28\n' ;;
            IFS=$'\3' read -r _ _ _ repo_ver repo_rel < <(pkg_version "$FUNCNAME" "$1" "" "" "$sys_db")
            log "$FUNCNAME" '$repo_ver' "$repo_ver"
            log "$FUNCNAME" '$repo_rel' "$repo_rel"
            ;;
        '')
            log "$FUNCNAME" 'kiss [a|b|c|d|i|l|r|s|u|U|v] [pkg]...'
            log "$FUNCNAME" 'alternatives List and swap alternatives'
            log "$FUNCNAME" 'build'    'Build packages'
            log "$FUNCNAME" 'checksum' 'Generate checksums'
            log "$FUNCNAME" 'download' 'Download sources'
            log "$FUNCNAME" 'install'  'Install packages'
            log "$FUNCNAME" 'list'     'List installed packages'
            log "$FUNCNAME" 'pick'     'Query and pick up package'
            log "$FUNCNAME" 'remove'   'Remove packages'
            log "$FUNCNAME" 'search'   'Search for packages'
            log "$FUNCNAME" 'update'   'Update the system and repositories'
            log "$FUNCNAME" 'upgrade'  'Update the system'
            log "$FUNCNAME" 'version'  'Package version'

            printf '\nRun "kiss [H|help-ext]" to see all actions\n'
            ;;

        *)
            # _KISS_LVL must be reset here so the that any extensions
            # which call the package manager do not increment the value
            # further than the parent instance.
            log "$FUNCNAME" '$#' "$#"
            log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
            log "$FUNCNAME" '$2-$#' "$2-$#"

            local kiss_action="$(delegate "pkg_find" "kiss-$action*" "" -x "$PATH")"
            null "$kiss_action" && die "$FUNCNAME" '$kiss_action' "$kiss_action"

            log "$FUNCNAME" '$sys_db'      "$sys_db"
            log "$FUNCNAME" '$kiss_action' "$kiss_action"


            _KISS_LVL=0 "$kiss_action" "$@"
            ;;
    esac
}

# Need a nicer way of detecting architecture
determine_arch(){
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local _arch="$($cmd_elf -a -W $1 | grep 'Machine:')"
    local _endian="$($cmd_elf -a -W $1 | grep 'Data:')"

    case "$_arch $_endian" in
        *AArch64*little*)   arch="aarch64-linux-musl";;
        *AArch64*big*)      arch="aarch64_be-linux-musl";;
        *ARM*)              arch="armv7-linux-musleabihf";;
        *Intel*80386*)      arch="i686-linux-musl";;
        *PowerPC64*little*) arch="powerpc64le-linux-musl";;
        *PowerPC64*big*)    arch="powerpc64-linux-musl";;
        *PowerPC*little*)   arch="powerpcle-linux-musl";;
        *PowerPC*big*)      arch="powerpc-linux-musl";;
        *X86-64*)           arch="x86_64-linux-musl";;
        *RISC-V*)           arch="riscv64-linux-musl";;
        *) die "$FUNCNAME" "Unknown architecture: $_arch / $_endian";;
    esac

    echo $arch
}

cross_flags() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    export KISS_XBUILD_TRIPLE="$(clang -print-target-triple | sed 's/-unknown//')"
    export KISS_XHOST_TRIPLE="${KISS_XHOST_TRIPLE:-$(determine_arch $KISS_ROOT/usr/bin/bzip2)}"

    set -f
    old_ifs=$IFS
    IFS=-

    set -- $KISS_XBUILD_TRIPLE
    export KISS_XBUILD_ARCH=$1
    export KISS_XBUILD_SYS=$2
    export KISS_XBUILD_ABI=$3

    set -- $KISS_XHOST_TRIPLE
    export KISS_XHOST_ARCH=$1
    export KISS_XHOST_SYS=$2
    export KISS_XHOST_ABI=$3

    IFS=$old_ifs
    set +f

    # Flags used for pkg-config
    export PKG_CONFIG_PATH=
    export PKG_CONFIG_LIBDIR=${KISS_ROOT}/usr/lib/pkgconfig:${KISS_ROOT}/usr/share/pkgconfig
    export PKG_CONFIG_SYSROOT_DIR=${KISS_ROOT}

    # Don't carry over flags if this is a cross build
    if [ ! -z $KISS_ROOT ]; then
        unset CFLAGS
        unset CXXFLAGS
        unset LDFLAGS
    fi

    # Allow setting of chroot-specific cflags
    flagfile="$KISS_ROOT/etc/os-buildflags"
    if [ -f "$flagfile" ]; then
        source $flagfile
    fi

    # Set the compiler target architecture
    if [ -z "$KISS_ROOT" ]; then
        # Local build. Allow user-set CFLAGS as per normal KISS, or override them in /etc/os-buildflags
        export CC="${CC:-clang}"
        export CXX="${CXX:-clang++}"
    else
        # Cross build. CFLAGS will always come from $KISS_ROOT/etc/os-buildflags
        flags="--target=$KISS_XHOST_TRIPLE --sysroot=${KISS_ROOT} -fPIC"
        export   CFLAGS="$flags $CFLAGS"
        export CXXFLAGS="$flags $CXXFLAGS"
        export  LDFLAGS="--sysroot=$KISS_ROOT $LDFLAGS"
        export       CC="clang $CFLAGS"
        export      CXX="clang++ $CXXFLAGS"
    fi
}

repo_setup() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Set variables which help with cross building
    if [ -z "$KISS_BINREPO" ]; then
        cross_flags

        # Bin repo will be "local" for normal builds, for chroot builds
        # it will be the last part of $KISS_ROOT appended with md5sum of
        # the full $KISS_ROOT path. This keeps packages built for different
        # root directories in separate directories.
        local lastbit="${KISS_ROOT##*/}"
        if null "$lastbit"; then
            binrepo="local"
        else
            binrepo="${lastbit}_$(echo "$KISS_ROOT" | md5sum | cut -c1-32)"
        fi
    else
        binrepo="$KISS_BINREPO"
    fi
}


main() {
    # http://mywiki.wooledge.org/BashFAQ/105
    # Globally disable globbing and enable exit-on-error.

    # https://unix.stackexchange.com/questions/151771/getting-wrong-lineno-for-a-trapped-function
    set -efE # set -ef # set -exf
    trap 'eval echo "${trace_line}"' ERR

    # Store the original working directory to ensure that relative paths
    # passed by the user on the command-line properly resolve to locations
    # in the filesystem.
    ppwd=$PWD

    # Store the date and time of script invocation to be used as the name of
    # the log files the package manager creates during builds.
    time=$(date +%Y-%m-%d-%H:%M)

    # Never know when you're gonna need one of these.
    newline="
"
    # Color can be disabled via the environment variable KISS_COLOR. Colors are
    # also automatically disabled if output is being used in a pipe/redirection.
    equ "$KISS_COLOR" 0 || { :; ! [ -t 2 ]; } || { :
        if [ -z "$KISS_ROOT" ]; then
            c1='\033[1;33m'
            c2='\033[1;34m'
            c3='\033[m'
        else
            c1='\033[1;33m'
            c2='\033[1;35m'
            c3='\033[m'
        fi
    }

    init_dirs "$ppwd"
    log "$FUNCNAME" '$log_dir_original' "$log_dir_original[global]"
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    log "$FUNCNAME" '$KISS_ROOT' "$KISS_ROOT"

    # Defaults for environment variables.
    : "${KISS_COMPRESS:=gz}"
    : "${KISS_PID:=$$}"
    : "${LOGNAME:?POSIX requires LOGNAME be set}"

    log "$FUNCNAME" '$KISS_PID' "$KISS_PID"
    log "$FUNCNAME" '$PPID' "$PPID"

    # Figure out which 'sudo' command to use based on the user's choice or what
    # is available on the system.
    cmd_su=${KISS_SU:-"$(
        command -v /usr/bin/ssu  ||
        command -v /usr/bin/doas ||
        command -v /usr/bin/sudo ||
        command -v /usr/bin/su
    )"} || cmd_su=/usr/bin/su

    # Figure out which utility is available to dump elf information.
    cmd_elf=${KISS_ELF:-"$(
        command -v /usr/bin/readelf      ||
        command -v /usr/bin/eu-readelf   ||
        command -v /usr/bin/llvm-readelf
    )"} || cmd_elf=/usr/bin/ldd

    # Figure out which sha256 utility is available.
    cmd_sha=${KISS_CHK:-"$(
        command -v /usr/bin/openssl   ||
        command -v /usr/bin/sha256sum ||
        command -v /usr/bin/sha256    ||
        command -v /usr/bin/shasum    ||
        command -v /usr/bin/digest
    )"} || die "$FUNCNAME" "No sha256 utility found"

    # Figure out which download utility is available.
    cmd_get=${KISS_GET:-"$(
        command -v /usr/bin/aria2c ||
        command -v /usr/bin/axel   ||
        command -v /usr/bin/curl   ||
        command -v /usr/bin/wget   ||
        command -v /usr/bin/wget2
    )"} || die "$FUNCNAME" "No download utility found (aria2c, axel, curl, wget, wget2)"


    repo_setup

    # Catch errors and ensure that build files and directories are cleaned
    # up before we die. This occurs on 'Ctrl+C' as well as success and error.
    # trap pkg_clean EXIT INT
    trap_off
    # trap_on

    args "$@"

    tmp_clean
}

main "$@"

# vi:   set filetype=sh syntax=sh :
# vim:  set filetype=sh syntax=sh :
# nvim: set filetype=sh syntax=sh :
