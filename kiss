#!/bin/sh -eEf
# shellcheck source=/dev/null
#
# Simple package manager written in POSIX shell for https://kisslinux.org
#
# The MIT License (MIT)
#
# Copyright (c) 2019-2021 Dylan Araps
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# $1 string
# $2 sub_str
contains() {
    # Check if a "string list" contains a word.
    case " $1 " in *" $2 "*) return 0; esac; return 1
}

equ() {
    # Check if a string is equal to enother.
    # This replaces '[ "$var" = str ]' and '[ "$var" != str ]'.
    case $1 in "$2") return 0 ;; *) return 1; esac
}

ok() {
    # Check if a string is non-null.
    # This replaces '[ "$var" ]', '[ -n "$var" ]'.
    case $1 in '') return 1 ;; *) return 0; esac
}

null() {
    # Check if a string is null.
    # This replaces '[ -z "$var" ]'.
    case $1 in '') return 0 ;; *) return 1; esac
}

ok "$NL" || export NL='
'
ok "$TABSTOP"      || export TABSTOP=4
ok "$WIDTH_SCOPE"  || export WIDTH_SCOPE=20
ok "$WIDTH_KEY"    || export WIDTH_KEY=16
ok "$DELIMITER"    || export DELIMITER=$NL

# Error trace
trace_line() {
    local funcname="$1"
    local lineno="$2"
    log "$FUNCNAME" "Error on '$funcname' at line" "$lineno"
}

# "set -e" did this
# trap 'trace_line "$(readlink -f "$0")" "$LINENO"' ERR

# https://stackoverflow.com/questions/70675246/replacing-newlines-with-the-string-n-with-posix-tools
magic() { { cat -u; printf '\n'; } | awk -v ORS= '{print sep $0; sep="\\n"}'; }

# https://stackoverflow.com/questions/12162010/posix-sh-equivalent-for-bash-s-printf-q
esceval() {
    local caller_name="$1"
    shift 1
    local result=
    case $# in 0) return 0; esac
    local index=0
    while :
    do
        if null "$result"; then
            result="'"
        else
            result="$result'$DELIMITER'"
        fi
        : $((index += 1))
        # debug "$caller_name \$@" "\$$index" "$1"
        case "$1" in
            '')
                result="$result$(printf '%s' "")"
                ;;
            *)
                result="$result$(printf '%s' "$1" | sed "s/'/'\\\\''/g")"
        esac
        shift
        case $# in 0) break; esac
    done
    result="$result'"
    printf '%s' "$result"
}

run() {
    # Print the command, then run it.
    log "$FUNCNAME" "$*"
    "$@"
}

# Some maintainers might print debug information in a function's definition,
# but which function has an output as a return value.
# This delegation makes it sure of only getting the printf content after the last \n,
# which content comes from a
# function_name() { printf "\n%s" "$output"; }
# local var="$(delegate -- "function_name" "$@")"
delegate() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    shift 1
    printf "%s" "$("$@" | awk 'BEGIN{ RS = ""; FS = "\n" }{print $NF}')"
}

# Should be subshell function
occurrences() {
    { [ -z "$1" ] || [ -z "$2" ]; } && die "$FUNCNAME" "Wrong parameters for function"
    local s="$1"
    local sub_str="$2"
    count=0
    until
        t=${s#*"$sub_str"}
        [ "$t" = "$s" ]
    do
        count=$((count + 1))
        s=$t
    done
    printf "%s" "$count"
}

# Should be subshell function
standardize() {
    local path="$1"
    null "$path" || {
        # local src_length=${#path}
        # [ "$(expr substr $path 1 2)" != '//' ] ||
        #     path="$(expr substr $path 2 $((src_length - 1)) )"
        [ "${path:0:2}" != '//' ] || path="${path#/}"

        # src_length=${#path}
        # [ "$(expr substr $path $src_length 1)" != '/' ] ||
        #     path="$(expr substr $path 1 $((src_length - 1)) )"
        [ "${path:$((${#path} - 1))}" != '/' ] || path=${path%/}

        # src_length=${#path}
        # [ "$(expr substr $path $src_length 1)" != '*' ] ||
        #   path="$(expr substr $path 1 $((src_length - 1)) )"
        [ "${path:$((${#path} - 1))}" != '*' ] || path="${path%\*}"
    }
    [ "$path" == "$1" ] || path="$(standardize "$path")"
    printf "%s" "$path"
}


check_errors() {
    # Function. Parameter 1 is the return code
    # Para. 2 is text to display on failure.
    if [ "${1}" -ne "0" ]; then
        die "ERROR #" "${1}" "${2}"
        # as a bonus, make our script exit with the right error code.
        exit ${1}
    fi
}

spaces() {
    local header_width=$1
    local length_header=$2
    local index=1
    local white_spaces=
    while [ $index -le $((header_width - length_header)) ]; do
        white_spaces=" ${white_spaces}"
        let "index = index + 1"
    done
    printf "%s" "${white_spaces}"
}

# 0=$(tabstop_remainder -16)
# 3=$(tabstop_remainder -17)
tabstop_remainder() {
    local length=$1
    local length_with_tabstop=$((length > 0 ? ((length / TABSTOP + 1)) * TABSTOP \
                - length : length - ((length / TABSTOP - 1)) * TABSTOP))
    [ "$length_with_tabstop" -ne "4" ] || length_with_tabstop=0
    printf '%s' "$length_with_tabstop"
}

# ok "$LENGTH_HEADER" || export LENGTH_HEADER="$(delegate -- tabstop_remainder "$((WIDTH_SCOPE + 1 + WIDTH_KEY + 1 ))")"
ok "$LENGTH_HEADER" || export LENGTH_HEADER=$((WIDTH_SCOPE + WIDTH_KEY))

# Print key-value parameter pair with consistent format
# Local variables/contents have to be passed by parameter 3
# $1 scope  : function name
# S2 key    : variable name
# $3 value  : contents
out() {
    # null "$LENGTH_HEADER" && LENGTH_HEADER=28
    local scope="$1"
    local key="$2"
    local contents
    local result=

    # Problematical design
    # if null "$3"; then
    #     # $3 is not set at all
    #     # printf "-z \$3: %s %s %s\n" "$FUNCNAME" '$key' "$key" > /dev/stderr
    #     case "$key" in
    #         *'$'*)
    #             # log 'out' 'fucking $2' "$2"
    #             contents="$(eval echo "$key")"
    #             ;;
    #         *)
    #             contents="$key"
    #             key=""
    #     esac
    # else
        # $3 is empty or something else
        # printf "non -z \$3: %s %s %s\n" "$FUNCNAME" '$key' "$key"
        contents="$3"
    # fi

    local length_scope=$((${#scope} + 1))
    # local length_scope=$((WIDTH_SCOPE > length_scope ? WIDTH_SCOPE : length_scope))
    local margin_scope=$((WIDTH_SCOPE - length_scope))
    [ $margin_scope -ge 0 ] || margin_scope=$(tabstop_remainder length_scope)

    local length_key=$((${#key} + 1))
    # local margin_key=$((WIDTH_KEY - length_key))
    # [ $margin_key -ge 0 ] || margin_key=$(tabstop_remainder margin_key)
    local margin_header=
    null "$contents" || {
        # Using "$scope $key" as a combined header
        margin_header=$((WIDTH_SCOPE + WIDTH_KEY - length_scope - margin_scope - length_key))
        [ $margin_header -ge 0 ] || margin_header=$(tabstop_remainder $((length_scope + margin_scope + length_key)))
    }

    local wrapped_scope="$(printf "%b%s %${margin_scope}.0s%b" "$c1" "$scope" "" "$c3")"
    local wrapped_key="$(printf "%b%s %${margin_header}.0s%b" "${key:+$c2}" "$key" "" "$c3")"
    local wrapped_header="$wrapped_scope$wrapped_key"

    local length_header=$((length_scope + margin_scope + length_key + margin_header))

    local length_applied=0
    result="$wrapped_header"

    [ "$length_header" -le "$LENGTH_HEADER" ] ||
    null "$contents" ||
    result="$result\\$newline$(printf "%${LENGTH_HEADER}.0s" "")"

    null "$contents" ||
    case "$contents" in
        *$newline*|*$cr*)
            # contents="$(printf "%b" "$(printf "%s" "$contents" | magic)" | tr "\n" " ")"
            [ -n "${contents##*"\n"*}" ] ||
            # contents="$(printf "%b" "$(printf "%s" "$contents" | magic)" | tr "$cr" "${newline}")"
            contents="$(printf "%b" "$(printf "%s" "$contents")" | tr "$cr" "${newline}")"
            local index=0
            IFS_ORIGIN=$IFS
            IFS=$newline
            local item_previous=
            for item in $contents; do
                ok "$item" || continue
                [ -z "${item##*"'"*"'"*}" ] || item="'$item'"
                [ "$index" -eq "0" ] || {
                    # length_applied=$length_header
                    length_applied=$LENGTH_HEADER
                    result="$result$(printf "%$(tabstop_remainder $((LENGTH_HEADER + ${#item_previous}))).0s" "")\\$newline"
                }
                result="$result$(printf "%${length_applied}.0s%s" "" "$item")"
                item_previous="$item"
                : $((index += 1))
            done
            IFS=$IFS_ORIGIN
            ;;
        *)
            [ -z "${contents##*"'"*"'"*}" ] || contents="'$contents'"
            result="$result$(printf "%s" "$contents")"
    esac
    printf "%s" "$result"
}

log() {
    local result="$(out "$1" "$2" "$3")"
    printf '%s\n' "$result" > /dev/stderr
    printf '%s\n' "$result" | sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g' 2>&1 >> $log_dir/build.log
}

war() {
    # log "${1} WARNING" "$2" "$3"
    local c1_origin="$c1"
    c1='\033[1;43m'
    local result="$(out "WARNING $1" "$2" "$3")"
    c1=$c1_origin
    printf '%s\n' "$result" > /dev/stderr
    printf '%s\n' "$result" | sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g' 2>&1 >> $log_dir/build.log
}

hint() {
    local c1_origin="$c1"
    c1='\033[1;45m'
    local c2_origin="$c2"
    c2='\033[1;07m'
    local result="$(out "TURNTO $1" "$2" "$3")"
    c2=$c2_origin
    c1=$c1_origin
    printf '%s\n' "$result" > /dev/stderr
    printf '%s\n' "$result" | sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g' 2>&1 >> $log_dir/build.log
}

die() {
    # log "${1} ERROR" "$2" "$3"
    local c1_origin="$c1"
    c1='\033[1;41m'
    local result="$(out "ERROR $1" "$2" "$3")"
    c1=$c1_origin
    printf '%s\n' "$result" > /dev/stderr
    printf '%s\n' "$result" | sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g' 2>&1 >> $log_dir/build.log
    exit 1
}

# How to debug:
# export KISS_DEBUG=1
# set -exf
# https://bugzilla.redhat.com/show_bug.cgi?id=1596312
# strace -f -eexecve q acl 1
# sh -x ldd /bin/sh
debug() {
    # # https://www.shellscript.sh/exitcodes.html
    # # local check_debug=$(set | grep '^KISS_DEBUG=')
    # local check_debug="$(eval echo '$KISS_DEBUG')"
    # check_errors $? "\$check_debug : $check_debug"
    # # log 'debug' "check_debug=$check_debug"
    # if [ "$?" -ne "0" ]; then
    #     echo "Sorry, cannot find KISS_DEBUG in set"
    #     exit 1
    # else
    #     # Will hang up the shell on busybox 1.35.0-2
    #     # ( [ -n "$KISS_DEBUG" ] && \
    #     #         printf "%s\n" "$(out "$1" "$2" "$3")" 2>&1 >> $log_dir/build.log )
    #     [ -z "$KISS_DEBUG" ] || {
    #        [ 0 -ne "$KISS_DEBUG" ]  && \
    #           printf "%s\n" "$(out "$1" "$2" "$3")" 2>&1 >> $log_dir/build.log
                # export KISS_DEBUG=1

                # https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
                # [ -z ${KISS_DEBUG+x} ] || printf "%s\n" "$(out "$1" "$2" "$3")" 2>&1 >> $log_dir/build.log
                printf "%s\n" "$(out "$1" "$2" "$3")" | sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g' 2>&1 >> $log_dir/build.log

                # [ "${KISS_DEBUG+set}" != set ] && printf "%s\n" "$(out "$1" "$2" "$3")" 2>&1 >> $log_dir/build.log
    #     }
    # fi
}

# Aquire an empty file in temporary directory for writing into
# it step by step in the future
# $1 scope        : function name
# $2 src_address  : source file full path or file name
slot_aquire() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local scope="$1"
    log "$FUNCNAME" '$scope' "$scope"
    shift 1
    local pkg_name="$1"
    local src_address="$(standardize "$2")"
    local src_name="${src_address##*/}"
    src_name="${src_name%\?*}"

    # [ "$(expr substr $src_address 1 1)" != '/' ] || {
    #     local src_length=${#src_address}
    #     src_address="$(expr substr $src_address 2 $((src_length - 1)))"
    # }
    [ "${src_address:0:1}" != '/' ] || src_address="${src_address#/}"

    # Create a uniquely named temporary file and store its absolute path
    # in a variable (_stack_topend).
    #
    # To prevent subshell usage and to handle cases where multiple files
    # are needed, this saves the last two temporary files to variables
    # for access by the caller (allowing 3 files at once).
    # _stack_bottom="$_stack_second"
    # _stack_second="$_stack_topend"
    local _stack_topend="$tmp_dir/$pkg_name/$src_address"
    for item in $(\ls -x "$tmp_dir/$pkg_name"); do
        [ "$item" != "$_stack_topend" ] || {
            _stack_topend=""
            break
            die "$FUNCNAME" "$tmp_dir/$pkg_name/$src_address" "failed to create -- already exists"
        }
    done

    # { [ -n "$_stack_bottom" ] && [ -n "$_stack_second" ]; } \
    #     && { [ "$_stack_bottom" = "$_stack_second" ] \
    #         || [ "$_stack_bottom" = "$_stack_topend" ] \
    #         || [ "$_stack_topend" = "$_stack_second" ]; } \
    #     && {
    #     log "$FUNCNAME" '$_stack_bottom' "$_stack_bottom"
    #     log "$FUNCNAME" '$_stack_second' "$_stack_second"
    #     log "$FUNCNAME" '$_stack_topend' "$_stack_topend"
    #     die "$FUNCNAME" "$src_address" "Failed to aquire temporary file"
    # }

    null "$_stack_topend" || {
        local dir_topend="${_stack_topend%/*}"
        [ -d "$dir_topend" ] || \mkdir -p "$dir_topend"

        : > "$_stack_topend" || die "$FUNCNAME" "$src_address" "failed to create the temporary file under $tmp_dir/$pkg_name"
    }
    printf "\n%s" "$_stack_topend"
}

# Copy an extarnal file to temporary directory in one time
# Won't create empty file
# $1 scope        : function name
# $2 src_address  : source file full path
slot_push() {
    trap 'trace_line "$FUNCNAME" "$LINENO"' ERR
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local scope="$1"
    log "$FUNCNAME" '$scope' "$scope"
    shift 1
    local pkg_name="$1"
    local src_address="$2"
    local src_name="${src_address##*/}"
    src_name="${src_name%\?*}"

    # Create a uniquely named temporary file and make a duplicate of
    # the file in '$1' if it exists.
    [ ! -f "$src_address" ] || {
        log "$FUNCNAME" '$src_address' "$src_address"
        local top="$(delegate -- "slot_aquire" "$FUNCNAME" "$pkg_name" "$src_address")"
        null "$top" || \cp -f "$src_address" "$top"
    }
    log "$FUNCNAME" '$top' "$top"
    printf "\n%s" "$top"
}

prompt() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    null "$1" || log "$FUNCNAME" '$1' "$1"

    log "$FUNCNAME" "Continue?: Press Enter to continue or Ctrl+C to abort"

    # korn-shell does not exit on interrupt of read.
    equ "$KISS_PROMPT" 0 || read -r _ || exit 1
}

mkcd() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local scope="$1"
    log "$FUNCNAME" '$scope' "$scope"
    shift 1

    ok "$1" || die "$FUNCNAME" "Trying to create an empty directory"

    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local list="$@"
    local target="$1"
    for item in $list; do
        item="$(standardize "$item")"
        local parent_dir="${item%/*}"
        [ -z "${parent_dir:+x}" ] ||
        # Have not been created yet
        while [ ! -d "$parent_dir" ]; do parent_dir="${parent_dir%/*}"; done
        [ -n "${parent_dir:+x}" ] ||
            die "$FUNCNAME" 'mkdir -p $item' 'Trying to modify system root /'
        [ "$parent_dir" != "$KISS_ROOT" ] ||
            die "$FUNCNAME" 'mkdir -p $item' 'Trying to modify $KISS_ROOT/'
        log "$FUNCNAME" '$parent_dir' "$parent_dir"
        local user="$(stat -c '%U' "$(readlink -f "$parent_dir")")"
        log "$FUNCNAME" '$user' "$user"
        set -- $(delegate -- as_user "$user")
        $@ mkdir -p "$item"
    done
    cd "$target"
    log "$FUNCNAME" '$PWD' "$PWD"
}

# decode right to left
# $1 src_string : body
# $2 substitute : output
# $3 sub_string : input
# replace_left_with_right "$repo_source" "REPO_MAIN" "$REPO_MAIN" "REPO_ROOT" "$REPO_ROOT"
#                ^             ^        |             ^        |
#                |             |________|             |________|
#                |_________________|______________________|
replace_left_with_right() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Replace all occurrences of substrings with substrings. This
    # function takes pairs of arguments iterating two at a time
    # until everything has been replaced.
    local _fnr="$1"
    debug "$FUNCNAME input" '$_fnr' "$_fnr"
    shift 1

    while :; do case $_fnr-$# in
        *"$2"*)
            _fnr=${_fnr%"$2"*}${1}${_fnr##*"$2"}
            debug "$FUNCNAME" '$_fnr' "$_fnr"
            ;;
        *-2) break ;;
        *)
            shift 2
            debug "$FUNCNAME" '$#' "$#"
            debug "$FUNCNAME input" '$sub_string' "$2"
            debug "$FUNCNAME output" '$substitute' "$1"
    esac done
    debug "$FUNCNAME output" '$_fnr' "$_fnr"
    printf "\n%s" "$_fnr"
}

# encode right to left
# encode "$repo_source" "REPO_MAIN" "$REPO_MAIN" "REPO_ROOT" "$REPO_ROOT"
#                ^             ^        |             ^        |
#                |             |________|             |________|
#                |_________________|______________________|
encode() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    [ "$#" -ge "3" ] || die "$FUNCNAME" '$#' "$#"
    local str="$1"
    shift 1

    local key=
    local value=
    local args=

    for index in $(seq 1 2 $#); do
        local key="$(eval "printf '%s' \"\${$index}\"")"
        [ -n "$key" ] || key=\"\"
        local value="$(eval "printf '%s' \"\${$((index + 1))}\"")"
        [ -n "$value" ] || value=\"\"
        args="$args \x03 $key $key $value \\$key \x03"
        # If you have an array, and step in 2 elements at a time
        # set -f -- "$@" "\ " "$key" "$key" "$value" "\\$key" "\ "
    done
    debug "$FUNCNAME" '$args' "$args"
    printf "\n%s" "$(replace_left_with_right "$str" $args)"
}

# Surround each replacement with substitutions to handled escaped markers.
# First substitution turns '\MARKER' into ' ' (can't appear in sources as
# they're already split on whitespace),
# second replaces 'MARKER' with its value
# and the third, turns ' ' into 'MARKER' (dropping \\).
# local _fnr=$(delegate -- decode "${src_url%"${src_url##*[!/]}"}" \
#         "\ " "\\PACKAGE" "$pkg_name" "PACKAGE" "PACKAGE" "\ ")

# decode right to left
# decode "$repo_source" "$REPO_MAIN" "REPO_MAIN" "$REPO_ROOT" "REPO_ROOT"
#                ^             ^        |             ^        |
#                |             |________|             |________|
#                |_________________|______________________|
decode() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    [ "$#" -ge "3" ] || die "$FUNCNAME" '$#' "$#"
    local str="$1"
    shift 1

    local value=
    local key=
    local args=

    # debug "$FUNCNAME" '$10' "$10" # will be treated as $1+0
    # debug "$FUNCNAME" '${10}' "${10}"
    for index in $(seq 1 2 $#); do
        # log "$FUNCNAME" '$index' "$index"
        local value="$(eval "printf '%s' \"\${$index}\"")"
        [ -n "$value" ] || value=\"\"
        debug "$FUNCNAME" '$value' "$value"
        # log "$FUNCNAME" "\$$((index+1))" "$(eval echo \${$((index+1))})"
        local key="$(eval "printf '%s' \"\${$((index + 1))}\"")"
        [ -n "$key" ] || key=\"\"
        debug "$FUNCNAME" '$key' "$key"
        args="$args \x03 \\$key $value $key $key \x03"
        # If you have an array, and step in 2 elements at a time
        # set -f -- "$@" "\ " "\\$key" "$value" "$key" "$key" "\ "
    done
    debug "$FUNCNAME" '$args' "$args"
    printf "\n%s" "$(replace_left_with_right "$str" $args)"
}

# $1 path
am_owner() {
    local path="$1"
    # local user_key=$2
    # local group_key=$3
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"

    # Figure out if we need to change users to operate on
    # a given file or directory.
    path="$(readlink -f "$path")"
    log "$FUNCNAME" '$path' "$path"
    # local inf="$(\ls -ld "$path")" ||
    #     die "$FUNCNAME" "Failed to file information for '$1'"

    # debug "$FUNCNAME" '$inf' "$inf"
    # # Split the ls output into fields.
    # read -r _ _ user _ < <(printf "$inf\n") > /dev/null ||
    #   die "$FUNCNAME" 'printf' "failed on $LINENO"

    local user=$(stat -c '%U' "${path}")
    log "$FUNCNAME" '$user' "$user"

    # [ -z "$user_key" ] || eval "$user_key=$user"
    # log "$FUNCNAME" '$user_key' "$user_key"
    # log "$FUNCNAME" '$(eval echo \$$user_key)' "$(eval echo \$$user_key)"

    local group=$(stat -c '%G' "${path}")
    log "$FUNCNAME" '$group' "$group"
    # [ -z "$group_key" ] || eval "$group_key=$group"
    # log "$FUNCNAME" '$group_key' "$group_key"
    # log "$FUNCNAME" '$(eval echo \$$group_key)' "$(eval echo \$$group_key)"

    # equ "$LOGNAME/$user" "$user/$LOGNAME"

    printf '%s\3%s\n' "$user" "$group"
}

as() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local user_name="$1"
    log "$FUNCNAME" "Using '$cmd_su' (to become $user_name)"
    shift 1

    case ${cmd_su##*/} in
        su) $cmd_su -c $* <&3 $user_name 3<&0 </dev/tty ;;
         *) $cmd_su -u $user_name -- $@
    esac
}

# $1 user_name
as_user() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local user_name="$1"
    log "$FUNCNAME" "Using '$cmd_su' (to become $user_name)"
    shift 1

    case ${cmd_su##*/} in
        su) printf '\n%s' "$cmd_su -c $* <&3 $user_name 3<&0 </dev/tty" ;;
         *) printf '\n%s' "$cmd_su -u $user_name -- $@"
    esac
}

# $1 parameter
# $2 library
# $3 manifest list
pkg_owner() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    ok "$2" || { set +f; set -f -- "$1" "$sys_db"/*/manifest; }

    _owns=$(grep -lxF "$@")
    _owns=${_owns%/*}
    _owns=${_owns##*/}

    ok "$_owns"
}

resolve_path() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    _rpath=$KISS_ROOT/${1#/}
    local _parent
    # Attempt to resolve symlinks by using 'cd'.
    # If this fails, fallback to the file's parent
    # directory.
    if cd -P "${_rpath%/*}" 2>/dev/null; then
        _parent=$PWD
        cd "$OLDPWD"
    else
        _parent=${_rpath%/*}
    fi

    _rpath=${_parent#"$KISS_ROOT"}/${_rpath##*/}
}

run_hook() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local command="$1"
    # Run all hooks in KISS_HOOK (a colon separated
    # list of absolute file paths).
    IFS_ORIGIN=$IFS
    IFS=:

    for hook in ${KISS_HOOK:-}; do case $hook in *?*)
        "$hook" "$@" || die "$FUNCNAME" "$command" "hook failed: '$hook'"
    esac done

    IFS=$IFS_ORIGIN
}

# $1 command
# $2 pkg_name
run_hook_pkg() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local command="$1"
    local pkg_name="$2"

    # Run a hook from the package's database files.
    if [ -x "$sys_db/$pkg_name/$command" ]; then
        log "$FUNCNAME" "$pkg_name" "Running $command hook"
        "$sys_db/$pkg_name/$command"

    elif [ -f "$sys_db/$pkg_name/$command" ]; then
        war "$FUNCNAME" "$pkg_name" "skipping $command hook: not executable"
    fi
}

# $1 tar_file : tar file
decompress() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    log "$FUNCNAME" '$tar_file' "$tar_file [global]"
    local tar_file="$1"

    if ok "$tar_file"; then
        log "$FUNCNAME " '$tar_file' "$tar_file [local]"
    else
        die "$FUNCNAME " '' "\$tar_file not found [local]"
    fi

    case $tar_file in
        *.tbz|*.bz2) bzip2 -d ;;
        *.lzma)      lzma -dc ;;
        *.lz)        lzip -dc ;;
        *.tar)       cat      ;;
        *.tgz|*.gz)  gzip -d  ;;
        *.xz|*.txz)  xz -dcT0 ;;
        *.zst)       zstd -dc ;;
    esac < "$tar_file"
}

sh256() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Higher level sh256 function which filters out non-existent
    # files (and also directories).
    for f do shift
        [ -d "$f" ] || [ ! -e "$f" ] || set -- "$@" "$f"
    done

    printf '\n%s' "$(_sh256 $@)"
}

_sh256() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # There's no standard utility to generate sha256 checksums.
    # This is a simple wrapper around sha256sum, sha256, shasum,
    # openssl, digest, ... which will use whatever is available.
    #
    # All utilities must match 'sha256sum' output.
    #
    # Example: '<checksum>  <file>'
    unset hash

    # Skip generation if no arguments.
    ! equ "$#" 0 || return 0

    # Set the arguments based on found sha256 utility.
    case ${cmd_sha##*/} in
        openssl) set -- dgst -sha256 -r "$@" ;;
         sha256) set -- -r "$@" ;;
         shasum) set -- -a 256 "$@" ;;
         digest) set -- -a sha256 "$@" ;;
    esac

    IFS_ORIGIN=$IFS
    IFS=$newline

    # Generate checksums for all input files. This is a single
    # call to the utility rather than one per file.
    local sha_list="$("$cmd_sha" "$@")" || die "$FUNCNAME" "Failed to generate checksums"

    # Strip the filename from each element.
    # '<checksum> ?<file>' -> '<checksum>'
    for sum in $sha_list; do
        hash=$hash${hash:+"${IFS}"}${sum%% *}
    done

    printf '\n%s' "$hash"
    IFS=$IFS_ORIGIN
}

# Package version of selected $KISS_PATH
# $1 scope
# $2 pkg_name
# $3
# $4 -d / -x
# $5 $KISS_PATH / $sys_db / $PATH
pkg_version() {
    set -eE
    trap 'trace_line "$FUNCNAME" "$LINENO"' ERR
    local scope="$1"
    debug "$FUNCNAME" '$scope' "$scope"
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    shift 1
    local pkg_name="$1"
    debug "$FUNCNAME" '$pkg_name' "$pkg_name"
    local list="$2"
    local shell_flag="$3"
    local search_path="$4"
    ok "$search_path" || search_path="$KISS_PATH"

    local ver_pre=$repo_ver
    local rel_pre=$repo_rel

    local repo_dir="$(delegate -- "pkg_find" "$@")"
    if [ -d "$repo_dir" ]; then
        debug "$FUNCNAME" '$repo_dir' "$repo_dir"
    else
        die "$FUNCNAME" '$repo_dir' "No such package ($pkg_name)"
    fi

    IFS=$' ' read -r repo_ver repo_rel 2>/dev/null < "$repo_dir/version" ||
        die "$FUNCNAME" "$pkg_name" "Failed to read version file ($repo_dir/version)"

    ok "$repo_rel" ||
        die "$FUNCNAME" "$pkg_name" "Release field not found in version file"

    # This belongs somewhere else, for now it can live here.
    [ -x "$repo_dir/build" ] ||
        die "$FUNCNAME" "$pkg_name" "Build file not found or not executable"

    debug "$FUNCNAME" '$ver_pre'  "$ver_pre"
    debug "$FUNCNAME" '$rel_pre'  "$rel_pre"
    debug "$FUNCNAME" '$repo_ver' "$repo_ver"
    debug "$FUNCNAME" '$repo_rel' "$repo_rel"

    printf '%s\3%s\3%s\3%s\3%s\n' \
        "$repo_dir" "$ver_pre" "$rel_pre" "$repo_ver" "$repo_rel"

}

# Package version of $sys_db
version_installed() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name
    if ok "$1"; then pkg_name="$1"; else pkg_name="kiss"; fi
    IFS=$'\3' read -r _ _ _ repo_ver repo_rel \
        < <(pkg_version "$FUNCNAME" "$pkg_name" "" "" "$sys_db") > /dev/null ||
        die "$FUNCNAME" 'pkg_version' "failed on $LINENO"
    log "$FUNCNAME" '$repo_ver-$repo_rel' "$repo_ver-$repo_rel"
}

# Package version details of selected $KISS_PATH
# $1 pkg_name
# $2
# $3 -d / -x
# $4 $KISS_PATH / $sys_db / $PATH
pkg_version_split() {
    local pkg_name="$1"
    debug "$FUNCNAME" '$pkg_name' "$pkg_name"
    local list="$2"
    local shell_flag="$3"
    local search_path="$4"
    ok "$search_path" || search_path="$KISS_PATH"
    set -eE
    trap 'trace_line "$FUNCNAME" "$LINENO"' ERR
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # https://stackoverflow.com/questions/2488715/idioms-for-returning-multiple-values-in-shell-scripting
    IFS=$'\3' read -r repo_dir _ _ repo_ver repo_rel \
        < <(pkg_version "$FUNCNAME" "$pkg_name" "$list" "$shell_flag" "$search_path") > /dev/null ||
        die "$FUNCNAME" 'pkg_version' "failed on $LINENO"
    null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
    null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"
    null "$repo_rel" && die "$FUNCNAME" '$repo_rel' "$repo_rel"
    debug "$FUNCNAME" '$repo_ver' "$repo_ver"

    # Split the version on '.+-_' to obtain individual components.
    IFS=.+-_ read -r repo_major repo_minor repo_patch repo_ident \
        < <(printf "$repo_ver\n") > /dev/null ||
        die "$FUNCNAME" 'printf' "failed on $LINENO"

    [ $? -eq 0 ] && {
        debug "$FUNCNAME" '$repo_dir' "$repo_dir"
        debug "$FUNCNAME" '$repo_major' "$repo_major"
        debug "$FUNCNAME" '$repo_minor' "$repo_minor"
        debug "$FUNCNAME" '$repo_patch' "$repo_patch"
        # [ -z ${repo_ident} ] && repo_ident="0"
        debug "$FUNCNAME" '$repo_ident' "$repo_ident"
    }
    printf '%s\3%s\3%s\3%s\3%s\3%s\3%s\n' \
        "$repo_dir" "$repo_ver" "$repo_rel" "$repo_major" "$repo_minor" "$repo_patch" "$repo_ident"

}

# Query package from $REPO_ROOT without being limited by $KISS_PATH
# and install it from the query index (optional)
# $1 pkg_name
# $2 index: selected one
pkg_pick_up() {
    set -eE
    trap 'trace_line "$FUNCNAME" "$LINENO"' ERR
    action_of_session="pick"
    local index=0

    local pkg_name
    local repo_list
    local index_pick_up=

    if ok "$1"; then
        pkg_name="${1}"
        repo_list="$(find "$REPO_ROOT" \( -type d -o -type l \) -name "${pkg_name}")"
        null "$2" || index_pick_up="${2}"
    else
        pkg_name="${PWD##*/}"
        repo_list="${PWD}"
        index_pick_up="$index"
    fi

    local repo_selected=
    local ver_selected=
    local rel_selected=

    [ ! -s "$sys_db/$pkg_name/keys" ] || {
        local tail_deep=1
        while [ -z "$(tail -n $tail_deep $sys_db/$pkg_name/keys)" ]; do : $((tail_deep += 1)); done
        IFS=$' ' read -r _ _ repo_source < <(tail -n $tail_deep $sys_db/$pkg_name/keys) \
            > /dev/null || die "$FUNCNAME" "tail -n $tail_deep $sys_db/$pkg_name/keys" "failed on $LINENO"
        repo_source=$(delegate -- decode "$repo_source" "$REPO_MAIN" "REPO_MAIN")
        log "$FUNCNAME" '$repo_source' "$repo_source"
    }

    local route
    local c2_origin="$c2"
    local length_index=$((WIDTH_SCOPE - TABSTOP - 2))
    debug "$FUNCNAME" '$length_index' "$length_index"
    local length_route=$((WIDTH_KEY - 2 * TABSTOP - 1))
    debug "$FUNCNAME" '$length_route' "$length_route"

    [ -n "${repo_list:+x}" ] || {
        c2="$c1"
        log "$FUNCNAME" "$pkg_name" "NONE"
        c2="$c2_origin"
        return
    }
    for repo in $repo_list
    do
        [ -d "$repo" ] && [ -f "$repo/version" ] || continue
        read -r repo_ver repo_rel 2>/dev/null < "$repo/version" || {
            printf "%s\n" "Failed to read version file ($repo/version)"
            exit 1
        }
        c2="$c1"
        [ -n "${repo##*$sys_db*}" ] || { route="->"; c2="$c1"; }
        [ "$repo_source" != "$repo" ] || { route="<-"; c2="$c1"; }
        log "$(printf "%-${TABSTOP}d %-${length_index}s" $((index)) "$repo_ver")" \
            "$(printf "%-${TABSTOP}d %-${length_route}s %-2s" "$repo_rel" "" "$route")" \
            "$repo"
        unset route
        c2="$c2_origin"
        null "$index_pick_up" || [ "$index" != "$index_pick_up" ] || {
            repo_selected="$repo"
            ver_selected="$repo_ver"
            rel_selected="$repo_rel"
        }
        : $((index += 1))
    done

    ok "$repo_selected" || return

    [ -n "${kiss_root_user:+x}" ] ||
    IFS=$'\3' read -r  kiss_root_user _ \
        < <(am_owner "$KISS_ROOT/") > /dev/null ||
        die "$FUNCNAME" 'am_owner' "failed on $LINENO"
    log "$FUNCNAME" "Perfroming selection"

    local c2_origin="$c2"
    route="<-"; c2="$c1";
    log "$(printf "%-${TABSTOP}d %-${length_index}s" "$index_pick_up" "$ver_selected")" \
        "$(printf "%-${TABSTOP}d %-${length_route}s %-2s" "$rel_selected" "" "$route")" \
        "$repo_selected"
    unset route
    c2="$c2_origin"

    local dir="$(dirname "$repo_selected")"
    local pkg_selected="$(basename "$repo_selected")"

    pkg_dirs "$action_of_session" "$pkg_selected"

    export KISS_PATH=$dir

    { hint "$FUNCNAME" 'pkg_checksum' "$pkg_selected"; action="c"; ! pkg_checksum  "$pkg_selected" 2>&1 > /dev/stderr; } ||
    { hint "$FUNCNAME" 'pkg_build_all' "$pkg_selected"; action="b"; ! pkg_build_all "$pkg_selected" 2>&1 > /dev/stderr; } || {
        hint "$FUNCNAME" 'pkg_install' "$pkg_selected"
        if ok "$action" && ! equ "$LOGNAME" "$kiss_root_user"; then
            subshell_action_all "i" "$pkg_selected"
        else
            action=i; pkg_install "$pkg_selected" 2>&1 > /dev/stderr
        fi
        # { action=i; pkg_install   "$pkg_selected" 2>&1 > /dev/stderr; }
        # /usr/bin/kiss c "$pkg_selected" 2>&1 > /dev/stderr &&
        # /usr/bin/kiss b "$pkg_selected" 2>&1 > /dev/stderr &&
        # /usr/bin/kiss i "$pkg_selected"
    }
}

# Figure out which repository a package belongs to (repo_dir)
# or print applications in $PATH (app_path)
# $1 pkg_url
# $2 list option: "all" for repositories and "" for the 1st repository
# $3 shell flag: -d / -x
# $4 $KISS_PATH / $sys_db / $PATH. Don't have pkg_name
# $5 result(s)
pkg_find() {
    set -eE
    trap 'trace_line "$FUNCNAME" "$LINENO"' ERR
    debug "$FUNCNAME" 'enter'
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    debug "$FUNCNAME" '$pkg_url' "$pkg_url [global]"

    # Figure out which repository a package belongs to by searching for
    # directories matching the package name in $KISS_PATH/*.
    set -- "$1" "$2" "$3" "${4:-"$KISS_PATH"}"
    local pkg_url="$1"
    local list="$2"
    ok "$list" || pkg_url="$(standardize "$pkg_url")" # pkg_url=${pkg_url%%\*}
    debug "$FUNCNAME " '$pkg_url' "$pkg_url [local]"
    local pkg_name="${pkg_url##*/}"
    debug "$FUNCNAME " '$pkg_name' "$pkg_name [local]"
    local test_key="$3"
    local search_paths="$4"
    debug "$FUNCNAME" '$#' "$#"
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"

    debug "$FUNCNAME" '$sys_db' "$sys_db"

    IFS_ORIGIN=$LFS
    IFS=$':'
    # Iterate over KISS_PATH, grabbing all directories which match the query.
    # Intentional.
    # shellcheck disable=2086
    for _found_path in $search_paths $sys_db; do
        debug "$FUNCNAME" '$pkg_url' "$pkg_url"
        debug "$FUNCNAME" '$pkg_name' "$pkg_name"
        null "$_found_path" || {
            _found_path="$(standardize "$_found_path")"
            debug "$FUNCNAME" '$_found_path' "$_found_path"
        }
        set +f
        if null "$list"; then
            debug "$FUNCNAME" '$list' "$list"
            local _found_pkg="$_found_path/$pkg_name"
            debug "$FUNCNAME" '$_found_pkg' "$_found_pkg"
            debug "$FUNCNAME" '$#' "$#"
            debug "$FUNCNAME" '${test_key:--d}' "${test_key:--d}"
            test "${test_key:--d}" "$_found_pkg" && {
                set -f -- "$@" "$_found_pkg"
                break
            }
            debug "$FUNCNAME" '$#' "$#"
        else    # ok "$list"
            debug "$FUNCNAME" '$list' "$list"
            local _pkgs="$(\ls -1 "$_found_path" 2>/dev/null | grep "$(standardize "$pkg_name")")"
            IFS=$newline
            for _found_pkg in $_pkgs; do
                debug "$FUNCNAME" '$_found_pkg' "$_found_pkg"
                _found_pkg="$_found_path/$_found_pkg"
                _found_pkg="$(standardize "$_found_pkg")"
                test "${test_key:--x}" "$_found_pkg" && {
                    set -f -- "$@" "$_found_pkg"
                }
            done
            IFS=$':'
        fi
    done
    IFS=$IFS_ORIGIN

    debug "$FUNCNAME" 'serach done'
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    debug "$FUNCNAME" '$list-$#' "$list-$#"

    null "$repo_dir" || debug "$FUNCNAME" '$repo_dir' "$repo_dir [global]"

    # Figure out which repository a package belongs to by searching for
    # Show all search results if called from 'kiss search', else store the
    # values in variables. If there are 4 arguments, no package has been found.
    local result=
    case $list-$# in
        *-4) ;;
        -*) # null "$list"
            repo_dir="$(standardize "$5")"
            result="$repo_dir"
            pkg_name="${5##*/}"
            debug "$FUNCNAME" '$repo_dir' "$repo_dir"
            ;;
        *)  # ok "$list"
            shift 4;
            for item in $@; do
                result="${result:+"${result} "}$item"
            done
            debug "$FUNCNAME" '$applications' "$result"
    esac
    printf '\n%s' "$result"
}

pkg_list_version() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local scope="$1"
    log "$FUNCNAME" '$scope' "$scope"
    shift 1
    debug "$FUNCNAME" '$#' "$#"

    # List installed packages. As the format is files and directories, this
    # just involves a simple for loop and file read.

    log "$FUNCNAME" '$sys_db' "$sys_db"

    # Optional arguments can be passed to check for specific packages. If no
    # arguments are passed, list all.
    ok "$1" || { set +f; set -f -- "$sys_db"/*; }

    # Loop over each package and print its name and version.
    for pkg_name do
        debug "$FUNCNAME" '$pkg_name'       "$pkg_name"
        debug "$FUNCNAME" '${pkg_name##*/}' "${pkg_name##*/}"
        IFS=$'\3' read -r repo_dir ver_pre rel_pre repo_ver repo_rel \
            < <(pkg_version "$FUNCNAME" "${pkg_name##*/}" "" "" "$sys_db") \
            > /dev/null || die "$FUNCNAME" '$pkg_version' "failed on $LINENO"
        null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
        null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"
        log "$FUNCNAME" "${pkg_name##*/}" "$repo_ver-$repo_rel"
    done
}

# Should be subshell function
# How to use:
# local tar_file="$(delegate -- pkg_cache "$pkg_name")"
# $1 pkg_name : package name
pkg_cache() {
    set -eE
    trap 'trace_line "$FUNCNAME" "$LINENO"' ERR
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local arguents="$@"
    local pkg_name="$1"
    null "$2" || debug "$FUNCNAME" '$2' "$2"
    log "$FUNCNAME" '$bin_dir' "$bin_dir"

    # Find the tarball of a package using a glob. Use the user's set compression
    # method if found or first match of the below glob.

    IFS=$'\3' read -r repo_dir ver_pre rel_pre repo_ver repo_rel \
        < <(pkg_version "$FUNCNAME" "$pkg_name") > /dev/null ||
        die "$FUNCNAME" 'pkg_version' "failed on $LINENO"
    null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
    null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"

    log "$FUNCNAME" '$repo_ver' "$repo_ver"
    log "$FUNCNAME" '$repo_rel' "$repo_rel"
    set -- $arguents
    set +f -- "${bin_dir}/${pkg_name}/${1}@${repo_ver}-${repo_rel}.tar."
    set -f -- "${1}$KISS_COMPRESS" "${1}"*

    local tar_file=""

    log "$FUNCNAME" '$1' "$1"
    log "$FUNCNAME" '$2' "$2"

    # If the first match does not exist, use the second. If neither exist,
    # this function returns 1 and the caller handles the error.
    if [ -f "$1" ]; then
        tar_file="$1"
    elif [ -f "$2" ]; then
        tar_file="$2"
    else
        war "$FUNCNAME" '$tar_file' "not found (maybe later)"
    fi

    debug "$FUNCNAME" '$1'        "$1"
    debug "$FUNCNAME" '$2'        "$2"
    debug "$FUNCNAME" '$tar_file' "$tar_file"

    printf "\n%s" "$tar_file"
}

# Given a line of input from the sources file with parameters (src_url)
# and designated target folder name (dest), translate parameters and return
# an absolute path to the source (_des_dir) if it already exists, error if not.
# Input
# $1 pkg_name  : package name
# $2 src_url   : source link (in sources file)
# $3 dest      : destination / source folder name (in sources file)
# $4 action
# How to use
# IFS=$'\3' read -r _res _des_dir \
#     < <(source_route "$pkg_name" "$src_url" "$dest" "$action") > /dev/null ||
#         die "$FUNCNAME" 'source_route' "failed on $LINENO"
# Output
# _res      : source url
# _des_dir  : target file location, directory destination
source_route() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    local src_url="$2"
    local dest="$3"
    local action="$4"
    local _res _des_dir _fnr

    ok "${2%%\#*}" || {
        printf "%s\3%s\n" "" ""
        return 0
    }

    IFS=$'\3' read -r repo_dir _ _ repo_ver repo_rel \
        < <(pkg_version "$FUNCNAME" "$pkg_name") > /dev/null ||
        die "$FUNCNAME" 'pkg_version' "failed on $LINENO"
    ok "$repo_dir" || die "$FUNCNAME" '$repo_dir' "$repo_dir"
    ok "$repo_ver" || die "$FUNCNAME" '$repo_ver' "$repo_ver"
    IFS=$'\3' read -r repo_dir repo_ver repo_rel \
        repo_major repo_minor repo_patch repo_ident \
        < <(pkg_version_split "$pkg_name") > /dev/null ||
        die "$FUNCNAME" 'pkg_version' "failed on $LINENO"
    ok "$repo_dir" || die "$FUNCNAME" '$repo_dir' "$repo_dir"
    log "$FUNCNAME" '$repo_major' "$repo_major"
    log "$FUNCNAME" '$repo_minor' "$repo_minor"
    log "$FUNCNAME" '$repo_patch' "$repo_patch"
    log "$FUNCNAME" '$repo_ident' "$repo_ident"
    log "$FUNCNAME" '$pkg_name' "$pkg_name"

    [ -n "${ARCH:+x}" ] || die "$FUNCNAME" "\$ARCH must be defined" ||
    log "$FUNCNAME" '$ARCH' "$ARCH"

    local _fnr=$(delegate -- \
            decode "${src_url%"${src_url##*[!/]}"}" \
            "$REPO_MAIN"  "REPO_MAIN" \
            "$ARCH"       "ARCH"      \
            "$repo_ver"   "VERSION"   \
            "$repo_rel"   "RELEASE"   \
            "$repo_major" "MAJOR"     \
            "$repo_minor" "MINOR"     \
            "$repo_patch" "PATCH"     \
            "$repo_ident" "IDENT"     \
            "$pkg_name"  "PACKAGE"   )

    log "$FUNCNAME" '$_fnr(uri)' "$_fnr"

    set -- "$1" "$_fnr" "${3%"${3##*[!/]}"}" "$4"

    pkg_name="$1"
    src_url="$2"
    dest="$3"
    action="$4"

    local src_name="${src_url##*/}"
    src_name="${src_name%\?*}"

    # local src_current="${src_name%%-"$repo_ver"*}"
    # src_current="${src_current%%"$repo_ver"*}"
    # src_current="${src_current%%[@\#]*}"
    # [ -n "$src_current" ] || {
    #     src_current="$pkg_name"
    # }
    # local _des_name=$src_current
    # case $src_url in
    #     git+*)
    #         ;;

    #     *.tar|*.tar.??|*.tar.???|*.tar.????|*.t?z)
    #         log "$FUNCNAME" '$dest' "$dest"
    #         # mkcd "$FUNCNAME" "$make_dir/$pkg_name/${_des_dir##*/}"
    #         local head=${src_name%.t??*}
    #         local tail=${src_name##$head}
    #         src_current=$src_current-$repo_ver$tail
    #         ;;

    #     *?*)
    #         ;;
    # esac
    # log "$FUNCNAME" '$src_current' "$src_current"

    # Git repository.
    if null "${src_url##git+*}"; then
        _res=$src_url
        # _des_dir=$src_root/$pkg_name/${dest:-"$src_name"}
        # _des_dir=${_des_dir%[@#]*}/.
        _des_dir=$src_root/$pkg_name/${dest:+"$dest/"}.

    # How to judge the content under src's subfolder is valid?
    # # Remote source dir (cached).
    # elif [ -d "$src_root/$pkg_name/${dest:+"$dest/"}$src_current" ]; then
    #     _res=$src_root/$pkg_name/${dest:+"$dest/"}$src_current
    #     _des_dir=$src_root/$pkg_name/${dest:+"$dest/"}$src_current

    # Remote source files (cached).
    elif [ -f "$archive_root/$pkg_name/${dest:+"$dest/"}$src_name" ]; then
        _res=$archive_root/$pkg_name/${dest:+"$dest/"}$src_name
        _des_dir=$src_root/$pkg_name/${dest:+"$dest/"}.

    # Remote source archive/files.
    elif null "${src_url##*://*}"; then
        _res=url+$src_url
        _des_dir=$archive_root/$pkg_name/${dest:+"$dest/"}.

    # Local relative dir.
    elif [ -d "$repo_dir/$src_url" ]; then
        _res=$repo_dir/$src_url/.
        _des_dir=$_res

    # Local absolute dir.
    elif [ -d "/${src_url##/}" ]; then
        _res=/${src_url##/}/.
        _des_dir=$_res

    # Local relative file (/repo_dir/files/filename).
    elif [ -f "$repo_dir/$src_url" ]; then
        _res=$repo_dir/$src_url
        _des_dir="${_res%/*}/."

    # Local absolute file (/files/filename).
    elif [ -f "/${src_url##/}" ]; then
        _res=/${src_url##/}
        _des_dir="${_res%/*}/."

    else
        die "$FUNCNAME" "$pkg_name" "No local file '$src_url'"
    fi

    ok "$action" || log "$FUNCNAME" '$_res' "$_res"

    log "$FUNCNAME" '$_des_dir'   "$_des_dir"
    log "$FUNCNAME" '$action' "$action"

    printf "%s\3%s\n" "$_res" "$_des_dir"
}

# Download any remote package sources. The existence of local files is
# also checked.
# $1 pkg_name  : package name
# $2 action    : action name
pkg_download() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    local action="$2"
    log "$FUNCNAME" '$pkg_name' "$pkg_name"
    log "$FUNCNAME" '$action'   "$action"
    IFS=$'\3' read -r repo_dir repo_ver repo_rel repo_major repo_minor repo_patch repo_ident \
        < <(pkg_version_split "$pkg_name") > /dev/null ||
        die "$FUNCNAME" 'pkg_version_split' "failed on $LINENO"
    [ "$?" -ne 0 ] || {
        log "$FUNCNAME" '$repo_dir'   "$repo_dir"
        log "$FUNCNAME" '$repo_major' "$repo_major"
        log "$FUNCNAME" '$repo_minor' "$repo_minor"
        log "$FUNCNAME" '$repo_patch' "$repo_patch"
        log "$FUNCNAME" '$repo_ident' "$repo_ident"
    }

    # Support packages without sources. Simply do nothing.
    [ -f "$repo_dir/sources" ] || return 0

    log "$FUNCNAME" "$pkg_name" "Reading sources"

    while read -r src_url dest || ok "${src_url%%\#*}"; do
        ok "${src_url%%\#*}" || continue
        log "$FUNCNAME" '$src_url'  "$src_url"
        log "$FUNCNAME" '$dest' "$dest"
        IFS=$'\3' read -r _res _des_dir \
            < <(source_route "$pkg_name" "$src_url" "$dest" "$action") > /dev/null ||
            die "$FUNCNAME" "source_route" "failed on $LINENO"
        log "$FUNCNAME" '$_res' "$_res"
        log "$FUNCNAME" '$_des_dir' "$_des_dir"

        # arg1: pre-source
        # arg2: package name
        # arg3: verbatim source
        # arg4: resolved source
        run_hook pre-source "$pkg_name" "$src_url" "$_fnr"

        # '$2' is set when this function is called from 'kiss c' and it is used
        # here to skip calling the Git code.
        local _res_purified="${_res##"${_res%%+*}+"}"
        log "$FUNCNAME" '$_res_purified' "$_res_purified"
        case ${action}$_res in "${action}url+"*|git+*)
            # For download_url and download_git
            "download_${_res%%+*}" "$pkg_name" "$_des_dir" "$_res_purified"
        esac

        # arg1: post-source
        # arg2: package name
        # arg3: verbatim source
        # arg4: resolved source
        run_hook post-source "$pkg_name" "$src_url" "${_des_dir:-"$_res"}"
    done < "$repo_dir/sources"
}

download_url() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    shift 1
    local _des_dir="$1"
    local _res_purified="$2"
    local src_name="${_res_purified##*/}"
    src_name="${src_name%\?*}"

    [ "${_des_dir##*/}" != "." ] || _des_dir="${_des_dir%/*}"
    log "$FUNCNAME" '$_des_dir' "$_des_dir"
    mkcd "$FUNCNAME" "${_des_dir}"

    log "$FUNCNAME" "$pkg_name" "$_res_purified"
    log "$FUNCNAME" '${cmd_get##*/}' "${cmd_get##*/}"
    # Set the arguments based on found download utility.
    case ${cmd_get##*/} in
        aria2c|axel) set -- -o   "$_des_dir/$src_name" "$_res_purified" ;;
               curl) set -- -fLo "$_des_dir/$src_name" "$_res_purified" ;;
         wget|wget2) set -- -O   "$_des_dir/$src_name" "$_res_purified" ;;
    esac

    # Opening output file $_des_dir/$src_name
    # Error opening local file
    # /usr/bin/kiss: line 1198: -o: not found
    local as_archive_user=
    IFS=$'\3' read -r archive_dir_user _  \
        < <(am_owner "$archive_root/$pkg_name") > /dev/null ||
        die "$FUNCNAME" 'am_owner' "failed on $LINENO"
    equ "$LOGNAME" "$archive_dir_user" || as_archive_user=$(delegate -- as_user "$archive_dir_user")

    log "$FUNCNAME" '$LOGNAME' "$LOGNAME"
    log "$FUNCNAME" '$as_archive_user' "$as_archive_user"

    $as_archive_user "$cmd_get" "$@" || {
        $as_archive_user rm -f "$_des_dir/$src_name"
        die "$FUNCNAME" "$pkg_name" "Failed to download $_res_purified"
    }
}

download_git() {
    set -eE
    trap 'trace_line "$FUNCNAME" "$LINENO"' ERR
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    shift 1
    local _des_dir="$1"
    local _res_purified="$2"

    log "$FUNCNAME" '$src_root' "$src_root"
    log "$FUNCNAME" '$src_user' "$src_user"

    set --
    equ "$LOGNAME" "$src_user" || set -- $(delegate -- as_user "$src_user")

    log "$FUNCNAME" '$_des_dir' "$_des_dir" # "$src_root/$pkg_name/${dest:+"$dest/"}."
    # Remove "/."
    [ "${_des_dir##*/}" != "." ] || _des_dir="${_des_dir%/*}"
    log "$FUNCNAME" '$_des_dir' "$_des_dir"
    mkcd "$FUNCNAME" "$_des_dir"

    # Might be empty
    local upstream_name=
    [ -n "${_res_purified##*[@\#]*}" ] || upstream_name="${_res_purified##*[@\#]}"

    url="${_res_purified%[\#@]*}"

    log "$FUNCNAME" '$upstream_name' "$upstream_name"
    log "$FUNCNAME" '$url' "${url}"
    log "$FUNCNAME" '$PWD' "$PWD"

    local target=

    for item in $($@ git ls-remote $url --heads origin "refs/heads/*" | awk '{print $2}'); do
        { [ -n "${upstream_name:+x}" ] && [ -z "${item##*"${upstream_name}"*}" ]; } ||
        [ -z "${item##*"master"*}" ] ||
        [ -z "${item##*"main"*}" ] || continue
        target="${item##"refs/heads/"}"
        break
    done

    local upstream_type

    if [ -n "$target" ]; then
        upstream_type="branch"
    else
        upstream_type="tag"
        for item in $($@ git ls-remote $url --tags origin "refs/tags/*${upstream_name}*" | awk '{print $2}'); do
            { [ -n "${upstream_name:+x}" ] && [ -z "${item##*"${upstream_name}"*}" ]; } || continue
            target="${item##"refs/tags/"}"
            break
        done
        [ -n "$target" ] || {

            [ "$($@ git -C "$_des_dir" rev-parse --is-inside-work-tree 2>/dev/null)" = "true" ] || {
                $@ find "$_des_dir" -mindepth 1 -delete
                $@ git clone --recursive --depth 1 "${url}" "$_des_dir" ||
                    die "$FUNCNAME" "git clone --recursive --depth 1 \"${url}\" \"$_des_dir\"" "failed at $LINENO"
            }
            # Time consuming operation
            # $@ git fetch --all --tags --prune
            $@ git fetch --tags --prune
            # https://stackoverflow.com/questions/21439488/find-latest-git-tag-from-the-remote-git-repository
            # Leaving ^0 at the end of tags
            # target="$($@ git rev-list --tags --timestamp --no-walk | sort -nr | head -n1 | cut -f 2 -d ' ' | xargs $@ git describe --contains)"
            # https://stackoverflow.com/questions/1404796/how-can-i-get-the-latest-tag-name-in-current-branch-in-git
            target="$($@ git describe --tags $($@ git rev-list --tags --max-count=1))"
        }
        [ -n "$target" ] ||
        die "$FUNCNAME" "branch/tag '$upstream_name', 'main', and 'master' doesn't exist." \
        "Specify a valid branch/tag name, please"
    fi

    log "$FUNCNAME" '$target' "$target"
    log "$FUNCNAME" '$upstream_type' "$upstream_type"

    if [ "$($@ git -C "$_des_dir" rev-parse --is-inside-work-tree 2>/dev/null)" = "true" ]; then

        local remote_url=$($@ git -C "$_des_dir" remote -v | grep fetch | grep origin | awk '{print $2}')
        # [ "$remote_url" = "$url" ] || {
        #     $@ git remote remove origin
        #     $@ git remote add origin "${url}"
        # }

        [ "$remote_url" = "$url" ] ||
        $@ git remote set-url origin "${url}" 2>/dev/null ||
        $@ git remote add origin "${url}" ||
        die "$FUNCNAME" "git remote set-url origin \"${url}\"" "failed at $LINENO"


        if [ "$upstream_type" == "branch" ]; then

            [ -z "$target" ] ||
            $@ git remote set-branches origin $target ||
            die "$FUNCNAME" "git remote set-branches origin $target" "failed at $LINENO"

            log "$FUNCNAME" 'fetch' "${url}"
            $@ git fetch --depth 1 "${url}" $target 2>/dev/null ||
            $@ git fetch "${url}" $target ||
            die "$FUNCNAME" "git fetch --depth 1 \"${url}\" $target" "failed at $LINENO"
            # generate branch "$terget" in .git/config
            $@ git fetch --depth 1 origin $target

            local target_ref=$($@ git branch | grep -v remotes | grep \* | awk '{print $2}')
            # fatal: a branch named 'master' already exists when "$target" = "$target_ref"
            [ "$target" == "$target_ref" ] || {
                [ "$($@ git branch | grep -v remotes | grep "$target" | awk '{print $1}')" == "$target" ] ||
                # fatal: a branch named 'master' already exists
                $@ git branch $target FETCH_HEAD 2>/dev/null ||
                # fatal: 'origin/aster' is not a commit and a branch 'master' cannot be created from it
                $@ git checkout -b $target --track origin/$target 2>/dev/null ||
                die "$FUNCNAME" "git checkout -b $target --track origin/$target" "failed at $LINENO"

                $@ git switch $target 2>/dev/null || $@ git switch -c $target ||    # Already on 'master'
                die "$FUNCNAME" "git switch $target" "failed at $LINENO"

                target_ref=$($@ git branch | grep -v remotes | grep \* | awk '{print $2}')
                [ "$target_ref" = "$target" ] || die "$FUNCNAME" " \"$target_ref\" = \"$target\" " "failed at $LINENO"
            }

            log "$FUNCNAME" '$target_ref' "$target_ref"

            $@ git branch --set-upstream-to=origin/$target $target
            # fatal: the requested upstream branch 'origin/master' does not exist
            $@ git reset --hard origin/$target ||
                die "$FUNCNAME" "git reset --hard origin/$target" "failed at $LINENO"

        elif [ "$upstream_type" == "tag" ]; then

            local targets=$($@ git tag)
            contains "$targets" "$target" ||
            # $@ git fetch --all --tags
            $@ git fetch --depth 1 "${url}" tag $target --no-tags 2>/dev/null ||
            $@ git fetch --depth 1 "${url}" refs/tags/$target:refs/tags/$target 2>/dev/null ||
            $@ git fetch "${url}" tag $target --no-tags ||
                die "$FUNCNAME" "git fetch \"${url}\" tag $target --no-tags" "failed at $LINENO"

            local target_ref=$($@ git branch | grep -v remotes | grep \* | awk '{print $2}')
            [ -z "${target_ref##*${target}*}" ] || {
                [ "$($@ git branch | grep -v remotes | grep "$target" | awk '{print $1}')" == "$target" ] ||
                $@ git checkout tags/$target -b $target ||
                die "$FUNCNAME" "git checkout tags/$target -b $target" "failed at $LINENO"

                $@ git switch $target 2>/dev/null || $@ git switch -c $target ||    # Already on 'master'
                die "$FUNCNAME" "git switch $target" "failed at $LINENO"

                target_ref=$($@ git branch | grep -v remotes | grep \* | awk '{print $2}')
                [ "$target_ref" == "$target" ] || die "$FUNCNAME" " \"$target_ref\" = \"$target\" " "failed at $LINENO"
            }

            log "$FUNCNAME" '$target_ref' "$target_ref"

            $@ git reset --hard tags/$target ||
            die "$FUNCNAME" "git reset --hard tags/$target" "failed at $LINENO"
        fi

        $@ git rev-parse --short HEAD
        $@ git describe --always

        $@ git submodule deinit --all -f
        $@ git submodule init
        $@ git submodule sync
        $@ git submodule update --init --remote --recursive --force
    else
        $@ find "$_des_dir" -mindepth 1 -delete
        # https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/
        $@ git clone --recursive --depth 1 --single-branch --branch $target "${url}" "$_des_dir" 2>/dev/null ||
        # $@ git clone --recursive --depth 1 --single-branch --branch $target "${url}" "$_des_dir" 2>/dev/null ||
        # $@ git clone --recursive --filter=tree:0 --branch $target "${url}" "$_des_dir" 2>/dev/null ||
        # $@ git clone --recursive --filter=blob:none --branch $target "${url}" "$_des_dir" 2>/dev/null ||
        $@ git clone --depth 1 "${url}" "$_des_dir" 2>/dev/null ||
            die "$FUNCNAME" "git clone --recursive --depth 1 --branch $target \"${url}\" \"$_des_dir\"" "failed at $LINENO"
    fi
}

# $1 pkg_name
# $2 $_des_dir
# $3 $_res
# working under "${_des_dir%/*}"
extract_tar() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    shift 1
    local _des_dir="$1"
    local _res="$2"

    [ -n "${_des_dir:+x}" ] || die "$FUNCNAME" '$_des_dir' "$_des_dir"

    [ "${_des_dir##*/}" != "." ] || _des_dir="${_des_dir%/*}"
    mkcd "$FUNCNAME" "${_des_dir}"

    log "$FUNCNAME" '$0' "$0"
    log "$FUNCNAME" '$_res' "$_res"
    log "$FUNCNAME" '$pkg_name' "$pkg_name"

    # This is a portable shell implementation of GNU tar's
    # '--strip-components 1'. Use of this function denotes a
    # performance penalty.
    local tarball="$(delegate -- "slot_aquire" "$FUNCNAME" "$pkg_name" "$_des_dir/tarball")"
    log "$FUNCNAME" '$tarball' "$tarball"
    local tarball_manifest="$(delegate -- "slot_aquire" "$FUNCNAME" "$pkg_name" "$_des_dir/tarball-manifest")"
    log "$FUNCNAME" '$tarball_manifest' "$tarball_manifest"

    decompress "$_res" > "$tarball" || {
        \rm -f "$_res"
        die "$FUNCNAME" "$pkg_name" "Failed to decompress $_res and deleted."
    }

    tar xf "$tarball" ||
        die "$FUNCNAME" "$pkg_name" "Failed to extract $_res"

    # The sort command filters out all duplicate top-level
    # directories from the tarball's manifest. This is an optimization
    # as we avoid looping (4000 times for Python(!)).
    tar tf "$tarball" | sort -ut / -k1,1 > "$tarball_manifest" ||
        die "$FUNCNAME" "$pkg_name" "Failed to extract manifest"

    # Iterate over all directories in the first level of the
    # tarball's manifest. Each directory is moved up a level.
    while IFS=/ read -r dir _; do case ${dir#.} in *?*)
        # Skip entries which aren't directories.
        [ -d "$dir" ] || continue

        # Move the parent directory to prevent naming conflicts
        # with the to-be-moved children.
        mv -f "$dir" "$KISS_PID-$dir"

        # Move all children up a directory level. If the mv command
        # fails, fallback to copying the remainder of the files.
        #
        # We can't use '-exec {} +' with any arguments between
        # the '{}' and '+' as this is not POSIX. We must also
        # use '$0' and '$@' to reference all arguments.
        find "$KISS_PID-$dir/." ! -name . -prune \
            -exec sh -c 'mv -f "$0" "$@" .' {} + 2>/dev/null ||

        find "$KISS_PID-$dir/." ! -name . -prune \
            -exec sh -c 'cp -fRp "$0" "$@" .' {} +

        # Remove the directory now that all files have been
        # transferred out of it. This can't be a simple 'rmdir'
        # as we may leave files in here if any were copied.
        rm -rf "$KISS_PID-$dir"
    esac done < "$tarball_manifest"

    # Remove the tarball now that we are done with it.
    rm -f "$tarball"
}

# $1 pkg_name
pkg_to_make_dir() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    # Extract all source archives to the build directory and copy over any
    # local repository files.
    #
    # NOTE: repo_dir comes from caller.
    log "$FUNCNAME" "$pkg_name" "Extracting sources"

    # arg1: pre-extract
    # arg2: package name
    # arg3: path to DESTDIR
    run_hook pre-extract "$pkg_name" "$pkg_dir/$pkg_name"

    while read -r src_url dest || ok "${src_url%%\#*}"; do
        IFS=$'\3' read -r _res _des_dir \
            < <(source_route "$pkg_name" "$src_url" "$dest") > /dev/null ||
            die "$FUNCNAME" "source_route" "failed on $LINENO"

        [ "${_des_dir##*/}" != "." ] || _des_dir="${_des_dir%/*}"

        # Create the source's directories if not null.
        null "$_res" ||

        case $_res in
            git+*)
                mkcd "$FUNCNAME" "$make_dir/$pkg_name/$dest"
                rsync -aqz "$_des_dir/." .
            ;;

            *.tar|*.tar.??|*.tar.???|*.tar.????|*.t?z)
                extract_tar "$pkg_name" "$_des_dir" "$_res"
                # mkcd "$FUNCNAME" "$make_dir/$pkg_name/${_des_dir##*/}"
                mkcd "$FUNCNAME" "$make_dir/$pkg_name/$dest"
                rsync -aqz "$_des_dir/." .
            ;;

            *?*)
                mkcd "$FUNCNAME" "$make_dir/$pkg_name/$dest"
                cp -LRf "$_res" .
            ;;
        esac
    done < "$repo_dir/sources" || die "$FUNCNAME" "$pkg_name" "Failed to extract $_res"
}

# $1 pkg_name   : dependence with repo path
# $2 policy     : raw/expl | policies
# $3 filter     : filter switch
# $4 appended   : dependencies appended
# $5 dep_stage  : dependent type/stage [build time / runtime]
pkg_depends() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    local policy="$2"
    local filter="$3"
    local appended="$4"
    local dep_stage="$5"

    log "$FUNCNAME" '$pkg_name' "$pkg_name"
    log "$FUNCNAME" '$policy' "$policy"
    log "$FUNCNAME" '$filter' "$filter"
    log "$FUNCNAME" '$appended' "$appended"
    log "$FUNCNAME" '$dep_stage' "$dep_stage"

    log "$FUNCNAME" '$deps' "$deps"
    log "$FUNCNAME" '$explicit' "$explicit"
    log "$FUNCNAME" '$sys_db/$pkg_name' "$sys_db/$pkg_name"

    # Resolve all dependencies and generate an ordered list. The deepest
    # dependencies are listed first and then the parents in reverse order.
    ! contains "$deps" "$pkg_name" || return 0

    # Filter out non-explicit, already installed packages.
    null "$filter" || ok "$policy" || contains "$explicit" "$pkg_name" ||
        [ ! -d "$sys_db/$pkg_name" ] || return 0

    # Detect circular dependencies and bail out.
    # Looks for multiple repeating patterns of (dep dep_parent) (5 is max).
    case " $appended " in
*" ${appended##* } "*" ${pkg_name} "\
*" ${appended##* } "*" ${pkg_name} "\
*" ${appended##* } "*" ${pkg_name} "\
*" ${appended##* } "*" ${pkg_name} "\
*" ${appended##* } "*" ${pkg_name} "*)
        die "$FUNCNAME" "$pkg_name <> ${4##* }" "circular dependency detected"
    esac

    local repo_dir="$sys_db/$pkg_name"
    [ -d "$sys_db/$pkg_name" ] ||
        repo_dir="$(delegate -- "pkg_find" "$pkg_name")"

    ok "$repo_dir" || die "$FUNCNAME" "$pkg_name" 'is not yet installed'

    log "$FUNCNAME" '$repo_dir' "$repo_dir"
    log "$FUNCNAME" '$KISS_ROOT' "$KISS_ROOT"
    log "$FUNCNAME" '$4' "$4"
    log "$FUNCNAME" '$appended' "$appended"

    # Packages which exist and have depends.
    null "$(delegate -- "pkg_find" "$pkg_name")" ||
    [ ! -e "$repo_dir/depends" ] ||
    # Recurse through the dependencies of the child packages.
    while read -r dep dep_type || ok "$dep"; do
        log "$FUNCNAME" '$dep' "$dep"
        log "$FUNCNAME" '$dep_type' "$dep_type"

        null ${dep##*/*} ||
        contains "$appended" "$pkg_name" || {
            { ok "${dep##\#*}" && [ -n ${KISS_ROOT:+x} ]; } ||
                pkg_depends "$dep" '' "$filter" "$4 $pkg_name" "$dep_type"
            { [ -z ${KISS_ROOT:+x} ] || ok "$dep_type"; } ||
                pkg_depends "$dep" '' "$filter" "$4 $pkg_name" "$dep_type"
            { [ -z ${KISS_ROOT:+x} ] || null "$dep_type"; } ||
                pkg_make_depends "$dep" '' "$filter" "$4 $pkg_name" "$dep_type"
        }
    done < "$repo_dir/depends" || :

    # Add parent to dependencies list.
    equ "$policy" expl && { ! equ "$dep_stage" make || ok "$(delegate -- "pkg_cache" "$pkg_name")"; } ||
        deps="${deps:+"${deps} "}$pkg_name"

    for item in $deps; do
        log "$FUNCNAME" '$deps' "$item"
    done
}

pkg_make_depends() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    # Only add to list once
    ! contains "$makedeps" "$pkg_name" || return 0

    # Filter already installed packages on build machine.
    ! [ -d "$REPO_ROOT/installed/$pkg_name" ] || return 0

    # Add to the list
    makedeps="$makedeps $pkg_name"
}

# "$@" : all packages
pkg_order() {
    # Order a list of packages based on dependence and take into account
    # pre-built tarballs if this is to be called from 'kiss i'.
    local order redro deps

    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"

    for pkg_name do case $pkg_name in
      /*@*.tar.*) deps="$deps $pkg_name" ;;
       *@*.tar.*) deps="$deps $ppwd/$pkg_name" ;;
             */*) die "$FUNCNAME" "Not a package' ($pkg_name)" ;;
               *) pkg_depends "$pkg_name" raw
    esac done

    for item in $deps; do
        debug "$FUNCNAME" '$deps' "$item"
    done

    local order=
    local redro=
    # Filter the list, only keeping explicit packages. The purpose of these
    # two loops is to order the argument list based on dependence.
    for pkg_name in $deps; do case " $* " in *" $pkg_name "*|*" ${pkg_name##"$ppwd/"} "*)
        order="${order:+"${order} "}$pkg_name"
        redro="$pkg_name${redro:+" ${redro}"}"
    esac done

    log "$FUNCNAME" '$order' "'$order'"
    log "$FUNCNAME" '$redro' "'$redro'"

    unset deps

    printf "%s\3%s\n" "$order" "$redro"
}

pkg_strip() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Strip package binaries and libraries. This saves space on the system as
    # well as on the tarballs we ship for installation.
    [ -f "$make_dir/$pkg_name/nostrip" ] || equ "$KISS_STRIP" 0 && return

    log "$FUNCNAME" "$1" "Stripping binaries and libraries"

    # Strip only files matching the below ELF types. This uses 'od' to print
    # the first 18 bytes of the file. This is the location of the ELF header
    # (up to the ELF type) and contains the type information we need.
    #
    # Static libraries (.a) are in reality AR archives which contain ELF
    # objects. We simply read from the same 18 bytes and assume that the AR
    # header equates to an archive containing objects (.o).
    #
    # Example ELF output ('003' is ELF type):
    # 0000000 177   E   L   F 002 001 001  \0  \0  \0  \0  \0  \0  \0  \0  \0
    # 0000020 003  \0
    # 0000022
    #
    # Example AR output (.a):
    # 0000000   !   <   a   r   c   h   >  \n   /
    # 0000020
    # 0000022
    while read -r file; do [ -h "$pkg_dir/$pkg_name$file" ] || case $file in
        # Look only in these locations for files of interest (libraries,
        # programs, etc). This includes all subdirectories. Old behavior
        # would run od on all files (upwards of 4000 for Python).
        */sbin/?*[!/]|*/bin/?*[!/]|*/lib/?*[!/]|\
        */lib??/?*[!/]|*/lib???/?*[!/]|*/lib????/?*[!/])

        case $(od -A o -t c -N 18 "$pkg_dir/$pkg_name$file") in
            # REL (object files (.o), static libraries (.a)).
            *177*E*L*F*0000020\ 001\ *|*\!*\<*a*r*c*h*\>*)
                run strip -g -R .comment -R .note "$pkg_dir/$pkg_name$file"
            ;;

            # EXEC (binaries), DYN (shared libraries).
            # Shared libraries keep global symbols in a separate ELF section
            # called '.dynsym'. '--strip-all/-s' does not touch the dynamic
            # symbol entries which makes this safe to do.
            *177*E*L*F*0000020\ 00[23]\ *)
                run strip -s -R .comment -R .note "$pkg_dir/$pkg_name$file"
            ;;
        esac
    esac done < "$pkg_dir/$pkg_name/$db/$1/manifest" || :
}

# could be subshell function before local version
# $1 pkg_name : repository name / package name
pkg_fix_deps() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    # Dynamically look for missing runtime dependencies by checking each
    # binary and library with 'ldd'. This catches any extra libraries and or
    # dependencies pulled in by the package's build suite.
    log "$FUNCNAME" "$pkg_name" "looking for dependencies (using ${cmd_elf##*/})"

    log "$FUNCNAME" '$PWD' "$PWD"    # "$pkg_dir/$pkg_name/$db/$pkg_name"
    log "$FUNCNAME" '$sys_db' "$sys_db"
    log "$FUNCNAME" '$pkg_name' "$pkg_name"

    set +f
    set -f -- "$sys_db/"*/manifest

    unset _fdep_seen

    # False positive (not a write).
    # shellcheck disable=2094
    while read -r _file; do [ -h "$_file" ] || case $_file in
        # Look only in these locations for files of interest (libraries,
        # programs, etc). This includes all subdirectories. Old behavior
        # would run ldd on all files (upwards of 4000 for Python).
        */sbin/?*[!/]|*/bin/?*[!/]|*/lib/?*[!/]|\
        */lib??/?*[!/]|*/lib???/?*[!/]|*/lib????/?*[!/])

        debug "$FUNCNAME" '$_file' "$_file"
        # [ "${_file:0:1}" == '/' ] || _file="${_file:1}"

        # The readelf mode requires ldd's output to resolve the library
        # path for a given file. If ldd fails, silently skip the file.
        local ldd="$(ldd -- "$pkg_dir/$pkg_name$_file" 2>/dev/null)" || continue

        # Attempt to get information from readelf. If this fails (or we
        # are in ldd mode), do full ldd mode (which has the downside of
        # listing dependencies of dependencies (and so on)).
        local elf="$("$cmd_elf" -d "$pkg_dir/$pkg_name$_file" 2>/dev/null)" || elf=$ldd

        # Iterate over the output of readelf or ldd, extract file names,
        # resolve their paths and finally, figure out their owner.
        while read -r lib; do case $lib in *NEEDED*\[*\]|*'=>'*)
            # readelf: 0x0000 (NEEDED) Shared library: [libjson-c.so.5]
            lib=${lib##*\[}
            lib=${lib%%\]*}

            # Resolve library path.
            # ldd: libjson-c.so.5 => /lib/libjson-c.so.5 ...
            case $cmd_elf in
                *readelf) lib=${ldd#*"	$lib => "} ;;
                *)        lib=${lib##*=> } ;;
            esac
            lib=${lib%% *}

            # Skip files owned by libc, libc++ and POSIX.
            case ${lib##*/} in
                ld-*           |\
                lib[cm].so*    |\
                libc++.so*     |\
                libc++abi.so*  |\
                libcrypt.so*   |\
                libdl.so*      |\
                libgcc_s.so*   |\
                libmvec.so*    |\
                libpthread.so* |\
                libresolv.so*  |\
                librt.so*      |\
                libstdc++.so*  |\
                libtrace.so*   |\
                libunwind.so*  |\
                libutil.so*    |\
                libxnet.so*    |\
                ldd)
                    continue
            esac

            # Skip files we have seen before.
            case " $_fdep_seen " in
                *" $lib "*) continue ;;
                *) _fdep_seen="$_fdep_seen $lib"
            esac

            resolve_path "$lib"

            # Skip file if owned by current package
            ! pkg_owner -e "$_rpath" manifest ||
                continue

            ! pkg_owner -e "$_rpath" "$@" ||
                log "$FUNCNAME" '$_owns' "$_owns"

        esac done < <([ "$?" -eq 0 ] || :; printf "%s\n" "$elf") > /dev/null ||
        die "$FUNCNAME" 'printf "%s\n" "$elf"' "failed on $LINENO"
    esac done < manifest |

    [ ! -s "depends" ] || {
        local depends_list="$(cat depends)"
        for item in $depends_list; do
            log "$FUNCNAME depends" "to fix" "$item"
        done
        local depends_clone="$(delegate -- "slot_push" "$FUNCNAME" "$pkg_name" "depends")"
        log "$FUNCNAME pushed" '$depends' "$depends"

        local depends_fixed="$(delegate -- "slot_aquire" "$FUNCNAME" "$pkg_name" "depends-fixed")"
        log "$FUNCNAME pushed" '$depends_fixed' "$depends_fixed"

        # Sort the depends file (including the existing depends file) and
        # remove any duplicate entries. This can't take into account comments
        # so they remain rather than being replaced.
        sort -u -k 1,1 "$depends_clone" /dev/stdout > "$depends_fixed"

        # If the depends file was modified, show a diff and replace it.
        [ ! -s "$depends_fixed" ] || {
            diff -U 3 "$depends_clone" "$depends_fixed" 2>/dev/null || :

            log "$FUNCNAME to be" '$depends_fixed' "$depends_fixed"
            # Replace the existing depends file if one exists, otherwise this
            # just moves the file to its final resting place.
            \mv -f "$depends_fixed" depends
            local depends_list="$(cat depends)"
            for item in $depends_list; do
                log "$FUNCNAME depends" "fixed" "$item"
            done
            # Generate a new manifest as we may be the creator of the depends
            # file. This could otherwise be implemented by inserting a line
            # at the correct place in the existing manifest.
            pkg_manifest "${PWD##*/}" "$pkg_dir/$pkg_name"
        }
    }
}

# could be subshell function before local version
# $1 pkg_name                               : package name
# $2 pkg_dir/$pkg_name / tar_dir/$pkg_name  : package directory / extracting directory
pkg_manifest() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    local dir_operating="$2"
    # Generate the package's manifest file. This is a list of each file
    # and directory inside the package. The file is used when uninstalling
    # packages, checking for package conflicts and for general debugging.
    log "$FUNCNAME" "$pkg_name" "Generating manifest"
    log "$FUNCNAME" '$dir_operating' "$dir_operating"
    log "$FUNCNAME" '$db' "$db"

    local manifest="$(delegate -- "slot_aquire" "$FUNCNAME" "$pkg_name" "manifest")"

    # Create a list of all files and directories. Append '/' to the end of
    # directories so they can be easily filtered out later. Also filter out
    # all libtool .la files and charset.alias.
    {
        printf '%s\n' "$dir_operating/$db/$pkg_name/manifest"

        ! [ -d "$dir_operating/etc" ] ||
        printf '%s\n' "$dir_operating/$db/$pkg_name/etcsums"

        find "$dir_operating" ! -path "$dir_operating" -type d -exec printf '%s/\n' {} + \
            -o \( ! -type d -a ! -name \*.la -a ! -name charset.alias \) -print

        # Sort the output in reverse. Directories appear after their contents.
    } | sort -ur > "$manifest"

    as "$src_user" /usr/bin/touch "$dir_operating/$db/$pkg_name/manifest"
    # Remove the prefix from each line.
    while read -r file; do
        printf '%s\n' "${file#"$dir_operating"}"
    done < "$manifest" > "$dir_operating/$db/$pkg_name/manifest"
}

# $1 $pkg_name
manifest_validate() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # NOTE: pkg_name comes from caller.
    local pkg_name="$1"
    log "$FUNCNAME" "$pkg_name" "Checking if manifest valid"

    log "$FUNCNAME" '$tar_dir/$pkg_name' "$tar_dir/$pkg_name"
    log "$FUNCNAME" 'manifest file' "$db/$pkg_name/manifest"

    shift 1

    while read -r line; do
        [ -e "$tar_dir/$pkg_name$line" ] || [ -h "$tar_dir/$pkg_name$line" ] || {
            log "$FUNCNAME" '$line' "$line"
            set -- "$@" "$line"
        }
    done < "$tar_dir/$pkg_name/$db/$pkg_name/manifest"

    for f do
        log "$FUNCNAME" '$f' "$f"
        die "$FUNCNAME" "$pkg_name" "manifest contains $# non-existent files"
    done
}

manifest_replace() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Replace the matching line in the manifest with the desired replacement.
    # This used to be a 'sed' call which turned out to be a little
    # error-prone in some cases. This new method is a tad slower but ensures
    # we never wipe the file due to a command error.
    local manifest_replace_buffer="$(delegate -- "slot_aquire" "$FUNCNAME" "$pkg_name" "manifest-replace-${2##*/}")"

    while read -r line; do
        ! equ "$line" "$2" || line=$3

        printf '%s\n' "$line"
    done < "$sys_db/$1/manifest" | sort -r > "$manifest_replace_buffer"

    mv -f "$manifest_replace_buffer" "$sys_db/$1/manifest"
}

# $@ :
pkg_etcsums() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    # Generate checksums for each configuration file in the package's /etc/
    # directory for use in "smart" handling of these files.
    log "$FUNCNAME" "$pkg_name" "Generating etcsums"
    shift 3

    # Minor optimization - skip packages without /etc/.
    [ -d "$pkg_dir/$pkg_name/etc" ] || return 0

    # Create a list of all files in etc but do it in reverse.
    while read -r etc; do case $etc in /etc/*[!/])
        set -- "$pkg_dir/$pkg_name/$etc" "$@"
    esac done < "$pkg_dir/$pkg_name/$db/$pkg_name/manifest"

    as "$src_user" sh -c 'printf "%s\n" "$(delegate -- "sh256" "$@")" > "$pkg_dir/$pkg_name/$db/$pkg_name/etcsums"'
}

# $1 pkg_name : package name
pkg_tar() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    log "$FUNCNAME" '$pkg_name' "$pkg_name [global]"
    local pkg_name="$1"
    log "$FUNCNAME" '$pkg_name' "$pkg_name [local]"

    # Create a tarball from the built package's files. This tarball also
    # contains the package's database entry.
    #
    # NOTE: repo_ comes from caller.
    log "$FUNCNAME" "$pkg_name" "tarball creating"
    # tree "$pkg_dir"

    IFS=$'\3' read -r repo_dir ver_pre rel_pre repo_ver repo_rel \
        < <(pkg_version "$FUNCNAME" "$pkg_name") > /dev/null ||
            die "$FUNCNAME" 'pkg_version' "failed on $LINENO"
    null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
    null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"
    local tar_file=$bin_dir/$pkg_name/$pkg_name@$repo_ver-$repo_rel.tar.$KISS_COMPRESS
    local repofile="repo.index"

    # Use 'cd' to avoid needing tar's '-C' flag which may not be portable
    # across implementations.
    cd "$pkg_dir/$pkg_name"

    # Create a tarball from the contents of the built package.
    as "$src_user" /usr/bin/tar cf - . | case $KISS_COMPRESS in
        bz2)  bzip2 -z ;;
        gz)   gzip -6  ;;
        lzma) lzma -zf  ;;
        lz)   lzip -z  ;;
        xz)   xz -zT0f  ;;
        zst)  zstd -z  ;;
    esac > "$tar_file"

    # Remove any instances of this package in the index
    # This will leave only the latest version
    as "$src_user" touch $bin_dir/$pkg_name/$repofile
    sed -i "/$pkg_name@/d" $bin_dir/$pkg_name/$repofile

    # Write the checksum to the repo file
    local cs=$(delegate -- "_sh256" "$tar_file")
    echo "$cs  $_tar_fn" >> "$bin_dir/$pkg_name/$repofile"
    log "$FUNCNAME" "$pkg_name" "repo index updated"

    cd "$OLDPWD"

    log "$FUNCNAME" "$pkg_name" "tarball created successfully"
    log "$FUNCNAME" '$tar_file' "$tar_file"

    # arg1: post-package
    # arg2: package name
    # arg3: path to tarball
    run_hook post-package "$pkg_name" "$tar_file"
}

# $@ packages name
pkg_build_all() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"

    local action="build"

    # Build packages and turn them into packaged tarballs.
    # Order the argument list and filter out duplicates.

    # Mark packages passed on the command-line explicit.
    # Also resolve dependencies for all explicit packages.
    for pkg_name do
        pkg_dirs "$action" "$pkg_name"
        pkg_depends "$pkg_name" expl filter
        explicit="$explicit $pkg_name "
    done

    # If this is an update, don't always build explicitly passsed packages
    # and instead install pre-built binaries if they exist.
    ok "$prefer_cache" || explicit_build=$explicit

    # If cross building, make sure the build machine has the correct deps
    set -- $makedeps
    [ "$#" -le 0 ] || die "$FUNCNAME" "You need the following packages on your build machine: $*"

    set --

    # If an explicit package is a dependency of another explicit package,
    # remove it from the explicit list.
    for pkg_name in $explicit; do
        contains "$deps" "$pkg_name" || set -- "$@" "$pkg_name"
    done
    explicit_cnt=$#
    explicit=$*

    log "$FUNCNAME" "" "Building: explicit $*${deps:+, implicit: ${deps## }}"

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    set -- $deps "$@"

    # Ask for confirmation if extra packages need to be built.
    equ "$#" "$explicit_cnt" || prompt

    log "$FUNCNAME" "" "Checking for pre-built dependencies"

    # Install any pre-built dependencies if they exist in the binary
    # directory and are up to date.
    for pkg_name in $@; do
        local tar_file="$(delegate -- "pkg_cache" "$pkg_name")"
        if ! contains "$explicit_build" "$pkg_name" && ok "$tar_file"; then
            log "$FUNCNAME" "$pkg_name" "Found pre-built binary"

            # Intended behavior.
            # shellcheck disable=2030,2031
            (export KISS_FORCE=1; args i "$tar_file")
        else
            set -- "$@" "$pkg_name"
        fi
        shift
    done

    for pkg_name do
        pkg_download "$pkg_name"
        local repo_dir="$(delegate -- "pkg_find" "$pkg_name")"
        IFS=$' ' read -r repo_ver repo_rel 2>/dev/null < "$repo_dir/version" ||
        die "$FUNCNAME" "$pkg_name" "Failed to read version file ($repo_dir/version)"
        [ ! -f "$repo_dir/sources" ] ||
        [ "$repo_ver" == "git" ] ||
        pkg_verify "$repo_dir" "$pkg_name"
    done

    [ -z ${KISS_ROOT:+x} ]          || log "$FUNCNAME" '$KISS_ROOT' "$KISS_ROOT"
    # Building on host (cross build)
    [ -z ${KISS_XBUILD_TRIPLE:+x} ] || log "$FUNCNAME" '$KISS_XBUILD_TRIPLE' "$KISS_XBUILD_TRIPLE"
    # Building for target (cross host)
    [ -z ${KISS_XHOST_TRIPLE:+x} ]  || log "$FUNCNAME" '$KISS_XHOST_TRIPLE' "$KISS_XHOST_TRIPLE"
    log "$FUNCNAME" '$bin_dir' "$bin_dir"
    [ -z ${CC:+x} ]      || log "$FUNCNAME" '$CC'       "$CC"
    [ -z ${CXX:+x} ]     || log "$FUNCNAME" '$CXX'      "$CXX"
    [ -z ${CFLAGS+x} ]   || log "$FUNCNAME" '$CFLAGS'   "$CFLAGS"
    [ -z ${CXXFLAGS+x} ] || log "$FUNCNAME" '$CXXFLAGS' "$CXXFLAGS"
    [ -z ${LDFLAGS+x} ]  || log "$FUNCNAME" '$LDFLAGS'  "$LDFLAGS"

    # Finally build and create tarballs for all passed packages and
    # dependencies.
    local _build_cur
    for pkg_name do
        log "$FUNCNAME" "$pkg_name" "Building package ($((_build_cur+=1))/$#)"

        log "$FUNCNAME" '$repo_dir' "$repo_dir [global]"
        IFS=$'\3' read -r repo_dir repo_ver repo_rel repo_major repo_minor repo_patch repo_ident \
            < <(pkg_version_split "$pkg_name") > /dev/null ||
            die "$FUNCNAME" 'pkg_version_split' "failed on $LINENO"
        null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"

        # arg1: queue-status
        # arg2: package name
        # arg3: number in queue
        # arg4: total in queue
        run_hook queue "$pkg_name" "$_build_cur" "$#"

        log "$FUNCNAME" '$repo_dir' "$repo_dir [local]"
        null "$repo_dir" && die "$FUNCNAME" '' "\$repo_dir not found [local]"
        [ ! -f "$repo_dir/sources" ] || pkg_to_make_dir "$pkg_name"

        log "$FUNCNAME" '$db'  "$db"
        log "$FUNCNAME" '$PWD' "$PWD"
        pkg_build    "$pkg_name"
        pkg_manifest "$pkg_name" "$pkg_dir/$pkg_name"
        pkg_strip    "$pkg_name"

        cd "$pkg_dir/$pkg_name/$db/$pkg_name"
        pkg_fix_deps "$pkg_name"
        pkg_etcsums  "$pkg_name"
        pkg_tar      "$pkg_name"

        if equ "${prefer_cache:=0}" 1 || ! contains "$explicit" "$pkg_name"; then
            log "$FUNCNAME" "$pkg_name" "Needed as a dependency or has an update, installing"

            # Intended behavior.
            # shellcheck disable=2030,2031
            (export KISS_FORCE=1; args i "$pkg_name")
        fi
    done

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    ! equ "${build_install:=1}" 1 || ! equ "${KISS_PROMPT:=1}" 1 ||
        ! prompt "Install built packages? [$explicit]" || (args i $explicit)
}

# could be subshell function before local version
# $1 pkg_name
pkg_build() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    # Install built packages to a directory under the package name to
    # avoid collisions with other packages.

    log "$FUNCNAME" '$pkg_dir'  "$pkg_dir"
    log "$FUNCNAME" '$bin_dir'  "$bin_dir"
    log "$FUNCNAME" '$log_dir'  "$log_dir"
    log "$FUNCNAME" '$proc_root/$pkg_name' "$proc_root/$pkg_name"
    log "$FUNCNAME" '$make_dir/$pkg_name' "$make_dir/$pkg_name"
    log "$FUNCNAME" '$repo_ver' "$repo_ver"
    log "$FUNCNAME" '$repo_dir' "$repo_dir [global]"

    local repo_dir="$(delegate -- "pkg_find" "$pkg_name")"

    ok "$repo_dir" || die "$FUNCNAME" '$repo_dir' "$repo_dir"

    log "$FUNCNAME" '$repo_dir'    "$repo_dir [local]"
    log "$FUNCNAME" '$pkg_name'    "$pkg_name"
    log "$FUNCNAME" '$db'          "$db"
    log "$FUNCNAME" '$LOGNAME'     "$LOGNAME"
    log "$FUNCNAME" '$pkg_dir/$pkg_name/$db' "$pkg_dir/$pkg_name/$db"

    mkcd "$FUNCNAME" "$make_dir/$pkg_name" "$pkg_dir/$pkg_name/$db"

    log "$FUNCNAME" "$pkg_name" "Starting build"

    # arg1: pre-build
    # arg2: package name
    # arg3: path to build directory
    run_hook pre-build "$pkg_name" "$make_dir/$pkg_name"

    # Attempt to create the log file early so any permissions errors are caught
    # before the build starts. 'tee' is run in a pipe and POSIX shell has no
    # pipe-fail causing confusing behavior when tee fails.
    # Log has been created when script booted
    # : > "$log_dir/build.log"

    [ -z "${USE_GMAKE+x}" ] || {
        log "$FUNCNAME" "GNU make used"
        [ "$(readlink -f "$bin_dir/$pkg_name/gunzip")" != "/usr/bin/pigz"  ] && as "$src_user" /usr/bin/ln -sf "/usr/bin/pigz"  "$bin_dir/$pkg_name/gunzip"
        [ "$(readlink -f "$bin_dir/$pkg_name/make")"   != "/usr/bin/gmake" ] && as "$src_user" /usr/bin/ln -sf "/usr/bin/gmake" "$bin_dir/$pkg_name/make"
        export PATH="$bin_dir/$pkg_name:$PATH"
    }

    # Call the build script, log the output to the terminal and to a file.
    # There's no PIPEFAIL in POSIX shell so we must resort to tricks like kill.
    {
        log "$FUNCNAME" '$LOGNAME' "$(whoami)"
        log "$FUNCNAME" '$PWD'     "$PWD"
        # Give the script a modified environment. Define toolchain program
        # environment variables assuming a generic environment by default.
        #
        # Define DESTDIR and GOPATH to sane defaults as their use is mandatory
        # in anything using autotools, meson, cmake, etc. Define KISS_ROOT as
        # the sanitized value used internally by the package manager. This is
        # safe to join with other paths.
        $(delegate -- as_user "$src_user") \
            env \
            AR="${AR:-ar}" \
            CC="${CC:-cc}" \
            CXX="${CXX:-c++}" \
            CFLAGS="${CFLAGS:-" -O3 -pipe -fPIC "}" \
            CXXFLAGS="${CXXFLAGS:-" -O3 -pipe -fPIC "}" \
            NM="${NM:-nm}" \
            RANLIB="${RANLIB:-ranlib}" \
            KISS_SRC_ROOT="$KISS_SRC_ROOT" \
            RUSTFLAGS="--remap-path-prefix=$PWD=. $RUSTFLAGS" \
            GOFLAGS="-trimpath -modcacherw $GOFLAGS" \
            GOPATH="$PWD/go" \
            PATH="$GOPATH/bin:$PATH" \
            KISS_TMPDIR="$KISS_TMPDIR" \
            REPO_MAIN="$REPO_MAIN" \
            KISS_ROOT="$KISS_ROOT" \
            KISS_XHOST_ARCH="$KISS_XHOST_ARCH" \
            KISS_XBUILD_ARCH="$KISS_XHOST_ARCH" \
            CHOST=${KISS_XHOST_TRIPLE} \
            CBUILD=${KISS_XBUILD_TRIPLE} \
            KISS_XHOST_ABI="$KISS_XHOST_ABI" \
            KISS_XBUILD_ABI="$KISS_XBUILD_ABI" \
            KISS_XHOST_TRIPLE="$KISS_XHOST_ARCH-linux-$KISS_XHOST_ABI" \
            KISS_XBUILD_TRIPLE="$KISS_XBUILD_ARCH-linux-$KISS_XBUILD_ABI" \
            SRCDIR="$src_root/$pkg_name" \
            LOGDIR="$log_dir" \
            REPODIR="$repo_dir/$pkg_name" \
            MAKEDIR="$make_dir/$pkg_name" \
            DESTDIR="$pkg_dir/$pkg_name" \
            \
            "$repo_dir/build" "$pkg_dir/$pkg_name" "$repo_ver" 2>&1 || {
            log "$FUNCNAME" "$pkg_name" "Build failed"
            log "$FUNCNAME" "$pkg_name" "If hardcoded doas/sudo/su/ssu, it is not recommended)"
            log "$FUNCNAME" "$pkg_name" "Log stored to $log_dir/build.log"

            # arg1: build-fail
            # arg2: package name
            # arg3: path to build directory
            (run_hook build-fail "$pkg_name" "$make_dir/$pkg_name") || :

            # pkg_clean_all
            kill 0
        }
    } | tee "$log_dir/build.log"

    # # Delete the log file if the build succeeded to prevent the directory
    # # from filling very quickly with useless logs.
    # equ "$KISS_KEEPLOG" 1 || rm -f "$log_dir/$pkg_name/build.log"

    # Copy the repository files to the package directory.
    as "$src_user" /usr/bin/cp -LRf "$repo_dir" "$pkg_dir/$pkg_name/$db/"

    log "$FUNCNAME" "$pkg_name" "Successfully built package"

    # arg1: post-build
    # arg2: package name
    # arg3: path to DESTDIR
    run_hook post-build "$pkg_name" "$pkg_dir/$pkg_name"
}

pkg_checksum() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"

    pkg_download "$pkg_name" c

    log "$FUNCNAME" '$repo_dir' "$repo_dir"
    [ -f "$repo_dir/sources" ] || return 0

    local hash="$(delegate -- "pkg_checksum_gen" "$pkg_name")"

    if ok "$hash"; then
        local as_kiss_root_usr=
        [ "$(whoami)" == "$kiss_root_user" ] || as_kiss_root_usr="$(delegate -- as_user "$kiss_root_user")"
        log "$FUNCNAME" '$as_kiss_root_usr' "$as_kiss_root_usr"
        $as_kiss_root_usr sh -c '/usr/bin/printf "%s\n" "$hash" > "$repo_dir/checksums"'
        log "$FUNCNAME" "$pkg_name" "Generated checksums"

    else
        log "$FUNCNAME" "$pkg_name" "No sources needing checksums"
    fi
}

# $@ :
pkg_checksum_gen() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    log "$FUNCNAME" '$repo_dir' "$repo_dir"
    # Generate checksums for packages.
    #
    # NOTE: repo_ comes from caller.
    while read -r src_url dest || ok "${src_url%%\#*}"; do
        IFS=$'\3' read -r _res _ \
            < <(source_route "$pkg_name" "$src_url" "$dest") > /dev/null ||
            die "$FUNCNAME" "source_route" "failed on $LINENO"

        case ${_res##git+*} in */*[!.])
            set -- "$@" "$_res"
        esac
    done < "$repo_dir/sources"

    printf "\n%s" "$(delegate -- "sh256" "$@")"
}

# $1 pkg_name : package name
pkg_verify() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local repo_dir="$1"
    local pkg_name="$2"

    # Verify all package checksums. This is achieved by generating a new set
    # of checksums and then comparing those with the old set.
    #
    # NOTE: repo_dir comes from caller.
    log "$FUNCNAME" "$pkg_name" "Verifying sources"

    # Generate a new set of checksums to compare against.
    local hash="$(delegate -- "pkg_checksum_gen" "$pkg_name")"

    # Intentional, globbing disabled.
    # shellcheck disable=2038,2086
    set -- $hash

    [ -f "$repo_dir/checksums" ] || {
        : > "$repo_dir/checksums"
        # printf '%s\n' "$hash" >> "$repo_dir/checksums"
    }

    # Check that the first column (separated by whitespace) match in both
    # checksum files. If any part of either file differs, mismatch. Abort.
    null "$1" || while read -r check _ || ok "$1"; do
        # printf '%s\n%s\n' "- ${check:-missing}" "+ ${1:-no source}"
        log "$FUNCNAME" '$check' "${check:-missing}"
        log "$FUNCNAME" '$_hash' "${1:-no source}"
        equ "$1-${check:-null}" "$check-$1" ||
        equ "$1-${check:-null}" "$1-SKIP" || {
            # as "$(stat -c '%U' "$repo_dir/checksums")" /usr/bin/printf '%s\n' "$1" > "$repo_dir/checksums"
            [ -n "${KISS_FORCE:+x}" ] || die "$FUNCNAME" "$pkg_name" "Checksum mismatch"
        }
        shift "$(($# != 0))"
    done < "$repo_dir/checksums"
}

# $1 pkg_name : package name
pkg_conflicts() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Check to see if a package conflicts with another.
    # pkg_name comes from the caller.
    local pkg_name="$1"

    log "$FUNCNAME" "$pkg_name" "Checking for package conflicts"

    local manifest_files="$(delegate -- "slot_aquire" "$FUNCNAME" "$pkg_name" "manifest-files")"
    local found_conflicts="$(delegate -- "slot_aquire" "$FUNCNAME" "$pkg_name" "found-conflicts")"
    [ -f "$tar_dir/$pkg_name/$db/$pkg_name/manifest" ] || die "$FUNCNAME" "$tar_dir/$pkg_name/$db/$pkg_name/manifest does not exist"
    # Filter the tarball's manifest and select only files. Resolve all
    # symlinks in file paths as well.
    while read -r file; do case $file in *[!/])
        resolve_path "$file"

        printf '%s\n' "$_rpath"
    esac done < "$tar_dir/$pkg_name/$db/$pkg_name/manifest" > "$manifest_files"

    cd "$tar_dir/$pkg_name"
    set +f
    set -f "$sys_db"/*/manifest

    # Remove the current package from the manifest list.
    local _fnr=$(delegate -- replace_left_with_right " $* " " " " $sys_db/$pkg_name/manifest ")

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    set -- $_fnr

    # Return here if there is nothing to check conflicts against.
    ! equ "$#" 0 || return 0

    # Store the list of found conflicts in a file as we'll be using the
    # information multiple times. Storing things in the cache dir allows
    # us to be lazy as they'll be automatically removed on script end.
    grep -Fxf "$manifest_files" -- "$@" 2>/dev/null > "$found_conflicts" || :

    # Enable alternatives automatically if it is safe to do so.
    # This checks to see that the package that is about to be installed
    # doesn't overwrite anything it shouldn't in '$REPO_ROOT/installed'.
    grep -q ":$REPO_ROOT/installed/" "$found_conflicts" || safe=1

    if ! equ "$KISS_CHOICE" 1 && equ "$safe" 1 && [ -s "$found_conflicts" ]; then
        # This is a novel way of offering an "alternatives" system.
        # It is entirely dynamic and all "choices" are created and
        # destroyed on the fly.
        #
        # When a conflict is found between two packages, the file
        # is moved to a directory called "choices" and its name
        # changed to store its parent package and its intended
        # location.
        #
        # The package's manifest is then updated to reflect this
        # new location.
        #
        # The 'kiss alternatives' command parses this directory and
        # offers you the CHOICE of *swapping* entries in this
        # directory for those on the filesystem.
        #
        # The alternatives command does the same thing we do here,
        # it rewrites manifests and moves files around to make
        # this work.
        #
        # Pretty nifty huh?
        while IFS=: read -r _ con; do
            log "$FUNCNAME" "Found conflict $con"

            # Create the "choices" directory inside of the tarball.
            # This directory will store the conflicting file.
            mkdir -p "$PWD/$cho_db"

            # Construct the file name of the "db" entry of the
            # conflicting file. (pkg_name>usr>bin>ls)
            local _fnr=$(delegate -- replace_left_with_right "$con" '>' '/')

            # Move the conflicting file to the choices directory
            # and name it according to the format above.
            mv -f "$PWD$con" "$PWD/$cho_db/$pkg_name$_fnr" 2>/dev/null || {
                log "$FUNCNAME" "File must be in ${con%/*} and not a symlink to it"
                log "$FUNCNAME" "This usually occurs when a binary is installed to"
                die "$FUNCNAME" "/sbin instead of /usr/bin (example)"
            }
        done < "$found_conflicts"

        log "$FUNCNAME" "$pkg_name" "Converted all conflicts to choices (kiss a)"

        # Rewrite the package's manifest to update its location
        # to its new spot (and name) in the choices directory.
        pkg_manifest "$pkg_name" "$tar_dir/$pkg_name"

    elif [ -s "$found_conflicts" ]; then
        log "$FUNCNAME" "Package '$pkg_name' conflicts with another package" "!>"
        log "$FUNCNAME" "Run 'KISS_CHOICE=1 kiss i $pkg_name' to add conflicts" "!>"
        die "$FUNCNAME" "as alternatives." "!>"
    fi
}

# $@ :
pkg_alternatives() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    if equ "$1" -; then
        while read -r pkg_name path; do
            pkg_swap "$pkg_name" "$path"
        done

    elif ok "$1"; then
        pkg_swap "$@"

    else
        # Go over each alternative and format the file
        # name for listing. (pkg_name>usr>bin>ls)
        set +f; for pkg_name in "$sys_ch/"*; do
            local _fnr=$(delegate -- replace_left_with_right "${pkg_name##*/}" '/' '>')
            # printf '%s %s\n' "${_fnr%%/*}" "/${_fnr#*/}"
            log "$FUNCNAME" "${_fnr%%/*} /${_fnr#*/}"
        done
    fi
}

pkg_swap() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Swap between package alternatives.
    [ -d "$sys_db/$1" ] || die "$FUNCNAME" "'$1' not found"

    local _fnr=$(delegate -- replace_left_with_right "$1$2" '>' '/')

    [ -f "$sys_ch/$_fnr" ] || [ -h "$sys_ch/$_fnr" ] ||
        die "$FUNCNAME" "" "Alternative '$1 ${2:-null}' doesn't exist"

    if [ -f "$KISS_ROOT/${2#/}" ]; then
        pkg_owner "/${2#/}" ||
            die "$FUNCNAME" "" "File '$2' exists on filesystem but isn't owned"

        log "$FUNCNAME" "Swapping '$2' from '$_owns' to '$1'"

        # Convert the current owner to an alternative and rewrite its manifest
        # file to reflect this.
        cp -Pf "$KISS_ROOT/${2#/}" "$sys_ch/$_owns>${_fnr#*>}"
        manifest_replace "$_owns" "$2" "/$cho_db/$_owns>${_fnr#*>}"
    fi

    # Convert the desired alternative to a real file and rewrite the manifest
    # file to reflect this. The reverse of above.
    mv -f "$sys_ch/$_fnr" "$KISS_ROOT/${2#/}"
    manifest_replace "$1" "/$cho_db/$_fnr" "$2"
}

file_rwx() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Convert the output of 'ls' (rwxrwx---) to octal. This is simply
    # a 1-9 loop with the second digit being the value of the field.
    #
    # NOTE: This drops setgid/setuid permissions and does not include
    # them in the conversion. This is intentional.
    unset oct o

    rwx=$(ls -ld "$1")

    for c in 14 22 31 44 52 61 74 82 91; do
        rwx=${rwx#?}

        case $rwx in
            [rwx]*) o=$((o + ${c#?})) ;;
             [st]*) o=$((o + 1)) ;;
        esac

        case $((${c%?} % 3)) in 0)
            oct=$oct$o
            o=0
        esac
    done
}

pkg_install_files() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    shift 1
    # Copy files and create directories (preserving permissions).
    # The 'test $1' will run with '-z' for overwrite and '-e' for verify.
    while { read -r file && _file=$KISS_ROOT$file; } do case $file in
        */)
            # Skip directories if they already exist in the file system.
            # (Think /usr/bin, /usr/lib, etc).
            [ -d "$_file" ] || {
                file_rwx "$2/${file#/}"
                mkdir -m "$oct" "$_file"
            }
        ;;

        *)
            # Skip directories and files which exist in verify mode.
            [ -d "$_file" ] || ! test "$1" "$_file" ||
                continue

            case $file in /etc/*[!/])
                # Handle /etc/ files in a special way (via a 3-way checksum) to
                # determine how these files should be installed. Do we overwrite
                # the existing file? Do we install it as $file.new to avoid
                # deleting user configuration? etc.
                #
                # This is more or less similar to Arch Linux's Pacman with the
                # user manually handling the .new files when and if they appear.
                pkg_etc "$file" "$pkg_name" || continue
            esac

            if [ -h "$_file" ]; then
                # Copy the file to the destination directory overwriting
                # any existing file.
                cp -fP "$2$file" "${_file%/*}/."

            else
                # Construct a temporary filename which is a) unique and
                # b) identifiable as related to the package manager.
                local __tmp=${_file%/*}/__kiss-tmp-$pkg_name-${file##*/}-$KISS_PID

                # Copy the file to the destination directory with the
                # temporary name created above.
                cp -fP "$2$file" "$__tmp" &&

                # Atomically move the temporary file to its final
                # destination. The running processes will either get
                # the old file or the new one.
                mv -f "$__tmp" "$_file"
            fi
    esac || return 1; done
}

pkg_remove_files() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Remove a file list from the system. This function runs during package
    # installation and package removal. Combining the removals in these two
    # functions allows us to stop duplicating code.
    while read -r file; do
        case $file in /etc/?*[!/])
            local hash="$(delegate -- "sh256" "$KISS_ROOT/${file#/}")"

            read -r sum_pkg <&3 ||:

            equ "$hash" "$sum_pkg" || {
                log "$FUNCNAME" "Skipping $file (modified)"
                continue
            }
        esac

        local _file=${KISS_ROOT:+"$KISS_ROOT/"}${file%%/}

        # Queue all directory symlinks for later removal.
        if [ -h "$_file" ] && [ -d "$_file" ]; then
            case $file in /*/*/)
                set -- "$@" "$_file"
            esac

        # Remove empty directories.
        elif [ -d "$_file" ]; then
            rmdir "$_file" 2>/dev/null || :

        # Remove everything else.
        else
            rm -f "$_file"
        fi
    done

    # Remove all broken directory symlinks.
    for sym do
        [ -e "$sym" ] || rm -f "$sym"
    done
}

pkg_etc() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local file="$1"
    local pkg_name="$2"
    local hash="$(delegate -- "sh256" "$tar_dir/$pkg_name/$file" "$KISS_ROOT/${file#/}")"

    local sum_new=${hash%%"$newline"*}
    local sum_sys=${hash#*"$newline"}

    read -r sum_old <&3 2>/dev/null ||:

    # Compare the three checksums to determine what to do.
    case ${sum_old:-null}${sum_sys:-null}${sum_new} in
        # old = Y, sys = X, new = Y
        "${sum_new}${sum_sys}${sum_old}")
            return 1
        ;;

        # old = X, sys = X, new = X
        # old = X, sys = Y, new = Y
        # old = X, sys = X, new = Y
        "${sum_old}${sum_old}${sum_old}"|\
        "${sum_old:-null}${sum_sys}${sum_sys}"|\
        "${sum_sys}${sum_old}"*)

        ;;

        # All other cases.
        *)
            war "$FUNCNAME" "$pkg_name" "saving $file as $file.new"
            _file=$_file.new
        ;;
    esac
}

removable() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    # Check if a package is removable and die if it is not.
    # A package is removable when it has no dependents.
    log "$FUNCNAME" "$pkg_name" "Checking if package removable"

    cd "$sys_db"
    set +f
    # ?
    pkg_name="$1"
    log "$FUNCNAME" '$pkg_name' "$pkg_name"

    ! grep -lFx -- "$pkg_name" */depends ||
        die "$FUNCNAME" "$pkg_name" "Not removable, has dependents"

    set -f
    cd "$OLDPWD"
}

# $1 pkg_name : package name
# could be subshell function before local version
pkg_remove() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    # Remove a package and all of its files. The '/etc' directory is handled
    # differently and configuration files are *not* overwritten.
    [ -d "$sys_db/$pkg_name" ] || die "$FUNCNAME" "'$pkg_name' not installed"

    # Intended behavior.
    # shellcheck disable=2030,2031
    equ "$KISS_FORCE" 1 || removable "$pkg_name"

    # Block being able to abort the script with 'Ctrl+C' during removal.
    # Removes all risk of the user aborting a package removal leaving an
    # incomplete package installed.
    trap '' INT

    # arg1: pre-remove
    # arg2: package name
    # arg3: path to installed database
    run_hook_pkg pre-remove "$pkg_name"
    run_hook     pre-remove "$pkg_name" "$sys_db/$pkg_name"

    log "$FUNCNAME" '$pkg_name' "$pkg_name"
    log "$FUNCNAME" "removing package" "$pkg_name"
    # Make a backup of any etcsums if they exist.
    [ -f "$sys_db/$pkg_name/manifest" ] && {
        [ ! -s "$sys_db/$pkg_name/etcsums" ] &&
        pkg_remove_files < "$sys_db/$pkg_name/manifest" || {
            local etcsums_clone="$(delegate -- "slot_push" "$FUNCNAME" "$pkg_name" "$sys_db/$pkg_name/etcsums")"
            pkg_remove_files < "$sys_db/$pkg_name/manifest" 3< "$etcsums_clone"
        }
    }
    rm -rf "$sys_db/$pkg_name"
    # Reset 'trap' to its original value. Removal is done so
    # we no longer need to block 'Ctrl+C'.
    trap 'pkg_clean_all "r" "$pkg_name"' EXIT INT

    log "$FUNCNAME" "$pkg_name" "removed successfully"
}

# could be subshell function before local version
# $1 pkg_name  : package name
# $2 depends   : depends file address
# $3 missing   : missing package(s)
installable() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_name="$1"
    local depents="$2"
    local missing="$3"
    # Check if a package is removable and die if it is not.
    # A package is removable when all of its dependencies
    # are satisfied.
    log "$FUNCNAME" "$pkg_name" "Checking if package installable"

    log "$FUNCNAME" '$PWD' "$PWD"
    log "$FUNCNAME" '$pkg_name' "$pkg_name"
    log "$FUNCNAME" '$depents' "$depents"

    null "$missing" || log "$FUNCNAME" '$missing' "$missing"

    # False positive.
    # shellcheck disable=2094
    ! [ -f "$depents" ] ||

    while read -r dep dep_type || ok "$dep"; do
        debug "$FUNCNAME" '$dep'    "$dep"
        debug "$FUNCNAME" '$sys_db' "$sys_db"
        case "$dep $dep_type" in [!\#]?*\ )
            { [ ! -d "$sys_db/$dep" ] && log "$FUNCNAME" '$dep not found' "$dep"; } || continue

            debug "$FUNCNAME" '$dep'      "$dep"
            war   "$FUNCNAME" '$dep'      "$dep"
            debug "$FUNCNAME" '$dep_type' "$dep_type"
            war   "$FUNCNAME" '$dep_type' "$dep_type"
            missing=$(($missing + 1))
            set -- "$pkg_name" "$depents" "$missing"
            # set -- "$1" "$2" "$(($3 + 1))"
        esac
    done < "$depents"
    null "$missing" || log "$FUNCNAME" '$missing' "$missing"
    debug "$FUNCNAME" '$3' "$3"
    debug "$FUNCNAME" '$missing' "$missing"
    case ${missing:-0} in [1-9]*)
        die "$FUNCNAME" "$pkg_name" "Package not installable, missing $missing package(s)"
    esac
}

# $1 diff source
# $2 diff target
repo_diff_is_null(){
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local a="$1"
    local b="$2"
    local differences=
    while IFS=$' ' read -r _ _ _ file _; do
        local base_name="${file##*/}"
        case "$base_name" in
            "keys"|"manifest"|"etcsums"|"checksums"|"depends") ;;
            *)
                differences="$file $differences"
                log "$FUNCNAME" "diff [$base_name]" "$file"
        esac
    done < <(diff -qrN "$a" "$b") > /dev/null ||
        die "$FUNCNAME" 'diff' "failed on $LINENO"
    return null "$differences"
}

# $1 pkg_url : package path
pkg_install() {
    set -eE
    trap 'trace_line "$FUNCNAME" "$LINENO"' ERR
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local pkg_url="$1"
    local action="install"
    log "$FUNCNAME" '$pkg_url' "$pkg_url"
    log "$FUNCNAME" '$repo_dir' "$repo_dir [global]"

    # Install a built package tarball.
    #
    # Package installation works similarly to the method used by Slackware in
    # some of their tooling. It's not the obvious solution to the problem,
    # however it is the best solution at this given time.
    #
    # When an installation is an update to an existing package, instead of
    # removing the old version first we do something different.
    #
    # The new version is installed overwriting any files which it has in
    # common with the previously installed version of the package.
    #
    # A "diff" is then generated between the old and new versions and contains
    # any files existing in the old version but not the new version.
    #
    # The package manager then goes and removes these files which leaves us
    # with the new package version in the file system and all traces of the
    # old version gone.
    #
    # For good measure the package manager will then install the new package
    # an additional time. This is to ensure that the above diff didn't contain
    # anything incorrect.
    #
    # This is the better method as it is "seamless". An update to busybox won't
    # create a window in which there is no access to all of its utilities.
    local tar_file
    local pkg_name
    # Install can also take the full path to a tarball. We don't need to check
    # the repository if this is the case.
    case $pkg_url in
        *.tar.*)
            log "$FUNCNAME" 'tar $pkg_url' "$pkg_url"

            [ -f "$pkg_url" ] || die "$FUNCNAME" "File '$pkg_url' does not exist"

            tar_file="$pkg_url"
            pkg_name="${pkg_url##*/}"
            pkg_name="${pkg_name%@*}"
            ;;

        *)
            log "$FUNCNAME" 'non tar $pkg_url' "$pkg_url"

            pkg_name="$pkg_url"
            tar_file="$(delegate -- "pkg_cache" "$pkg_name")"
            { [ "$?" -eq 0 ] && ok "$tar_file"; } || {  # die "$FUNCNAME" "$pkg_name" "not yet built"
                { action=c; ! pkg_checksum  "$pkg_name" 2>&1 > /dev/stderr; } ||
                { action=b; ! pkg_build_all "$pkg_name" 2>&1 > /dev/stderr; } ||
                tar_file="$(delegate -- "pkg_cache" "$pkg_name")"
                { [ "$?" -eq 0 ] && ok "$tar_file"; } || die "$FUNCNAME" "$pkg_name" "build failed"
            }
            ;;
    esac

    pkg_dirs "$action" "$pkg_name"

    log "$FUNCNAME" '$pkg_name' "$pkg_name"
    log "$FUNCNAME" '$tar_dir/$pkg_name'  "$tar_dir/$pkg_name"

    mkcd "$FUNCNAME" "$tar_dir/$pkg_name"

    # The tarball is extracted to a temporary directory where its contents are
    # then "installed" to the filesystem. Running this step as soon as possible
    # allows us to also check the validity of the tarball and bail out early
    # if needed.

    if ok "$tar_file"; then
        log "$FUNCNAME " '$tar_file' "$tar_file [local]"
    else
        die "$FUNCNAME " '' "\$tar_file not found [local]"
    fi

    decompress "$tar_file" | tar xf -

    # Naively assume that the existence of a manifest file is all that
    # determines a valid KISS package from an invalid one. This should be a
    # fine assumption to make in 99.99% of cases.
    [ -f "$tar_dir/$pkg_name/$db/$pkg_name/manifest" ] || die "$FUNCNAME" "Not a valid KISS package"

    # Intended behavior.
    # shellcheck disable=2030,2031
    equ "$KISS_FORCE" 1 || {
        manifest_validate "$pkg_name"
        installable "$pkg_name" "$tar_dir/$pkg_name/$db/$pkg_name/depends"
    }
    log "$FUNCNAME" '$PWD' "$PWD"

    # arg1: pre-install
    # arg2: package name
    # arg3: path to extracted package
    run_hook pre-install "$pkg_name" "$tar_dir/$pkg_name"

    pkg_conflicts "$pkg_name"

    log "$FUNCNAME" "$pkg_name" "Installing package (${tar_file##*/})"

    # If the package is already installed (and this is an upgrade) make a
    # backup of the manifest and etcsums files.
    local manifest="$(delegate -- "slot_push" "$FUNCNAME" "$pkg_name" "$sys_db/$pkg_name/manifest")"
    log "$FUNCNAME" '$manifest' "$manifest"

    local manifest_diff="$(delegate -- "slot_aquire" "$FUNCNAME" "$pkg_name" "manifest-diff")"
    log "$FUNCNAME" '$manifest_diff' "$manifest_diff"

    tar_man="$tar_dir/$pkg_name/$db/$pkg_name/manifest"

    # Generate a list of files which exist in the currently installed manifest
    # but not in the newer (to be installed) manifest.
    grep -vFxf "$tar_man" "$manifest" > "$manifest_diff" 2>/dev/null ||:

    # Reverse the manifest file so that we start shallow and go deeper as we
    # iterate over each item. This is needed so that directories are created
    # going down the tree.
    local manifest_reverse="$(delegate -- "slot_aquire" "$FUNCNAME" "$pkg_name" "manifest-reverse")"
    sort "$tar_man" > "$manifest_reverse"

    # Block being able to abort the script with Ctrl+C during installation.
    # Removes all risk of the user aborting a package installation leaving
    # an incomplete package installed.
    trap_off    # trap '' INT

    if [ -s "$sys_db/$pkg_name/etcsums" ]; then
        local etcsums_clone="$(delegate -- "slot_push" "$FUNCNAME" "$pkg_name" "$sys_db/$pkg_name/etcsums")"
        log "$FUNCNAME" '$etcsums_clone'  "$etcsums_clone"

        # Install the package's files by iterating over its manifest.
        pkg_install_files "$pkg_name" -z "$tar_dir/$pkg_name" < "$manifest_reverse" 3< "$etcsums_clone" &&

        # This is the aforementioned step removing any files from the old
        # version of the package if the installation is an update. Each file
        # type has to be specially handled to ensure no system breakage occurs.
        pkg_remove_files < "$manifest_diff" 3< "$etcsums_clone" &&

        # Install the package's files a second time to fix any mess caused by
        # the above removal of the previous version of the package.
        pkg_install_files "$pkg_name" -e "$tar_dir/$pkg_name" < "$manifest_reverse" 3< "$etcsums_clone"

        result="$?"
    else
        # Install the package's files by iterating over its manifest.
        pkg_install_files "$pkg_name" -z "$tar_dir/$pkg_name" < "$manifest_reverse" &&

        # This is the aforementioned step removing any files from the old
        # version of the package if the installation is an update. Each file
        # type has to be specially handled to ensure no system breakage occurs.
        pkg_remove_files < "$manifest_diff" &&

        # Install the package's files a second time to fix any mess caused by
        # the above removal of the previous version of the package.
        pkg_install_files "$pkg_name" -e "$tar_dir/$pkg_name" < "$manifest_reverse"

        result="$?"
    fi

    [ "$result" -eq 0 ] || {
        # pkg_clean_all
        war "$FUNCNAME" "$pkg_name" "Failed to install package."
        die "$FUNCNAME" "$pkg_name" "Filesystem now dirty, manual repair needed."
    }
    # Reset 'trap' to its original value. Installation is done so we no longer
    # need to block 'Ctrl+C'.
    trap_on "install" "$pkg_name" # trap pkg_clean_all EXIT INT

    # arg1: post-install
    # arg2: package name
    # arg3: path to installed package database
    run_hook_pkg post-install "$pkg_name"
    run_hook     post-install "$pkg_name" "$sys_db/$pkg_name"

    log "$FUNCNAME" '$sys_db'   "$sys_db"
    log "$FUNCNAME" '$tar_dir'  "$tar_dir"  # $HOME/.cache/kiss/proc/$pkg_name/extract
    log "$FUNCNAME" '$pkg_dir'  "$pkg_dir"  # $HOME/.cache/kiss/proc/$pkg_name/pkg
    log "$FUNCNAME" '$db'       "$db"
    log "$FUNCNAME" '$pkg_name' "$pkg_name"
    log "$FUNCNAME" '$pkg_dir/$pkg_name/$db/$pkg_name' "$pkg_dir/$pkg_name/$db/$pkg_name"
    log "$FUNCNAME" '$tar_dir/$pkg_name/$db/$pkg_name' "$tar_dir/$pkg_name/$db/$pkg_name"

    [ -d "$pkg_dir/$pkg_name/$db/$pkg_name" ] || die "$FUNCNAME" "$pkg_dir/$pkg_name/$db/$pkg_name" "does not exist"

    local repo_target="$(delegate -- "pkg_find" "$pkg_name" "" "-d" "$KISS_PATH")"
    # IFS=$'\3' read -r repo_target _ _ repo_ver repo_rel \
    #     < <(pkg_version "$FUNCNAME" "${pkg_name##*/}" "" "" "$pkg_dir/$pkg_name/$db") > /dev/null ||
    # die "$FUNCNAME" 'pkg_version' "failed on $LINENO"
    [ -d "$repo_target" ] || die  "$FUNCNAME" '$repo_target' "$repo_target"
    log "$FUNCNAME" '$repo_target' "$repo_target"
    IFS=$' ' read -r repo_ver repo_rel < <(cat "$repo_target/version") > /dev/null ||
    die "$FUNCNAME" 'cat "$repo_target/version"' "failed on $LINENO"
    log "$FUNCNAME" '$repo_ver' "$repo_ver"
    log "$FUNCNAME" '$repo_rel' "$repo_rel"

    local repo_source=

    [ -n "${REPO_ROOT:+x}" ] || die "$FUNCNAME" '$REPO_ROOT' "$REPO_ROOT"
    [ -n "${REPO_MAIN:+x}" ] || die "$FUNCNAME" '$REPO_MAIN' "$REPO_MAIN"
    [ -d "$REPO_MAIN" ] || die "$FUNCNAME" '$REPO_MAIN' "$REPO_MAIN directory does not exist"

    # package repo might be in sys_db / main repo / others
    # We want to create the relation between sys_db and main repo
    # key occupied : value consistency : key in main repo : value in main repo
    #   0                   ?                   0               ?               # is_key_global_conflicts_free=1; double keys have the same repo
    #                                                                           # copy sys_db/$pkg_name to main repo
    #   1                   1                   1               1               # repo_source="$repo"
    #   1                   1                   0               0               # copy sys_db/$pkg_name to main repo
    #   1                   0                   0               0               # To invent a wheel? Auto version and link to it? "choices"?

    # Move to pick_up? No, because you don't know it will build
    [ -n "${repo_target##*${sys_db}*}" ] || {
        local index_global=0
        local value_consistent=0

        for repo in $(find "$REPO_ROOT" \( -type d -o -type l \) -path "$sys_db" -prune -a -name "${pkg_name}" -print)
        do
            log "$FUNCNAME" '$repo' "$repo"
            # Guaranteed performance with step-by-step filtering
            diff -bwurB "$sys_db/$pkg_name/version" "$repo/version" > /dev/null 2>&1 || continue
            diff -bwurB "$sys_db/$pkg_name/build" "$repo/build" > /dev/null 2>&1 || continue
            local differences=$(repo_diff_is_null "$sys_db/$pkg_name" "$repo")
            index_global=$((index_global + 1))
            [ "$differences" -eq "0" ] || continue
            value_consistent=1
            IFS=$' ' read -r ver rel < <(cat "$repo/version") > /dev/null ||
            die "$FUNCNAME" "cat $repo/version" "failed on $LINENO"
            log "$FUNCNAME mapped" "${pkg_name}" "$repo [$ver-$rel]"
            [ -n "${repo##*${REPO_MAIN}*}" ] || {
                # Already in REPO_MAIN
                repo_source="$repo"
                break
            }
            # Out of REPO_MAIN
        done

        local target_dir="$REPO_MAIN/archive/$pkg_name"
        local repo_list=
        [ -n "$repo_source" ] ||
        [ "$value_consistent" -ne 0 ] || {
            # Key conflicts and content does not match / inconsistency
            [ -d "$target_dir" ] || \mkdir -p "$target_dir"
            # Search in main repo
            local version_dir
            for repo in $(delegate -- pkg_find $pkg_name "all" "-d" "$kiss_path_repo_main"); do
                # $REPO_MAIN/system/crust
                repo="$(standardize "$repo")"
                IFS=$' ' read -r ver rel < <(cat "$repo/version") > /dev/null ||
                die "$FUNCNAME" "cat $repo/version" "failed on $LINENO"
                version_dir="$ver-$rel"
                ok $(repo_diff_is_null "$sys_db/$pkg_name" "$repo") || {
                    [ ! -d "$target_dir/$version_dir" ] || {
                        local differences=$(repo_diff_is_null "$target_dir/$version_dir" "$repo")
                        [ "$differences" -eq "0" ] ||
                        \mv -f "$target_dir/$version_dir" "$target_dir/$version_dir.$(mktemp -u XXXXXX)"
                    }
                    [ -d "$target_dir/$version_dir" ] || \mv -f "$repo" "$target_dir/$version_dir"

                    rsync -aqz "$sys_db/$pkg_name/." --exclude=keys --exclude=manifest --delete-after "$repo/"
                    ok "$repo_source" || {
                        repo_source="$repo"
                        continue
                    }
                    \rm -rf "$repo"
                    continue
                }
                [ ! -d "$target_dir/$version_dir" ] || {
                    local differences=$(repo_diff_is_null "$target_dir/$version_dir" "$repo")
                    [ "$differences" -eq "0" ] ||
                    \mv -f "$repo" "$target_dir/$version_dir.$(mktemp -u XXXXXX)"
                }
                [ -d "$target_dir/$version_dir" ] || \mv -f "$repo" "$target_dir/$version_dir"
                [ ! -d "$repo" ] || \rm -rf "$repo"
            done
        }

        [ "$repo_source" != "$repo_target" ] || die  "$FUNCNAME" '$repo_source' "$repo_source is an unresolved orphan"
    }

    [ -n "$repo_source" ] || {
        log "$FUNCNAME backup" "$pkg_name" "$REPO_MAIN/extra/$pkg_name"
        rsync -aqz "$sys_db/$pkg_name" "$REPO_MAIN/extra/"
        repo_source="$REPO_MAIN/extra/$pkg_name"
    }

    local repo_source_encoded=$(delegate -- encode "$repo_source" "REPO_MAIN" "$REPO_MAIN")
    log "$FUNCNAME" '$repo_source' "$repo_source"

    local index_key=0
    local version_list=
    local length_index=$((WIDTH_SCOPE - TABSTOP))

    IFS_ORIGIN=$IFS
    IFS=$(printf '%b' "\x03")
    [ ! -f "$sys_db/$pkg_name/keys" ] ||
    while IFS=$' ' read -r ver rel repo; do
        null "$ver" || null "$rel" || null "$repo" ||
        { [ "$ver" = "$repo_ver" ] && [ "$rel" = "$repo_rel" ] && [ "$repo" = "$repo_source" ]; } ||
        [ -z "${version_list##*${ver}*${rel}*${repo}*}" ] || {
            log "$(printf "%-${TABSTOP}s %-${length_index}s" "$index_key" "$ver")" "$rel" "$repo"
            version_list="$version_list${ver} ${rel} ${repo}${IFS}"
        }
        : $((index_key += 1))
    done < "$sys_db/$pkg_name/keys"
    # No \n at the end
    version_list="$version_list${repo_ver} ${repo_rel} ${repo_source_encoded}"
    : > "$sys_db/$pkg_name/keys"
    for item in $version_list; do
        printf "%s\n" "$item" >> "$sys_db/$pkg_name/keys"
    done
    IFS=$IFS_ORIGIN

    local tail_deep=1
    while [ -z "$(tail -n $tail_deep "$sys_db/$pkg_name/keys")" ]; do : $((tail_deep += 1)); done
    IFS=$' ' read -r _ver _rel _repo_source \
        < <(tail -n $tail_deep "$sys_db/$pkg_name/keys" | grep "$repo_ver" | grep "$repo_rel") > /dev/null || {
        cat "$sys_db/$pkg_name/keys"
        die "$FUNCNAME" 'query current key' "failed on $LINENO"
    }

    [ "$_repo_source" == "$repo_source_encoded" ] || die "$FUNCNAME" '$_repo_source' "$_repo_source"

    local route
    local c2_origin="$c2"
    c2="$c1"
    route="->"
    log "$(printf "%-${TABSTOP}d %-${length_index}s %-${TABSTOP}d" 0 "$repo_ver" "$repo_rel")" \
        "$(printf '%-2s %s' "$route" "$sys_db/$pkg_name")"
    route="<-"
    log "$(printf "%-${TABSTOP}d %-${length_index}s %-${TABSTOP}d" 1 "$repo_ver" "$repo_rel")" \
        "$(printf '%-2s %s' "$route" "$repo_source")"
    unset route
    c2="$c2_origin"

    log "$FUNCNAME" "$pkg_name" "installed successfully"

}

pkg_update() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    log "$FUNCNAME" "" "Updating repositories"

    # Create a list of all repositories.
    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    { IFS_ORIGIN=$IFS; IFS=:; set -- $KISS_PATH; IFS=$IFS_ORIGIN; }

    # Update each repository in '$KISS_PATH'.
    for repo do
        local repo_type
        if git -C "$repo" rev-parse 'HEAD@{upstream}' >/dev/null 2>&1; then
            repo_type=git

            # Get the Git repository root directory.
            local subm=$(git -C "$repo" rev-parse --show-superproject-working-tree)
            repo=$(git -C "${subm:-"$repo"}" rev-parse --show-toplevel)

        elif ! [ -d "$repo" ]; then
            continue
        else
            unset repo_type
        fi

        pkg_update_repo $repo_type $repo
    done

    pkg_upgrade
}

# $1 repo_type
# $2 repo
pkg_update_repo() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local repo_type=$1
    local repo=$2
    cd "$repo" || die "$FUNCNAME" "Repository '$repo' inaccessible"

    local repos
    contains "$repos" "$PWD" || {
        repos="$repos $PWD"

        log "$FUNCNAME" '$PWD' "$PWD"

        IFS=$'\3' read -r  pwd_user _  \
            < <(am_owner "$PWD") > /dev/null ||
            die "$FUNCNAME" 'am_owner' "failed on $LINENO"
        equ "pwd_user" "$LOGNAME" || {
            log "$FUNCNAME" 'Needs "$user" to update to' "$pwd_user"
            set -- $(delegate -- as_user "$user")
        }

        # arg1: pre-update
        # arg2: need su?
        # arg3: owner
        # env:  PWD is path to repository
        run_hook pre-update "$#" "$user"

        case $repo_type in git)
            pkg_update_git "$@"
        esac

        # arg1: post-update
        # env:  PWD is path to repository
        run_hook post-update
    }
}

pkg_update_git() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Display whether or not signature verification is enabled.
    case $(git config --get merge.verifySignatures) in true)
        log "$FUNCNAME" 'Signature verification enabled.'
    esac

    "$@" git pull
    "$@" git submodule update --remote --init -f
}

pkg_upgrade() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"

    local action="upgrade"

    log "$FUNCNAME" "Checking for new package versions"
    set +f

    for pkg_name in "$sys_db/"*; do set -f
        pkg_dirs "$action" "$pkg_name"
        IFS=$'\3' read -r repo_dir ver_pre rel_pre repo_ver repo_rel \
            < <(pkg_version "$FUNCNAME" "${pkg_name##*/}" "" "" "$sys_db") > /dev/null ||
        die "$FUNCNAME" 'pkg_version' "failed on $LINENO"
        null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
        null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"
        IFS=$'\3' read -r repo_dir ver_pre rel_pre repo_ver repo_rel \
            < <(pkg_version "$FUNCNAME" "${pkg_name##*/}") > /dev/null ||
        die "$FUNCNAME" 'pkg_version' "failed on $LINENO"
        null "$repo_dir" && die "$FUNCNAME" '$repo_dir' "$repo_dir"
        null "$repo_ver" && die "$FUNCNAME" '$repo_ver' "$repo_ver"

        # Detect repository orphans (installed packages with no
        # associated repository).
        case $repo_dir in *"$REPO_ROOT/installed/"*)
            _repo_orp="$_repo_orp$newline${pkg_name##*/}"
        esac

        # Compare installed packages to repository packages.
        equ "$ver_pre-$rel_pre" "$repo_ver-$repo_rel" || {
            set -- "$@" "${pkg_name##*/}"

            log "$FUNCNAME" "${pkg_name##*/} $ver_pre-$rel_pre => $repo_ver-$repo_rel"
        }
    done

    case $_repo_orp in *?*)
        war "$FUNCNAME" "" "Packages without repository$_repo_orp"
    esac

    build_install=0
    prefer_cache=1

    ! contains "$*" kiss || {
        log "$FUNCNAME" "" "Detected package manager update"
        log "$FUNCNAME" "" "The package manager will be updated first"

        prompt
        pkg_build_all kiss

        log "$FUNCNAME" "" "Updated the package manager"
        log "$FUNCNAME" "" "Re-run 'kiss update' to update your system"
        return 0
    }

    for _ do
        IFS=$'\3' read -r order redro < <(pkg_order "$@") > /dev/null ||
            die "$FUNCNAME" 'pkg_order' "failed on $LINENO"

        # Intentional, globbing disabled.
        # shellcheck disable=2046,2086
        set -- $order

        prompt "Packages to update ($#): $*"
        pkg_build_all "$@"
        log "$FUNCNAME" "" "Updated all packages"
        return 0
    done

    log "$FUNCNAME" "" "Nothing to do"
}

# $1 action
# $2 pkg_name_00
# $3 pkg_name_00
# ...
# Claen all? $@ might has multiple packages
pkg_clean_all() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Clean up on exit or error. This removes everything related to the build.
    # If _KISS_LVL is (1) we are the top-level process - the entire cache will
    # be removed. If _KISS_LVL is any other value, remove only the tar directory.

    local action="$1"
    shift 1
    { [ "$action" != "pick" ] && [ "$action" != "p" ] &&
    [ "$action_of_session" != "pick" ] && [ "$action_of_session" != "p" ]; } || set -- "$1"
    for pkg_name in $@; do
        # https://stackoverflow.com/questions/32107041/how-to-check-if-a-string-only-contains-digits-numerical-characters
        # [ $(expr "x$pkg_name" : "x[0-9]*$") -le 0 ] && continue
        log "$FUNCNAME" '$action' "$action"
        log "$FUNCNAME" '$pkg_name' "$pkg_name"
        [ -d "$proc_root" ] || die "$FUNCNAME" '$proc_root' "$proc_root"
        debug "$FUNCNAME" '$tar_dir'    "$tar_dir"
        debug "$FUNCNAME" '$KISS_DEBUG' "$KISS_DEBUG"
        debug "$FUNCNAME" '$_KISS_LVL'  "$_KISS_LVL"

        case $action in
            i|install)
                log_permanent_all "$action" "$pkg_name"
        esac

        case ${KISS_DEBUG:-0}-${_KISS_LVL:-1} in
            0-1) null "$proc_root" || [ "$(standardize "$proc_root")" = "/proc" ] || pkg_clear "$action" "$pkg_name" ;;
            0-*) null "$tar_dir" || [ "$(occurrences "$tar_dir" "/")" -eq "1" ] || as "$kiss_root_user" find "$tar_dir/$pkg_name" -mindepth 1 -delete
        esac
    done
}

# $@ :
pkg_help_ext() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    debug "$FUNCNAME" '$#' "$#"
    log "$FUNCNAME" "" 'Installed extensions (kiss-* in PATH)'

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2030,2031
    set -- $(delegate -- "pkg_find" kiss-\* all -x "$PATH")
    null "$1" && die "$FUNCNAME" '$repo_dir' "$1"

    local path_list
    # To align descriptions figure out which extension has the longest
    # name by doing a simple 'name > max ? name : max' on the basename
    # of the path with 'kiss-' stripped as well.
    #
    # This also removes any duplicates found in '$PATH', picking the
    # first match.
    for path do
        p=${path#*/kiss-}

        [ -d "$path" ] && continue
        case " $seen " in *" $p "*)
            shift
            continue
            ;;
            *) path_list="$path_list $path"
        esac

        seen=" $seen $p "
        max=$((${#p} > max ? ${#p}+1 : max))
    done
    log "$FUNCNAME" '$#' "$#"
    set -- $path_list
    log "$FUNCNAME" '$#' "$#"
    IFS_ORIGIN=$IFS
    IFS=\#$IFS

    # Print each extension, grab its description from the second line
    # in the file and align the output based on the above max.
    for path do
        # Open the extension as a file descriptor.
        exec 3< "$path"

        # Grab the second line in the extension.
        { read -r _ && IFS=\#$IFS read -r _ cmt; } <&3

        printf "%b->%b %-${max}s %s\\n" \
            "$c1" "$c3" "${path#*/kiss-}" "$cmt"
    done >&2
    IFS=$IFS_ORIGIN
}

trap_on() {
    # Catch errors and ensure that build files and directories are cleaned
    # up before we die. This occurs on 'Ctrl+C' as well as success and error.
    trap trap_INT  INT
    trap 'trap_EXIT "$@"' EXIT
}

trap_INT() {
    run_hook SIGINT
    exit 1
}

trap_EXIT() {
    pkg_clean_all "$@"
    run_hook SIGEXIT
}

trap_off() {
    # Block being able to abort the script with 'Ctrl+C'. Removes all risk of
    # the user aborting a package install/removal leaving an incomplete package
    # installed.
    trap "" INT EXIT
}

generate_share_link() {
    [ "$#" -ge "6" ] || die "$FUNCNAME" "input" "arguments less than 6"
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local body_root_name="$1"
    local anchor_root_name="$2"
    local parent_dir="$3"
    local src_user="$4"
    local cache_dir="$5"
    local anchor_folder="$6"

    eval ": \"\${$body_root_name:=\"$parent_dir/$anchor_folder\"}\""
    # eval "true \"\${$body_root_name:=\"$parent_dir/$anchor_folder\"}\""
    # eval "$body_root_name=\"$parent_dir/$anchor_folder\""
    local body_root_value="$(eval "printf '%s' \"\$$body_root_name\"")"
    #                   name            value
    log "$FUNCNAME" "$body_root_name ->" "$body_root_value"
    [ "$body_root_value" == "$parent_dir/$anchor_folder" ] ||
    die  "$FUNCNAME" "$body_root_name" "$body_root_value"

    [ -d "$body_root_value" ] ||
        as $(stat -c '%U' "${parent_dir}") /usr/bin/mkdir -p "$body_root_value"

    eval "$anchor_root_name=\"$cache_dir/$anchor_folder\""
    local anchor_root_value="$(eval "printf '%s' \"\$$anchor_root_name\"")"
    #                   name            value
    log "$FUNCNAME" "$anchor_root_name <-" "$anchor_root_value"
    [ "$anchor_root_value" == "$cache_dir/$anchor_folder" ] ||
    die  "$FUNCNAME" "$anchor_root_name" "$anchor_root_value"

    { [ -L "$anchor_root_value" ] &&
        [ "$body_root_value" = "$(readlink -f "$anchor_root_value")" ]; } || {
            [ ! -d "$anchor_root_value" ] || [ -L "$anchor_root_value" ] || {
                [ "$(stat -c '%U' "$anchor_root_value")" == "$src_user" ] ||
                as "root" /usr/bin/chown -R $src_user:users "$anchor_root_value"
                as $src_user /usr/bin/rsync -aqz "$anchor_root_value/." "$body_root_value/"
            }
            as $src_user /usr/bin/rm -rf "$anchor_root_value"
            ln -sf "$body_root_value" "$anchor_root_value"
        }
    eval "$anchor_root_name=\"$body_root_value\""
}

init_dirs() {
    local ppwd="$1"

    {
        : "${KISS_SRC_ROOT:?kiss requires KISS_SRC_ROOT be set (prefer to a normal users share folder)}"
        KISS_SRC_ROOT="$(standardize "$KISS_SRC_ROOT")"
        [ -d "$KISS_SRC_ROOT" ] ||
        as $(stat -c '%U' "${KISS_SRC_ROOT%/*}") /usr/bin/mkdir -p "$KISS_SRC_ROOT"

        [ -n "${src_user:+x}" ] ||
        src_user="$(stat -c '%U' "$(readlink -f "$KISS_SRC_ROOT")")"

        # Neither the log folder nor the file is created at this moment. So don't use log functions
        # printf '%s %s %s\n' "$FUNCNAME" '$src_user' "$src_user"
        [ -n "${KISS_TMPDIR:+x}" ] || KISS_TMPDIR="/tmp/${HOME:1}/kiss"
        [ -d "$KISS_TMPDIR" ] || mkdir -p "$KISS_TMPDIR"
        proc_volatile="$KISS_TMPDIR/proc"
        [ -d "$proc_volatile" ] || mkdir -p "$proc_volatile"
        log_dir_original="$KISS_TMPDIR/logs"
        [ -d "$log_dir_original" ] || mkdir -p "$log_dir_original"

        [ "$log_dir" = "$log_dir_original" ] || log_dir="$log_dir_original"
        touch "$log_dir/build.log"
        hint "$FUNCNAME" 'New session' "started"
    }

    # Root directory standardization
    KISS_ROOT=${KISS_ROOT%"${KISS_ROOT##*[!/]}"}
    [ -n "${kiss_root_user:+x}" ] ||
    IFS=$'\3' read -r  kiss_root_user _ \
        < <(am_owner "$KISS_ROOT/") > /dev/null ||
    die "$FUNCNAME" 'am_owner' "failed on $LINENO"
    # This allows for automatic setup of a KISS chroot and will
    # do nothing on a normal system.
    [ -d "$KISS_ROOT/" ] ||
    as $kiss_root_user /usr/bin/mkdir -p "$KISS_ROOT/" 2>/dev/null || :

    # System package database.
    [ -n "${REPO_ROOT:+x}" ] || REPO_ROOT="/var/db/kiss"
    [ -d "$REPO_ROOT" ] || die "$FUNCNAME" '$REPO_ROOT' "does not exist"
    sys_db=$KISS_ROOT/${db:="${REPO_ROOT#*/}/installed"}
    sys_ch=$KISS_ROOT/${cho_db:="${REPO_ROOT#*/}/choices"}
    log "$FUNCNAME" '$db' "$db"
    log "$FUNCNAME" '$cho_db' "$cho_db"

    [ -n "${REPO_MAIN:+x}" ] || [ "$action" != "i" ] || [ "$action" != "install" ] ||
    die "$FUNCNAME" '$REPO_MAIN' "for reverse copying sys_db/repo to the main repo"

    # Top-level cache directory.
    cache_dir=${XDG_CACHE_HOME:-"${HOME%"${HOME##*[!/]}"}/.cache"}
    cache_dir=${cache_dir%"${cache_dir##*[!/]}"}/kiss
    [ -d "$cache_dir" ] || mkdir -p "$cache_dir"

    # : "${share_src_root:="$KISS_SRC_ROOT/sources"}"
    generate_share_link "share_src_root" "src_root" "$KISS_SRC_ROOT" "$src_user" "$cache_dir" "sources"

    # src_root_user="$(stat -c '%U' "$(readlink -f "${src_root}")")"

    # : "${share_proc_root:="$KISS_SRC_ROOT/proc"}"
    generate_share_link "share_proc_root" "proc_root" "$KISS_SRC_ROOT" "$src_user" "$cache_dir" "proc"

    # : "${share_archive_root:="$KISS_SRC_ROOT/archive"}"
    generate_share_link "share_archive_root" "archive_root" "$KISS_SRC_ROOT" "$src_user" "$cache_dir" "archive"


    log "$FUNCNAME" '$KISS_SRC_ROOT' "$KISS_SRC_ROOT"
    log "$FUNCNAME" '$KISS_ROOT/' "$KISS_ROOT/"
    log "$FUNCNAME" '$src_user' "$src_user"
    log "$FUNCNAME" '$kiss_root_user' "$kiss_root_user"
    log "$FUNCNAME" '$time' "$time"
    log "$FUNCNAME" '$sys_db' "$sys_db"
    log "$FUNCNAME" '$proc_volatile' "$proc_volatile"
}

pkg_clear() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"

    local action="$1"
    local pkg_name="$2"

    [ ! -d "$make_dir/$pkg_name" ] || [ "$make_dir" = "/make" ] || find "$make_dir/$pkg_name" -mindepth 1 -delete
    [ ! -d "$tmp_dir/$pkg_name" ] || [ "$tmp_dir" = "/tmp" ] || as "$kiss_root_user" find "$tmp_dir/$pkg_name" -mindepth 1 -delete

    [ "pick" == "$action" ] || [ "p" == "$action" ] ||
    [ "install" == "$action" ] || [ "i" == "$action" ] || {
        [ ! -d "$pkg_dir/$pkg_name" ] || [ "$pkg_dir" = "/pkg" ] || as "$kiss_root_user" find "$pkg_dir/$pkg_name" -mindepth 1 -delete
        [ ! -d "$tar_dir/$pkg_name" ] || [ "$tar_dir" = "/extract" ] || as "$kiss_root_user" find "$tar_dir/$pkg_name" -mindepth 1 -delete
    }

    # For pick_up to do a series of operations, we don't delete the results
    # tar_file in $bin_dir/$pkg_name mean building succeeded
    # [ ! -d "$bin_dir/$pkg_name" ] || [ "$bin_dir" = "/bin" ] || find "$bin_dir/$pkg_name" -mindepth 1 -delete

    # [ "$src_root/$pkg_name" = "/$pkg_name" ]    || find "$src_root/$pkg_name"  -mindepth 1 -delete

    # [ ! -d "${KISS_TMPDIR}/proc" ] ||
    # for item in $(\ls -x "${KISS_TMPDIR}/proc"); do [ "$item" = "$pkg_name" ] || \rm -rf "${KISS_TMPDIR}/proc/$item"; done
}

change_owner() {
    target_dir="$1"
    root_dir_user="$2"
    target_dir_user="$3"
    root_dir_group="$4"

    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    $(delegate -- as_user "$target_dir_user") chown -R $root_dir_user:$root_dir_group "${target_dir}" > /dev/null 2>&1 ||
    $(delegate -- as_user "$root_dir_user") chown -R $root_dir_user:$root_dir_group "${target_dir}" > /dev/null 2>&1 ||
    # Hard code root is not good
    as "$kiss_root_user" chown -R $root_dir_user:$root_dir_group "${target_dir}" > /dev/null 2>&1 ||
    die "$FUNCNAME" "chown ${target_dir}" "failed on $((LINENO - 3))"
}

maintain_ownership() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local root_dir="$1"
    [ ! -L "$root_dir" ] || root_dir="$(readlink -f "$root_dir")"
    local target_dir="$2"
    [ ! -L "$target_dir" ] || target_dir="$(readlink -f "$target_dir")"
    shift $#
    IFS=$'\3' read -r root_dir_user root_dir_group \
        < <(am_owner "$root_dir") > /dev/null ||
        die "$FUNCNAME" 'am_owner' "failed on $LINENO"

    log "$FUNCNAME" '$root_dir' "$root_dir"
    log "$FUNCNAME" '$target_dir' "$target_dir"
    log "$FUNCNAME" '$root_dir_user' "$root_dir_user"

    if [ -d "$target_dir" ]; then
        IFS=$'\3' read -r target_dir_user target_dir_group \
            < <(am_owner "$target_dir") > /dev/null ||
        die "$FUNCNAME" 'am_owner' "failed on $LINENO"

        { equ "$target_dir_user" "$root_dir_user" && equ "$target_dir_group" "$root_dir_group"; } || {
            if equ "$target_dir_user" "$root_dir_user"; then
                $(delegate -- as_user "$target_dir_user") chgrp -R $root_dir_group "${target_dir}" > /dev/null 2>&1 ||
                $(delegate -- as_user "$root_dir_user") chgrp -R $root_dir_group "${target_dir}" > /dev/null 2>&1 ||
                # Hard code root is not good
                as "$kiss_root_user" chgrp -R $root_dir_group "${target_dir}" > /dev/null 2>&1 ||
                die "$FUNCNAME" "chgrp ${target_dir}" "failed on $LINENO"
            else
                change_owner "${target_dir}" "$root_dir_user" "$target_dir_user" "$root_dir_group"
            fi
        }

        # File name might have spaces
        local found_folder_onwership_issue=0
        local item_user
        IFS_ORIGIN=$IFS
        IFS=$'\n'
        local index=0
        for item in $(find "${target_dir}" -name "*"); do
            [ "$index" -le 10 ] || break
            [ -f "$item" ] || continue
            item_user="$(stat -c '%U' "$item")"
            [ "$item_user" != "$root_dir_user" ] || { : $((index += 1)); continue; }

            log "$FUNCNAME" '$item' "$item"
            log "$FUNCNAME" '$item_user' "$item_user"
            found_folder_onwership_issue=1
            break
        done
        IFS=$IFS_ORIGIN
        # Won't work inside for loop with special $IFS
        [ "$found_folder_onwership_issue" -eq "0" ] ||
        change_owner "${target_dir}" "$root_dir_user" "$item_user" "$root_dir_group"
    else
        $(delegate -- as_user "$root_dir_user") mkdir -p "$target_dir"
    fi
}

# make or point to pkg_name related dirs
# $1 pkg_name
pkg_dirs() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"

    local action="$1"
    local pkg_name="$2"

    [ -n "${src_user:+x}" ] ||
    IFS=$'\3' read -r  src_user _ \
        < <(am_owner "$KISS_SRC_ROOT") > /dev/null ||
    die "$FUNCNAME" 'am_owner' "failed on $LINENO"

    debug "$FUNCNAME" '$pkg_name' "$pkg_name"
    {
        ok "$log_dir_original" || die "$FUNCNAME" "\$log_dir_original is not defined"

        local as_src_user="$(delegate -- as_user "$src_user")"
        [ ! -L "$proc_root" ] || proc_root="$(readlink -f "$proc_root")"

        # Temporary cache directories.
        make_dir="$proc_volatile/make"
        tmp_dir="$proc_volatile/tmp"
        # log_dir="$proc_volatile/logs"

        pkg_dir="$proc_root/pkg"
        tar_dir="$proc_root/extract"
        bin_dir="$proc_root/bin"


        # set +e will bypass the following exit
        # [ -d "${proc_root}" ] && equ "reset" "$2" && \rm -rf "$proc_root"
        # Removing "|| :", and adding the following line will get the same effect
        # [ $? -ne 0 ] && log "$FUNCNAME" "" "[] error occurred"

        # Using as $some_user of $(delegate -- as_user "$some_user") all will fail because they pick up
        # the new $log_dir to display content. But that location does not exist yet
        mkdir -p \
            "$make_dir" \
            "$tmp_dir"

            # "$log_dir" \

        $as_src_user /usr/bin/mkdir -p \
            "$pkg_dir" \
            "$tar_dir" \
            "$bin_dir"

        # [ -f "${log_dir}/build.log" ] ||
        # [ ! -f "${log_dir_original}/build.log" ] ||
        # \mv -f "${log_dir_original}/build.log" "${log_dir}/"

        [ ! -d "${proc_root}" ] || [ -z "${pkg_name:+x}" ] || {
            maintain_ownership "$pkg_dir" "$pkg_dir/$pkg_name"
            maintain_ownership "$tar_dir" "$tar_dir/$pkg_name"
            maintain_ownership "$bin_dir" "$bin_dir/$pkg_name"
            maintain_ownership "$src_root" "$src_root/$pkg_name"
            maintain_ownership "$archive_root" "$archive_root/$pkg_name"

            pkg_clear "$action" "$pkg_name"

            mkdir -p \
                "$tmp_dir/$pkg_name" \
                "$make_dir/$pkg_name"

            $as_src_user /usr/bin/mkdir -p \
                "$pkg_dir/$pkg_name" \
                "$tar_dir/$pkg_name" \
                "$bin_dir/$pkg_name"

        }

        # [ "$(readlink -f "${log_dir}/build.log")" == "${log_dir_original}/build.log" ] ||
        # ln -sf "${log_dir_original}/build.log" "${log_dir}/build.log"

        log "$FUNCNAME" '$log_dir' "$log_dir"
    }

    # Naming convention:
    # directory path
    # directory name
    #           folder (name)


    log "$FUNCNAME" '$make_dir' "$make_dir"
    log "$FUNCNAME" '$tmp_dir' "$tmp_dir"
    log "$FUNCNAME" '$log_dir' "$log_dir"
    log "$FUNCNAME" '$pkg_dir' "$pkg_dir"
    log "$FUNCNAME" '$tar_dir' "$tar_dir"
    log "$FUNCNAME" '$bin_dir' "$bin_dir"
    log "$FUNCNAME" '$src_root' "$src_root"
    log "$FUNCNAME" '$archive_root' "$archive_root"

    # printf "%s" "$proc_root"
}

log_permanent_all() {
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    set -eE
    trap 'trace_line "$FUNCNAME" "$LINENO"' ERR
    local action="$1"
    shift 1
    { [ "$action" != "pick" ] && [ "$action" != "p" ] &&
    [ "$action_of_session" != "pick" ] && [ "$action_of_session" != "p" ]; } || set -- "$1"
    [ "$#" -ge "1" ] || die "$FUNCNAME" "package based log not available"
    local log_dir_permanent
    debug "$FUNCNAME" '$log_dir' "$log_dir"
    for pkg_name in $@; do
        log "$FUNCNAME" '$pkg_name' "$pkg_name"
        # [ $(expr "x$pkg_name" : "x[0-9]*$") -le 0 ] && continue

        log_dir_permanent="$cache_dir/logs/$pkg_name"
        [ -d "$log_dir_permanent" ] || mkdir -p "$log_dir_permanent"

        [ ! -f "$log_dir/build.log" ] || {
            debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
            debug "$FUNCNAME" '$log_dir_permanent' "$log_dir_permanent"
            # \mv -f "$log_dir/build.log" "$log_dir_permanent/"
            \cp -f "$log_dir/build.log" "$log_dir_permanent/"
        }
        log "$FUNCNAME" 'find log at' "$log_dir_permanent/build.log"
    done
}

subshell_action_all() {
    local action="$1"
    shift 1

    trap_off
    for pkg_name in $@; do
        $(delegate -- as_user "$kiss_root_user") \
            env \
            KISS_SRC_ROOT="$KISS_SRC_ROOT" \
            LOGNAME="$kiss_root_user" \
            HOME="$HOME" \
            XDG_CACHE_HOME="$XDG_CACHE_HOME" \
            KISS_COMPRESS="$KISS_COMPRESS" \
            KISS_PATH="$KISS_PATH" \
            KISS_FORCE="$KISS_FORCE" \
            KISS_ROOT="$KISS_ROOT" \
            KISS_CHOICE="$KISS_CHOICE" \
            KISS_COLOR="$KISS_COLOR" \
            KISS_TMPDIR="$KISS_TMPDIR" \
            REPO_MAIN="$REPO_MAIN" \
            KISS_PID="$KISS_PID" \
            _KISS_LVL="$_KISS_LVL" \
            SRCDIR="$src_root/$pkg_name" \
            MAKEDIR="$make_dir/$pkg_name" \
            "$0" "$action" "$pkg_name"
    done
    trap_on "$action" "$@"
}

args() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Parse script arguments manually. This is rather easy to do in our case
    # since the first argument is always an "action" and the arguments that
    # follow are all package names.
    action="$1"
    log "$FUNCNAME" '$action' "$action"

    shift "$(($# != 0))"

    # Ensure that arguments do not contain invalid characters. Wildcards can
    # not be used here as they would conflict with kiss extensions.
    case $action in
        a|alternatives)
            case $1 in *\**|*\!*|*\[*|*\ *|*\]*|*/*|*"$newline"*)
                die "$FUNCNAME" "Invalid argument: '!*[ ]/\\n' ($1)";
            esac
        ;;

        b|build|c|checksum|d|download|i|install|l|list|r|remove)
            for _arg do case ${action%%"${action#?}"}-$_arg in
                i-*\!*|i-*\**|i-*\[*|i-*\ *|i-*\]*|i-*"$newline"*)
                    die "$FUNCNAME" "Invalid argument: '!*[ ]\\n' ('$_arg')"
                    ;;

                [!i]-*\!*|[!i]-*\**|[!i]-*\[*|[!i]-*\ *|\
                [!i]-*\]*|[!i]-*/*|[!i]-*"$newline"*)
                    die "$FUNCNAME" "Might be wrong usage of argument: '!*[ ]/\\n' ('$_arg'). Use a package name, please."
                    ;;
            esac done

            # When no arguments are given on the command-line, use the basename
            # of the current directory as the package name and add the parent
            # directory to the running process' KISS_PATH.
            case ${action%%"${action#?}"}-$# in [!l]-0)
                export KISS_PATH=${PWD%/*}:$KISS_PATH
                set -- "${PWD##*/}"
            esac

            # Search the installed database first when removing packages. Dependency
            # files may differ when repositories change. Removal is not dependent on
            # the state of the repository.
            case $action in r|remove)
                export KISS_PATH=$sys_db:$KISS_PATH
            esac

            # Order the argument list based on dependence.
            IFS=$'\3' read -r order redro < <(pkg_order "$@") > /dev/null || die "$FUNCNAME" 'pkg_order' "failed on $LINENO"
            for pkg_name in $order; do
                pkg_dirs "$action" "$pkg_name"
            done
            # Intentional, globbing disabled.
            # shellcheck disable=2046,2086
            set -- $order
    esac

    # Need to increment _KISS_LVL here to ensure we don't wipe the cache
    # early by non-asroot invocations.
    export _KISS_LVL=$((_KISS_LVL + 1))

    # Rerun the script as root with a fixed environment if needed. We sadly
    # can't run singular functions as root so this is needed.
    #
    # Intended behavior.
    # shellcheck disable=2030,2031

    log "$FUNCNAME" '$KISS_FORCE' "$KISS_FORCE"
    case $action in a|alternatives|i|install|r|remove)
        [ -n "${kiss_root_user:+x}" ] ||
        IFS=$'\3' read -r  kiss_root_user _ \
            < <(am_owner "$KISS_ROOT/") > /dev/null ||
            die "$FUNCNAME" 'am_owner' "failed on $LINENO"

        null "$action" || equ "$LOGNAME" "$kiss_root_user" || {
            subshell_action_all "$action" "$@"
            return
        }
    esac

    # Clear temporary files

    # This will cancell the process on busybox 1.35.0-2, when test variables has definition
    # and set -e
    # [ -z "$KISS_DEBUG" ] || log "$FUNCNAME" '$KISS_DEBUG' "$KISS_DEBUG"
    # null "$KISS_DEBUG" || log "$FUNCNAME" '$KISS_DEBUG' "$KISS_DEBUG"
    # This will recover the process
    # [ -z "$KISS_DEBUG" ] || { :; log "$FUNCNAME" '$KISS_DEBUG' "$KISS_DEBUG"; }
    [ -z ${KISS_DEBUG+x} ] || log "$FUNCNAME" '$KISS_DEBUG' "$KISS_DEBUG"

    # Actions can be abbreviated to their first letter. This saves keystrokes
    # once you memorize the commands.
    case $action in
        a|alternatives) pkg_alternatives "$@" ;;
        b|build)        pkg_build_all "$@" ;;
        c|checksum)     for pkg_name do pkg_checksum "$pkg_name"; done ;;
        d|download)     for pkg_name do pkg_download "$pkg_name"; done ;;
        H|help-ext)     pkg_help_ext "$@" ;;
        i|install)      for pkg_url do pkg_install "$pkg_url"; done ;;
        l|list)         pkg_list_version "$FUNCNAME" "$@" ;;
        p|pick)         pkg_pick_up "$1" "$2" ;;
        r|remove)       for pkg_name in $redro; do pkg_remove "$pkg_name"; done ;;
        s|search)       for pkg_name do for item in $(delegate -- "pkg_find" "$pkg_name" all -d); do log "$FUNCNAME" "$pkg_name" "$item"; done; done ;;
        u|update)       pkg_update ;;
        U|upgrade)      pkg_upgrade ;;
        v|version)      version_installed $1 ;;
        '')
            log "$FUNCNAME" 'kiss [a|b|c|d|i|l|r|s|u|U|v] [pkg]...'
            log "$FUNCNAME" 'alternatives List and swap alternatives'
            log "$FUNCNAME" 'build'    'Build packages'
            log "$FUNCNAME" 'checksum' 'Generate checksums'
            log "$FUNCNAME" 'download' 'Download sources'
            log "$FUNCNAME" 'install'  'Install packages'
            log "$FUNCNAME" 'list'     'List installed packages'
            log "$FUNCNAME" 'pick'     'Query and pick up a package'
            log "$FUNCNAME" 'remove'   'Remove packages'
            log "$FUNCNAME" 'search'   'Search for packages'
            log "$FUNCNAME" 'update'   'Update the system and repositories'
            log "$FUNCNAME" 'upgrade'  'Update the system'
            log "$FUNCNAME" 'version'  'Package version'

            log "$FUNCNAME" '\nRun "kiss [H|help-ext]" to see all actions\n'
            ;;

        *)
            # _KISS_LVL must be reset here so the that any extensions
            # which call the package manager do not increment the value
            # further than the parent instance.
            debug "$FUNCNAME" '$#' "$#"
            debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
            debug "$FUNCNAME" '$2-$#' "$2-$#"

            local kiss_action="$(delegate -- "pkg_find" "kiss-$action*" "" -x "$PATH")"
            hint "$FUNCNAME" '$kiss_action' "$kiss_action"
            ok "$kiss_action" || die "$FUNCNAME" '$kiss_action' "$kiss_action"

            debug "$FUNCNAME" '$sys_db'      "$sys_db"
            debug "$FUNCNAME" '$kiss_action' "$kiss_action"


            _KISS_LVL=0 "$kiss_action" "$@"
    esac
}

# Need a nicer way of detecting architecture
determine_arch(){
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    local _arch="$($cmd_elf -a -W $1 | grep 'Machine:')"
    local _endian="$($cmd_elf -a -W $1 | grep 'Data:')"

    case "$_arch $_endian" in
        *AArch64*little*)   arch="aarch64-linux-musl";;
        *AArch64*big*)      arch="aarch64_be-linux-musl";;
        *ARM*)              arch="armv7-linux-musleabihf";;
        *Intel*80386*)      arch="i686-linux-musl";;
        *PowerPC64*little*) arch="powerpc64le-linux-musl";;
        *PowerPC64*big*)    arch="powerpc64-linux-musl";;
        *PowerPC*little*)   arch="powerpcle-linux-musl";;
        *PowerPC*big*)      arch="powerpc-linux-musl";;
        *X86-64*)           arch="x86_64-linux-musl";;
        *RISC-V*)           arch="riscv64-linux-musl";;
        *) die "$FUNCNAME" "Unknown architecture: $_arch / $_endian";;
    esac

    echo $arch
}

cross_flags() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    export KISS_XBUILD_TRIPLE="$(clang -print-target-triple | sed 's/-unknown//')"
    export KISS_XHOST_TRIPLE="${KISS_XHOST_TRIPLE:-$(determine_arch $KISS_ROOT/usr/bin/bzip2)}"

    set -f
    IFS_ORIGIN=$IFS
    IFS=-

    set -- $KISS_XBUILD_TRIPLE
    export KISS_XBUILD_ARCH=$1
    export KISS_XBUILD_SYS=$2
    export KISS_XBUILD_ABI=$3

    set -- $KISS_XHOST_TRIPLE
    export KISS_XHOST_ARCH=$1
    export KISS_XHOST_SYS=$2
    export KISS_XHOST_ABI=$3

    IFS=$IFS_ORIGIN
    set +f

    # Flags used for pkg-config
    export PKG_CONFIG_PATH=
    export PKG_CONFIG_LIBDIR=${KISS_ROOT}/usr/lib/pkgconfig:${KISS_ROOT}/usr/share/pkgconfig
    export PKG_CONFIG_SYSROOT_DIR=${KISS_ROOT}

    # Don't carry over flags if this is a cross build
    [ -z ${KISS_ROOT:+x} ] || {
        unset CFLAGS
        unset CXXFLAGS
        unset LDFLAGS
    }

    # Allow setting of chroot-specific cflags
    flagfile="$KISS_ROOT/etc/os-buildflags"
    [ ! -f "$flagfile" ] || source $flagfile

    # Set the compiler target architecture
    if [ -z "${KISS_ROOT:+x}" ]; then
        # Local build. Allow user-set CFLAGS as per normal KISS, or override them in /etc/os-buildflags
        export CC="${CC:-clang}"
        export CXX="${CXX:-clang++}"
    else
        # Cross build. CFLAGS will always come from $KISS_ROOT/etc/os-buildflags
        flags="--target=$KISS_XHOST_TRIPLE --sysroot=${KISS_ROOT} -fPIC"
        export   CFLAGS="$flags $CFLAGS"
        export CXXFLAGS="$flags $CXXFLAGS"
        export  LDFLAGS="--sysroot=$KISS_ROOT $LDFLAGS"
        export       CC="clang $CFLAGS"
        export      CXX="clang++ $CXXFLAGS"
    fi
}

repo_setup() {
    debug "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" "$@")"
    # Set variables which help with cross building
    if [ -z "$KISS_BINREPO" ]; then
        cross_flags

        # Bin repo will be "local" for normal builds, for chroot builds
        # it will be the last part of $KISS_ROOT appended with md5sum of
        # the full $KISS_ROOT path. This keeps packages built for different
        # root directories in separate directories.
        local lastbit="${KISS_ROOT##*/}"
        if null "$lastbit"; then
            binrepo="local"
        else
            binrepo="${lastbit}_$(echo "$KISS_ROOT" | md5sum | cut -c1-32)"
        fi
    else
        binrepo="$KISS_BINREPO"
    fi
}


main() {
    # http://mywiki.wooledge.org/BashFAQ/105
    # Globally disable globbing and enable exit-on-error.

    # https://unix.stackexchange.com/questions/151771/getting-wrong-lineno-for-a-trapped-function
    set -efE # -eE # -ef # -exf
    trap 'trace_line "$FUNCNAME" "$LINENO"' ERR

    # Store the original working directory to ensure that relative paths
    # passed by the user on the command-line properly resolve to locations
    # in the filesystem.
    ppwd=$PWD
    kiss_path_repo_main=$KISS_PATH

    # Store the date and time of script invocation to be used as the name of
    # the log files the package manager creates during builds.
    time=$(date +%Y-%m-%d-%H:%M)

    # Never know when you're gonna need one of these.
    newline="
"
    cr="\n"

    # Color can be disabled via the environment variable KISS_COLOR. Colors are
    # also automatically disabled if output is being used in a pipe/redirection.
    equ "$KISS_COLOR" 0 || { :; ! [ -t 2 ]; } || { :
        if [ -z "${KISS_ROOT:+x}" ]; then
            c1='\033[1;100m'
            c2='\033[1;32m'
            c3='\033[m'
        else
            c1='\033[1;41m'
            c2='\033[1;32m'
            c3='\033[m'
        fi
    }


    # Defaults for environment variables.
    : "${KISS_COMPRESS:=gz}"
    : "${KISS_PID:=$$}"
    : "${LOGNAME:?POSIX requires LOGNAME be set}"


    # Figure out which 'sudo' command to use based on the user's choice or what
    # is available on the system.
    cmd_su=${KISS_SU:-"$(
        command -v /usr/bin/ssu  ||
        command -v /usr/bin/doas ||
        command -v /usr/bin/sudo ||
        command -v /usr/bin/su
    )"} || cmd_su=/usr/bin/su

    # Figure out which utility is available to dump elf information.
    cmd_elf=${KISS_ELF:-"$(
        command -v /usr/bin/readelf      ||
        command -v /usr/bin/eu-readelf   ||
        command -v /usr/bin/llvm-readelf
    )"} || cmd_elf=/usr/bin/ldd

    # Figure out which sha256 utility is available.
    cmd_sha=${KISS_CHK:-"$(
        command -v /usr/bin/openssl   ||
        command -v /usr/bin/sha256sum ||
        command -v /usr/bin/sha256    ||
        command -v /usr/bin/shasum    ||
        command -v /usr/bin/digest
    )"} || die "$FUNCNAME" "No sha256 utility found"

    # Figure out which download utility is available.
    cmd_get=${KISS_GET:-"$(
        command -v /usr/bin/aria2c ||
        command -v /usr/bin/axel   ||
        command -v /usr/bin/curl   ||
        command -v /usr/bin/wget   ||
        command -v /usr/bin/wget2
    )"} || die "$FUNCNAME" "No download utility found (aria2c, axel, curl, wget, wget2)"


    init_dirs "$ppwd"
    log "$FUNCNAME" '$@' "$(esceval "$FUNCNAME" $@)"
    log "$FUNCNAME" '$log_dir_original' "$log_dir_original [global]"
    log "$FUNCNAME" '$KISS_ROOT' "$KISS_ROOT"
    log "$FUNCNAME" '$KISS_PID' "$KISS_PID"
    log "$FUNCNAME" '$PPID' "$PPID"

    repo_setup

    # Catch errors and ensure that build files and directories are cleaned
    # up before we die. This occurs on 'Ctrl+C' as well as success and error.
    # trap pkg_clean_all EXIT INT
    # trap_off
    trap_on "$@"

    args "$@"

    trap_off
}

main "$@"

# vi:   set filetype=sh syntax=sh :
# vim:  set filetype=sh syntax=sh :
# nvim: set filetype=sh syntax=sh :
