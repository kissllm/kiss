#!/bin/sh
# shellcheck source=/dev/null
#
# Simple package manager written in POSIX shell for https://kisslinux.org
#
# The MIT License (MIT)
#
# Copyright (c) 2019-2021 Dylan Araps
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# https://stackoverflow.com/questions/12162010/posix-sh-equivalent-for-bash-s-printf-q
esceval() {
    case $# in 0) return 0; esac
    while :
    do
        printf "'"
        printf %s "$1" | sed "s/'/'\\\\''/g"
        shift
        case $# in 0) break; esac
        printf "' "
    done
    printf "'\n"
}

run() {
    local func_name='run'
    # Print the command, then run it.
    printf '%s\n' "$*"
    "$@"
}

occurrences() {
    local func_name='occurrences'
    { [ -z "$1" ] || [ -z "$2" ]; } && die "$func_name" "Wrong parameters for function"
    local s="$1"
    local sub_str="$2"
    count=0
    until
        t=${s#*"$sub_str"}
        [ "$t" = "$s" ]
    do
        count=$((count + 1))
        s=$t
    done
    printf "%s" "$count"
}

standardize() {
    local func_name='standardize'
    local path="$1"
    ok "$path" && {
        local src_length=$(printf "%s" "$path" | wc -m)
        [ "$(expr substr $path 1 2)" = '//' ] && {
            path="$(expr substr $path 2 $((src_length - 1)) )"
        }
        src_length=$(printf "%s" "$path" | wc -m)
        [ "$(expr substr $path $src_length 1)" = '/' ] && {
            path="$(expr substr $path 1 $((src_length - 1)) )"
        }
    }
    [ "$path" != "$1" ] && path="$(standardize "$path")"
    printf "%s" "$path"
}

standardize_exec() {
    local func_name='standardize_exec'
    local path="$1"
    ok "$path" && {
        local src_length=$(printf "%s" "$path" | wc -m)
        [ "$(expr substr $path $src_length 1)" = '*' ] && {
            path="$(expr substr $path 1 $((src_length - 1)) )"
        }
    }
    [ "$path" != "$1" ] && path="$(standardize_exec "$path")"
    printf "%s" "$path"
}

# $1 string
# $2 sub_str
contains() {
    local func_name='contains'
    # Check if a "string list" contains a word.
    case " $1 " in *" $2 "*) return 0; esac; return 1
}

equ() {
    local func_name='equ'
    # Check if a string is equal to enother.
    # This replaces '[ "$var" = str ]' and '[ "$var" != str ]'.
    case $1 in "$2") return 0 ;; *) return 1; esac
}

ok() {
    local func_name='ok'
    # Check if a string is non-null.
    # This replaces '[ "$var" ]', '[ -n "$var" ]'.
    case $1 in '') return 1 ;; *) return 0; esac
}

null() {
    local func_name='null'
    # Check if a string is null.
    # This replaces '[ -z "$var" ]'.
    case $1 in '') return 0 ;; *) return 1; esac
}

check_errs() {
    local func_name='check_errs'
    # Function. Parameter 1 is the return code
    # Para. 2 is text to display on failure.
    if [ "${1}" -ne "0" ]; then
        echo "ERROR # ${1} : ${2}"
        # as a bonus, make our script exit with the right error code.
        exit ${1}
    fi
}

spaces() {
    local func_name='spaces'
    local HEADER_WIDTH=$1
    local length_header=$2
    local index=1
    local white_spaces=
    while [ $index -le $((HEADER_WIDTH - length_header)) ]; do
        white_spaces=" ${white_spaces}"
        let "index = index + 1"
    done
    printf "%s" "${white_spaces}"
}

null "$SCOPE_WIDTH" && SCOPE_WIDTH=24
null "$KEY_WIDTH" && KEY_WIDTH=21
null "$HEADER_WIDTH" && HEADER_WIDTH=$((SCOPE_WIDTH + 1 + KEY_WIDTH + 1 + 1))
# Print key-value parameter pair with consistent format
# Local variables/contents have to be passed by parameter 3
# $1 scope  : function name
# S2 key    : variable name
# $3 value  : contents
out() {
    local func_name='log'
    # null "$HEADER_WIDTH" && HEADER_WIDTH=28
    local scope="$1"
    local key="$2"
    local contents
    local result

    if null "$3"; then
        # $3 is not set at all
        # printf "-z \$3: %s %s %s\n" "$func_name" '$key' "$key" > /dev/stderr
        case "$key" in
            *'$'*)
                # log 'out' 'fucking $2' "$2"
                contents="$(eval echo "$key")"
                ;;
            *)
                contents="$key"
                key=""
                ;;
        esac
    else
        # $3 is empty or something else
        # printf "non -z \$3: %s %s %s\n" "$func_name" '$key' "$key"
        contents="$3"
    fi

    # Using "$scope $key" as a combined header
    local length_scope=$(printf "%s" "$scope" | wc -m)
    if [ $length_scope -lt $SCOPE_WIDTH ]; then
        num_scope=$((SCOPE_WIDTH - length_scope))
        max_scope=$SCOPE_WIDTH
    else
        max_scope=$length_scope
    fi
    local length_key=$(printf "%s" "$key" | wc -m)
    if [ $length_key -lt $KEY_WIDTH ]; then
        num_key=$((KEY_WIDTH - length_key))
        max_key=$KEY_WIDTH
    else
        max_key=$length_key
    fi
    local length_header=$((max_scope + 1 + max_key + 1))
    if [ $length_header -ge $HEADER_WIDTH ]; then
        # refer to HEADER_WIDTH by value
        result="$(printf "%b%s %${num_scope}.0s %b%s%b \n%${HEADER_WIDTH}.0s  %s" \
            "$c1" "$scope" "" "${c3}${key:+$c2}" "$key" "$c3" "" "$contents")"
    else
        # local white_spaces="$(spaces $HEADER_WIDTH $length_header)"
        # printf "%b%s %b%s%b %s %s\n" \
        #     "$c1" "$scope" "${c3}${key:+$c2}" "$key" "$c3" "$white_spaces" "$contents"
        # local num_spaces=$((HEADER_WIDTH - length_header))
        result="$(printf "%b%s %${num_scope}.0s %b%s %${num_key}.0s %b %s" \
            "$c1" "$scope" "" "${c3}${key:+$c2}" "$key" "" "$c3" "$contents")"
    fi
    printf "%s" "$result"
}

log() {
    local func_name='log'
    if null "$3"; then _3=" "; else _3="$3"; fi
    printf "%s\n" "$(out "$1" "$2" "$_3")" > /dev/stderr
}

war() {
    local func_name='war'
    if null "$3"; then _3=" "; else _3="$3"; fi
    # log "${1} WARNING" "$2" "$_3"
    printf "%s\n" "$(out "$1 WARNING" "$2" "$_3")" > /dev/stderr
}

die() {
    local func_name='die'
    if null "$3"; then _3=" "; else _3="$3"; fi
    # log "${1} ERROR" "$2" "$_3"
    printf "%s\n" "$(out "$1 ERROR" "$2" "$_3")" > /dev/stderr
    exit 1
}

debug() {
    local func_name='debug'
    if null "$3"; then _3=" "; else _3="$3"; fi
    # # https://www.shellscript.sh/exitcodes.html
    # # local check_debug=$(set | grep '^KISS_DEBUG=')
    # local check_debug="$(eval echo '$KISS_DEBUG')"
    # check_errs $? "\$check_debug : $check_debug"
    # # log 'debug' "check_debug=$check_debug"
    # if [ "$?" -ne "0" ]; then
    #     echo "Sorry, cannot find KISS_DEBUG in set"
    #     exit 1
    # else
    #     # Will hang up the shell on busybox 1.35.0-2
    #     # ( [ -n "$KISS_DEBUG" ] && \
    #     #         printf "%s\n" "$(out "$1" "$2" "$3")" 2>&1 >> $log_dir/build.log )
    #     [ -z "$KISS_DEBUG" ] || {
    #        [ 0 -ne "$KISS_DEBUG" ]  && \
    #           printf "%s\n" "$(out "$1" "$2" "$_3")" 2>&1 >> $log_dir/build.log
                # export KISS_DEBUG=1
                ok "$KISS_DEBUG" && printf "%s\n" "$(out "$1" "$2" "$_3")" 2>&1 >> $log_dir/build.log
    #     }
    # fi
}

# $1 scope        : function name
# $2 src_address  : source file full path or file name
stack_slot() {
    local func_name='stack_slot'
    local scope="$1"
    log "$func_name" '$scope' "$scope"
    shift 1

    local src_address="$1"
    local src_name="$(printf "%s" "${src_address##*/}")"
    [ "$(expr substr $src_address 1 1)" = '/' ] && {
        local src_length=$(printf "%s" "$src_address" | wc -m)
        src_address="$(expr substr $src_address 2 $((src_length - 1)) )"
    }
    # Create a uniquely named temporary file and store its absolute path
    # in a variable (_stack_top).
    #
    # To prevent subshell usage and to handle cases where multiple files
    # are needed, this saves the last two temporary files to variables
    # for access by the caller (allowing 3 files at once).
    _stack_bottom="$_stack_second"
    _stack_second="$_stack_top"
    _stack_top="$tmp_dir/$src_address"

    log "$func_name" '$_stack_bottom' "$_stack_bottom"
    log "$func_name" '$_stack_second' "$_stack_second"
    log "$func_name" '$_stack_top'    "$_stack_top"

    { [ -n "$_stack_bottom" ] && [ -n "$_stack_second" ]; } \
        && { [ "$_stack_bottom" = "$_stack_second" ] \
            || [ "$_stack_bottom" = "$_stack_top" ] \
            || [ "$_stack_top" = "$_stack_second" ]; } \
        && {
        die "$func_name" "$src_address" "Failed to aquire temporary file"
    }

    local dir_top="$(dirname "$_stack_top")"
    [ ! -d "$dir_top" ] && mkdir -p "$dir_top"

    : > "$_stack_top" || die "$func_name" "$src_address" "Failed to create temporary file"

}

# $1 scope        : function name
# $2 src_address  : source file full path
stack_push() {
    local func_name='stack_push'
    local scope="$1"
    log "$func_name" '$scope' "$scope"
    shift 1

    local src_address="$1"
    local src_name="$(printf "%s" "${src_address##*/}")"

    # Create a uniquely named temporary file and make a duplicate of
    # the file in '$1' if it exists.
    [ -f "$src_address" ] && {
        log "$func_name" '$src_address' "$src_address"
        stack_slot "$func_name" "$src_address"
        cp -f "$src_address" "$_stack_top"
    }
}

prompt() {
    local func_name='prompt'
    null "$1" || log "$func_name" '$1' "$1"

    log "$func_name" "Continue?: Press Enter to continue or Ctrl+C to abort"

    # korn-shell does not exit on interrupt of read.
    equ "$KISS_PROMPT" 0 || read -r _ || exit 1
}

mkcd() {
    local func_name='mkcd'
    local scope="$1"
    log "$func_name" '$scope' "$scope"
    shift 1
    if null "$1"; then
        die "$func_name" "can not create directories"
    else
        log "$func_name" '$@' "$@"
        [ "$(dirname "$1")" != "/" ] && mkdir -p "$@" && cd "$1" || log "$func_name" 'cd' 'trying to cd to /'
    fi
}

replace() {
    local func_name='replace'
    # Replace all occurrences of substrings with substrings. This
    # function takes pairs of arguments iterating two at a time
    # until everything has been replaced.
    _fnr="$1"
    shift 1

    while :; do case $_fnr-$# in
        *"$1"*) _fnr=${_fnr%"$1"*}${2}${_fnr##*"$1"} ;;
           *-2) break ;;
             *) shift 2
    esac done
}

# $1 path
am_owner() {
    local func_name='am_owner'
    # Figure out if we need to change users to operate on
    # a given file or directory.
    local inf="$(ls -ld "$1")" ||
        die "$func_name" "Failed to file information for '$1'"

    log "$func_name" '$inf' "$inf"
    # Split the ls output into fields.
    read -r _ _ user _ <<EOF
$inf
EOF
    log "$func_name" '$user' "$user"
    equ "$LOGNAME/$user" "$user/$LOGNAME"
}

as_user() {
    local func_name='as_user'
    printf 'Using '%s' (to become %s)\n' "$cmd_su" "$user"

    case ${cmd_su##*/} in
        su) "$cmd_su" -c "$* <&3" "$user" 3<&0 </dev/tty ;;
         *) "$cmd_su" -u "$user" -- "$@"
    esac
}

pkg_owner() {
    local func_name='pkg_owner'
    ok "$2" || { set +f; set -f -- "$1" "$sys_db"/*/manifest; }

    _owns=$(grep -lxF "$@")
    _owns=${_owns%/*}
    _owns=${_owns##*/}

    ok "$_owns"
}

resolve_path() {
    local func_name='resolve_path'
    _rpath=$KISS_ROOT/${1#/}
    local _parent
    # Attempt to resolve symlinks by using 'cd'.
    # If this fails, fallback to the file's parent
    # directory.
    if cd -P "${_rpath%/*}" 2>/dev/null; then
        _parent=$PWD
        cd "$OLDPWD"
    else
        _parent=${_rpath%/*}
    fi

    _rpath=${_parent#"$KISS_ROOT"}/${_rpath##*/}
}

run_hook() {
    local func_name='run_hook'
    # Run all hooks in KISS_HOOK (a colon separated
    # list of absolute file paths).
    IFS=:

    for hook in ${KISS_HOOK:-}; do case $hook in *?*)
        "$hook" "$@" || die "$func_name" "$1 hook failed: '$hook'"
    esac done

    unset IFS
}

run_hook_pkg() {
    local func_name='run_hook_pkg'
    # Run a hook from the package's database files.
    if [ -x "$sys_db/$2/$1" ]; then
        log "$func_name" "$2" "Running $1 hook"
        "$sys_db/$2/$1"

    elif [ -f "$sys_db/$2/$1" ]; then
        war "$func_name" "$2" "skipping $1 hook: not executable"
    fi
}

# $1 tar_file : tar file
decompress() {
    local func_name='decompress'
    log "$func_name global" '$tar_file' "$tar_file"
    local tar_file="$1"
    log "$func_name" '$pkg' "$pkg"
    log "$func_name local " '$tar_file' "$tar_file"

    case $tar_file in
        *.tbz|*.bz2) bzip2 -d ;;
        *.lzma)      lzma -dc ;;
        *.lz)        lzip -dc ;;
        *.tar)       cat      ;;
        *.tgz|*.gz)  gzip -d  ;;
        *.xz|*.txz)  xz -dcT0 ;;
        *.zst)       zstd -dc ;;
    esac < "$tar_file"
}

sh256() {
    # Higher level sh256 function which filters out non-existent
    # files (and also directories).
    for f do shift
        [ -d "$f" ] || [ ! -e "$f" ] || set -- "$@" "$f"
    done

    _sh256 "$@"
}

_sh256() {
    local func_name='sh256'
    # There's no standard utility to generate sha256 checksums.
    # This is a simple wrapper around sha256sum, sha256, shasum,
    # openssl, digest, ... which will use whatever is available.
    #
    # All utilities must match 'sha256sum' output.
    #
    # Example: '<checksum>  <file>'
    unset hash

    # Skip generation if no arguments.
    ! equ "$#" 0 || return 0

    # Set the arguments based on found sha256 utility.
    case ${cmd_sha##*/} in
        openssl) set -- dgst -sha256 -r "$@" ;;
         sha256) set -- -r "$@" ;;
         shasum) set -- -a 256 "$@" ;;
         digest) set -- -a sha256 "$@" ;;
    esac

    IFS=$newline

    # Generate checksums for all input files. This is a single
    # call to the utility rather than one per file.
    local _hash=$("$cmd_sha" "$@") || die "$func_name" "Failed to generate checksums"

    # Strip the filename from each element.
    # '<checksum> ?<file>' -> '<checksum>'
    for sum in $_hash; do
        hash=$hash${hash:+"$newline"}${sum%% *}
    done

    printf '%s\n' "$hash"
    unset IFS
}

# $1 scope
# $2 pkg
# $3
# $4
pkg_find_version() {
    local func_name='pkg_find_version'
    local scope="$1"
    log "$func_name" '$scope' "$scope"
    esceval "$@"
    shift 1
    local pkg="$1"
    log "$func_name" '$pkg' "$pkg"

    case "$repo_dir" in
        *"${REPO_MAIN}"*)
            sed -i 's:#!/bin/sh -e:#!/usr/bin/env sh:g' "$repo_dir/build"
            ;;
        *) :;;
    esac

    ver_pre=$repo_ver
    rel_pre=$repo_rel

    pkg_find "$pkg" "$@"

    read -r repo_ver repo_rel 2>/dev/null < "$repo_dir/version" ||
        die "$func_name" "$pkg" "Failed to read version file ($repo_dir/version)"

    ok "$repo_rel" ||
        die "$func_name" "$pkg" "Release field not found in version file"

    # This belongs somewhere else, for now it can live here.
    [ -x "$repo_dir/build" ] ||
        die "$func_name" "$pkg" "Build file not found or not executable"

    debug "$func_name" '$ver_pre'  "$ver_pre"
    debug "$func_name" '$rel_pre'  "$rel_pre"
    debug "$func_name" '$repo_ver' "$repo_ver"
    debug "$func_name" '$repo_rel' "$repo_rel"
}

pkg_find_version_split() {
    local func_name='pkg_find_version_split'
    pkg_find_version "$func_name" "$@"

    # Split the version on '.+-_' to obtain individual components.
    IFS=.+-_ read -r repo_major repo_minor repo_patch repo_ident <<EOF
$repo_ver
EOF
}

# $1 pkg
# $2 option
pkg_find() {
    local func_name='pkg_find'
    log "$func_name" 'enter'
    log "$func_name" '$#' "$#"
    esceval "$@"
    local pkg="$1"
    _pkg_find "$@" || die "$func_name" "'$pkg' not found"
}

_pkg_find() {
    local func_name='_pkg_find'
    log "$func_name" 'enter'
    log "$func_name" '$#' "$#"
    # log "$func_name" '$@' "$@"
    esceval "$@"
    log "$func_name global" '$pkg' "$pkg"
    local pkg="$1"
    log "$func_name local " '$pkg' "$pkg"
    shift 1
    local pkg_name="$1"
    log "$func_name local " '$pkg_name' "$pkg_name"
    # Figure out which repository a package belongs to by searching for
    # directories matching the package name in $KISS_PATH/*.
    set -- "$1" "$2" "$3" "${4:-"$KISS_PATH"}"
    IFS=:

    log "$func_name" 'set -- '
    esceval "$@"

    local repo_search=
    pkg_name="$(standardize_exec "$pkg_name")"
    case "$4" in *"$pkg_name"*)
        ;;
        *)
            local found="$(which "$pkg_name")"
            if null "$found"; then
                path_lines=$(echo "$4" | sed "s/:/\n/g")

                while IFS= read -r path; do
                    [ -d "$path" ] && {
                        log "$func_name" 'searching $path' "$path"
                        local found="$(find "$path" -name "$pkg_name" | tr "\n" " ")"
                        ok "$found" && {
                            log "$func_name" '$found' "$found"
                            if ok "$repo_search"; then
                                repo_search="$found $repo_search"
                            else
                                repo_search="$found"
                            fi
                            break
                        }
                    }
                done <<EOF
$path_lines
EOF
            else
                repo_search="$found"
            fi
    esac

    # log "$func_name" '$#' "$#"
    log "$func_name" '$sys_db' "$sys_db"
    log "$func_name" '$repo_search' "$repo_search"
    # Iterate over KISS_PATH, grabbing all directories which match the query.
    # Intentional.
    # shellcheck disable=2086
    for _find_path in "$repo_search" "${3:-$sys_db}"; do
        log "$func_name" '$pkg' "$pkg"
        log "$func_name" '$pkg_name' "$pkg_name"
        ok "$_find_path" && {
            _find_path="$(standardize "$_find_path")"
            if [ "$_find_path" = "$sys_db" ]; then
                local pkg_basename="${pkg_name##*/}"
                if [ "${pkg_basename}" != "$pkg" ] && ok "${pkg_basename}"; then
                    _find_path="$(find "$sys_db" -type d -name "${pkg_basename}")"
                else
                    _find_path="$sys_db/$pkg"
                fi
            fi
            log "$func_name" '$_find_path' "$_find_path"
        }
        ok "${pkg_name##*/}" && {
            set +f
            for _find_pkg in "$_find_path" "$([ -f "$pkg_name" ] && printf "%s" "$1")"; do
                ok "$_find_pkg" && {
                    log "$func_name" '$1' "$1"
                    log "$func_name" '$pkg_name' "$pkg_name"
                    log "$func_name" '$_find_pkg' "$_find_pkg"
                    test "${3:--d}" "$_find_pkg" && set -f -- "$@" "$_find_pkg"
                }
            done
        }
    done

    unset IFS

    # log "$func_name" '$#' "$#"
    # log "$func_name" '$@' "$@"
    log "$func_name" 'serach done'
    esceval "$@"
    log "$func_name" '$2-$#' "$2-$#"

    # log "$func_name" '$repo_dir' "$repo_dir"

    # Figure out which repository a package belongs to by searching for
    # Show all search results if called from 'kiss search', else store the
    # values in variables. If there are 4 arguments, no package has been found.
    case $2-$# in
        *-4) return 1 ;;
        -*) repo_dir="$5"
            repo_name="${5##*/}"
            repo_dir="$(standardize "$repo_dir")"
            log "$func_name" '$repo_dir' "$repo_dir"
            ;;
        *) shift 4; printf '%s\n' "$@"
    esac
}

pkg_list_version() {
    local func_name='pkg_list_version'
    local scope="$1"
    log "$func_name" '$scope' "$scope"
    shift 1
    debug "$func_name" '$#' "$#"

    # List installed packages. As the format is files and directories, this
    # just involves a simple for loop and file read.

    log "$func_name" '$sys_db' "$sys_db"

    # Optional arguments can be passed to check for specific packages. If no
    # arguments are passed, list all.
    ok "$1" || { set +f; set -f -- "$sys_db"/*; }

    # Loop over each package and print its name and version.
    for _pkg do
        debug "$func_name" '$_pkg'       "$_pkg"
        debug "$func_name" '${_pkg##*/}' "${_pkg##*/}"
        pkg_find_version "$func_name" "${_pkg##*/}" "" "" "$sys_db"
        [ "$?" -ne "0" ] && log "$func_name" 'pkg_find_version' "Failed"
        log "$func_name" "$repo_name $repo_ver-$repo_rel"
    done
}

# could be subshell function before local version
# $1 pkg : package name
pkg_cache() {
    local func_name='pkg_cache'
    local pkg="$1"
    null "$2" || debug "$func_name" '$2' "$2"
    debug "$func_name" '$bin_dir'

    # Find the tarball of a package using a glob. Use the user's set compression
    # method if found or first match of the below glob.
    pkg_find_version "$func_name" "$pkg"

    set +f -- "${bin_dir}/${1}@${repo_ver}-${repo_rel}.tar."
    set -f -- "${1}$KISS_COMPRESS" "${1}"*

    local tar_file=""

    # If the first match does not exist, use the second. If neither exist,
    # this function returns 1 and the caller handles the error.
    if [ -f "$1" ]; then
        tar_file="$1"
    elif [ -f "$2" ]; then
        tar_file="$2"
    else
        die "$func_name" '$tar_file not found' "$tar_file"
    fi

    debug "$func_name" '$1'        "$1"
    debug "$func_name" '$2'        "$2"
    debug "$func_name" '$tar_file' "$tar_file"

    printf "%s" "$tar_file"
}

# $1 pkg_name / repo_name  : package name
# $2 src                   : source link
# $3 dest                  : destination / source folder name
# $4 operation
pkg_source_resolve() {
    local func_name='pkg_source_resolve'
    local pkg_name="$1"
    local src="$2"
    local dest="$3"
    local operation="$4"
    # Given a line of input from the sources file, return an absolute
    # path to the source if it already exists, error if not.
    unset _res _des _fnr

    ok "${2##\#*}" || return 0

    # Surround each replacement with substitutions to handled escaped markers.
    # First substitution turns '\MARKER' into ' ' (can't appear in sources as
    # they're already split on whitespace), second replaces 'MARKER' with its
    # value and the third, turns ' ' into 'MARKER' (dropping \\).
    replace "${2%"${2##*[!/]}"}" \
        \\VERSION \  VERSION "$repo_ver"   \  VERSION \
        \\RELEASE \  RELEASE "$repo_rel"   \  RELEASE \
        \\MAJOR   \  MAJOR   "$repo_major" \  MAJOR \
        \\MINOR   \  MINOR   "$repo_minor" \  MINOR \
        \\PATCH   \  PATCH   "$repo_patch" \  PATCH \
        \\IDENT   \  IDENT   "$repo_ident" \  IDENT \
        \\PACKAGE \  PACKAGE "$repo_name"  \  PACKAGE

    set -- "$1" "$_fnr" "${3%"${3##*[!/]}"}" "$4"

    # Git repository.
    if null "${2##git+*}"; then
        _res=$2
        _des=$src_dir/$1/${3:+"$3/"}${2##*/}
        _des=${_des%[@#]*}/

    # Remote source (cached).
    elif [ -f "$src_dir/$1/${3:+"$3/"}${2##*/}" ]; then
        _res=$src_dir/$1/${3:+"$3/"}${2##*/}

    # Remote source.
    elif null "${2##*://*}"; then
        _res=url+$2
        _des=$src_dir/$1/${3:+"$3/"}${2##*/}

    # Local relative dir.
    elif [ -d "$repo_dir/$2" ]; then
        _res=$repo_dir/$2/.

    # Local absolute dir.
    elif [ -d "/${2##/}" ]; then
        _res=/${2##/}/.

    # Local relative file.
    elif [ -f "$repo_dir/$2" ]; then
        _res=$repo_dir/$2

    # Local absolute file.
    elif [ -f "/${2##/}" ]; then
        _res=/${2##/}

    else
        die "$func_name" "$1" "No local file '$2'"
    fi

    # log "$func_name" '$src_dir'  "$src_dir"
    log "$func_name" '$_res'      "$_res"
    log "$func_name" '$_des'      "$_des"
    log "$func_name" '$tar_file'  "$tar_file"
    log "$func_name" '$operation' "$operation"

    ok "$operation" || printf 'found %s\n' "$_res"
}

# $1 pkg_name   : package name
# $2 operation  : operation name
pkg_source() {
    local func_name='pkg_source'
    local pkg_name="$1"
    local operation="$2"
    log "$func_name" '$pkg_name'  "$pkg_name"
    log "$func_name" '$operation' "$operation"
    # Download any remote package sources. The existence of local files is
    # also checked.
    pkg_find_version_split "$pkg_name"

    # Support packages without sources. Simply do nothing.
    [ -f "$repo_dir/sources" ] || return 0

    log "$func_name" "$pkg_name" "Reading sources"
    log "$func_name" '$repo_dir'

    while read -r src dest || ok "$src"; do
        log "$func_name" '$src'  "$src"
        log "$func_name" '$dest' "$dest"
        pkg_source_resolve "$pkg_name" "$src" "$dest" "$operation"

        # arg1: pre-source
        # arg2: package name
        # arg3: verbatim source
        # arg4: resolved source
        run_hook pre-source "$pkg_name" "$src" "$_fnr"

        # '$2' is set when this function is called from 'kiss c' and it is used
        # here to skip calling the Git code.
        case ${operation}$_res in "${operation}url+"*|git+*)
            log "$func_name" '$_des'  "$_des"
            mkcd "$func_name" "${_des%/*}"
            "pkg_source_${_res%%+*}" "$_des" "${_res##"${_res%%+*}+"}"
        esac

        # arg1: post-source
        # arg2: package name
        # arg3: verbatim source
        # arg4: resolved source
        run_hook post-source "$pkg_name" "$src" "${_des:-"$_res"}"
    done < "$repo_dir/sources"
}

pkg_source_url() {
    local func_name='pkg_source_url'
    log "$func_name" "$repo_name" "Downloading $2"

    # Set the arguments based on found download utility.
    case ${cmd_get##*/} in
        aria2c|axel) set -- -o   "$@" ;;
               curl) set -- -fLo "$@" ;;
         wget|wget2) set -- -O   "$@" ;;
    esac

    "$cmd_get" "$@" || {
        rm -f "$2"
        die "$func_name" "$repo_name" "Failed to download $3"
    }
}

pkg_source_git() {
    local func_name='pkg_source_git'
    local com=${2##*[@#]}
    com=${com#${2%[#@]*}}

    log "$func_name" "$repo_name" "Checking out ${com:-FETCH_HEAD}"

    [ -d .git ] || git init

    url="${2%[#@]*}"
    git remote set-url origin "${url}" 2>/dev/null ||
        git remote add origin "${url}"

    log "$func_name" '$branch' "$com"
    log "$func_name" '$url'    "${url}"
    log "$func_name" '$PWD'    "$PWD"

    ( git fetch --depth 1 "${url}" 2>/dev/null ) ||  git fetch "${url}"
    git reset --hard FETCH_HEAD

    git rev-parse --short HEAD
    git describe --always

    git submodule deinit --all -f
    git submodule init
    git submodule sync
    git submodule update --init --remote --recursive --force
}
# $1 $dest
# $2 $_res
pkg_source_tar() {
    local func_name='pkg_source_tar'
    local dest="$1"
    local _res="$2"

    log "$func_name" '$dest' "$dest"
    log "$func_name" '$_res' "$_res"
    log "$func_name" '$repo_name' "$repo_name"

    # This is a portable shell implementation of GNU tar's
    # '--strip-components 1'. Use of this function denotes a
    # performance penalty.
    stack_slot "$func_name" "$dest/tarball"
    stack_slot "$func_name" "$dest/tarball-manifest"

    log "$func_name" '$_stack_top'    "$_stack_top"
    log "$func_name" '$_stack_second' "$_stack_second"

    decompress "$_res" > "$_stack_second" ||
        die "$func_name" "$repo_name" "Failed to decompress $_res"

    tar xf "$_stack_second" ||
        die "$func_name" "$repo_name" "Failed to extract $_res"

    # The sort command filters out all duplicate top-level
    # directories from the tarball's manifest. This is an optimization
    # as we avoid looping (4000 times for Python(!)).
    tar tf "$_stack_second" | sort -ut / -k1,1 > "$_stack_top" ||
        die "$func_name" "$repo_name" "Failed to extract manifest"

    # Iterate over all directories in the first level of the
    # tarball's manifest. Each directory is moved up a level.
    while IFS=/ read -r dir _; do case ${dir#.} in *?*)
        # Skip entries which aren't directories.
        [ -d "$dir" ] || continue

        # Move the parent directory to prevent naming conflicts
        # with the to-be-moved children.
        mv -f "$dir" "$KISS_PID-$dir"

        # Move all children up a directory level. If the mv command
        # fails, fallback to copying the remainder of the files.
        #
        # We can't use '-exec {} +' with any arguments between
        # the '{}' and '+' as this is not POSIX. We must also
        # use '$0' and '$@' to reference all arguments.
        find "$KISS_PID-$dir/." ! -name . -prune \
            -exec sh -c 'mv -f "$0" "$@" .' {} + 2>/dev/null ||

        find "$KISS_PID-$dir/." ! -name . -prune \
            -exec sh -c 'cp -fRp "$0" "$@" .' {} +

        # Remove the directory now that all files have been
        # transferred out of it. This can't be a simple 'rmdir'
        # as we may leave files in here if any were copied.
        rm -rf "$KISS_PID-$dir"
    esac done < "$_stack_top"

    # Remove the tarball now that we are done with it.
    rm -f "$_stack_second"
}

pkg_extract() {
    local func_name='pkg_extract'
    local pkg_name="$1"
    # Extract all source archives to the build directory and copy over any
    # local repository files.
    #
    # NOTE: repo_dir comes from caller.
    log "$func_name" "$pkg_name" "Extracting sources"

    # arg1: pre-extract
    # arg2: package name
    # arg3: path to DESTDIR
    run_hook pre-extract "$pkg" "$pkg_dir"

    while read -r src dest || ok "$src"; do
        pkg_source_resolve "$pkg_name" "$src" "$dest" >/dev/null

        # Create the source's directories if not null.
        null "$_res" || mkcd "$func_name" "$mak_dir/$dest"

        case $_res in
            git+*)
                rsync -aqz "$_des/." .
            ;;

            *.tar|*.tar.??|*.tar.???|*.tar.????|*.t?z)
                pkg_source_tar "$dest" "$_res"
            ;;

            *?*)
                cp -LRf "$_res" .
            ;;
        esac
    done < "$repo_dir/sources" || die "$func_name" "$pkg_name" "Failed to extract $_res"
}

# $1 dep/pkg : dependence with path
pkg_depends() {
    local func_name='pkg_depends'
    debug "$func_name" '$#' "$#"
    debug "$func_name" '$1' "$1"
    debug "$func_name" '$2' "$2"
    debug "$func_name" '$3' "$3"
    debug "$func_name" '$4' "$4"
    local dep="$1"
    log "$func_name" '$dep'  "$dep"
    # log "$func_name" '$deps' "$deps"

    # Resolve all dependencies and generate an ordered list. The deepest
    # dependencies are listed first and then the parents in reverse order.
    ! contains "$deps" "$dep" || return 0

    # Filter out non-explicit, already installed packages.
    null "$3" || ok "$2" || contains "$explicit" "$dep" ||
        ! [ -d "$sys_db/$dep" ] || return 0

    # Detect circular dependencies and bail out.
    # Looks for multiple repeating patterns of (dep dep_parent) (5 is max).
    case " $4 " in
*" ${4##* } "*" ${dep} "\
*" ${4##* } "*" ${dep} "\
*" ${4##* } "*" ${dep} "\
*" ${4##* } "*" ${dep} "\
*" ${4##* } "*" ${dep} "*)
        die "$func_name" "Circular dependency detected
$dep
<>
${4##* }"
    esac

    local repo_dir
    if { [ -d "$dep" ] || [ -f "$dep" ]; }; then
        repo_dir="$dep"
    elif { [ -d "$sys_db/$dep" ] || [ -f "$sys_db/$dep" ]; }; then
        repo_dir="$sys_db/$dep"
    fi

    if null "$repo_dir"; then
        die "$func_name" '' "\$repo_dir is not defined"
    else
        log "$func_name" '$repo_dir' "$repo_dir"
    fi

    if null "$KISS_ROOT"; then
        log "$func_name" '' "\$KISS_ROOT is not defined"
    else
        log "$func_name" '$KISS_ROOT is defined' "$KISS_ROOT"
    fi

    log "$func_name" '$4' "$4"

    # Packages which exist and have depends.
    ! _pkg_find "$1" || ! [ -e "$repo_dir/depends" ] || {

        # Recurse through the dependencies of the child packages.
        while read -r dep dep_type || { :; ok "$dep"; }; do
            ! ok "${dep##\#*}" || {
                :
                log "$func_name" '$dep' "$dep"
                log "$func_name" '$dep_type' "$dep_type"
                local found_duplicated=0
                for I in $4; do
                    [ "$I" = "$1" ] && {
                        found_duplicated=1
                        break
                    }
                done
                [ $found_duplicated = 0 ] && {
                    null "$KISS_ROOT" && {
                        pkg_depends "$dep" '' "$3" "$4 $1" "$dep_type"
                    }
                    ok "$KISS_ROOT" && null "$dep_type" && {
                        pkg_depends "$dep" '' "$3" "$4 $1" "$dep_type"
                    }
                    ok "$KISS_ROOT" && ok "$dep_type" && {
                        pkg_make_depends "$dep" '' "$3" "$4 $1" "$dep_type"
                    }
                }
            }
        done < "$repo_dir/depends" || :
    }
    # Add parent to dependencies list.
    if ! equ "$2" expl || { equ "$5" make && null "$(pkg_cache "$1" | awk 'BEGIN{ RS = ""; FS = "\n" }{print $NF}')"; }; then
        deps="$deps $1"
    fi

    for item in $deps; do
        debug "$func_name" '$deps' "$item"
    done
}

pkg_make_depends() {
    local func_name='pkg_make_depends'
    local pkg="$1"
    # Only add to list once
    ! contains "$makedeps" "$pkg" || return 0

    # Filter already installed packages on build machine.
    ! [ -d "/var/db/kiss/installed/$pkg" ] || return 0

    # Add to the list
    makedeps="$makedeps $pkg"
}

# "$@" : all packages
pkg_order() {
    local func_name='pkg_order'
    # Order a list of packages based on dependence and take into account
    # pre-built tarballs if this is to be called from 'kiss i'.
    unset order redro deps

    # How to show parameters
    # log "$func_name" '\$@' "$@"

    log "$func_name" '$@' "$@"

    for pkg do case $pkg in
      /*@*.tar.*) deps="$deps $pkg" ;;
       *@*.tar.*) deps="$deps $ppwd/$pkg" ;;
             */*) die "$func_name" "Not a package' ($pkg)" ;;
               *) pkg_depends "$pkg" raw
    esac done

    for item in $deps; do
        debug "$func_name" '$deps' "$item"
    done

    # Filter the list, only keeping explicit packages. The purpose of these
    # two loops is to order the argument list based on dependence.
    for pkg in $deps; do case " $* " in *" $pkg "*|*" ${pkg##"$ppwd/"} "*)
        order="$order $pkg"
        redro="$pkg $redro"
    esac done

    # log "$func_name" '$order' "\"$order\""
    log "$func_name" '$redro' "\"$redro\""
    for element in $redro; do
        pkg="$element"
        ok "$sys_db/$pkg" && repo_dir="$sys_db/$pkg"
        repo_dir="$(standardize "$repo_dir")"
        break
    done
    unset deps
    ok "$pkg" && {
        log "$func_name global" '$pkg'      "$pkg"
        log "$func_name global" '$repo_dir' "$repo_dir"
    }
}

pkg_strip() {
    local func_name='pkg_strip'
    # Strip package binaries and libraries. This saves space on the system as
    # well as on the tarballs we ship for installation.
    [ -f "$mak_dir/nostrip" ] || equ "$KISS_STRIP" 0 && return

    log "$func_name" "$1" "Stripping binaries and libraries"

    # Strip only files matching the below ELF types. This uses 'od' to print
    # the first 18 bytes of the file. This is the location of the ELF header
    # (up to the ELF type) and contains the type information we need.
    #
    # Static libraries (.a) are in reality AR archives which contain ELF
    # objects. We simply read from the same 18 bytes and assume that the AR
    # header equates to an archive containing objects (.o).
    #
    # Example ELF output ('003' is ELF type):
    # 0000000 177   E   L   F 002 001 001  \0  \0  \0  \0  \0  \0  \0  \0  \0
    # 0000020 003  \0
    # 0000022
    #
    # Example AR output (.a):
    # 0000000   !   <   a   r   c   h   >  \n   /
    # 0000020
    # 0000022
    while read -r file; do [ -h "$pkg_dir/$file" ] || case $file in
        # Look only in these locations for files of interest (libraries,
        # programs, etc). This includes all subdirectories. Old behavior
        # would run od on all files (upwards of 4000 for Python).
        */sbin/?*[!/]|*/bin/?*[!/]|*/lib/?*[!/]|\
        */lib??/?*[!/]|*/lib???/?*[!/]|*/lib????/?*[!/])

        case $(od -A o -t c -N 18 "$pkg_dir/$file") in
            # REL (object files (.o), static libraries (.a)).
            *177*E*L*F*0000020\ 001\ *|*\!*\<*a*r*c*h*\>*)
                run strip -g -R .comment -R .note "$pkg_dir/$file"
            ;;

            # EXEC (binaries), DYN (shared libraries).
            # Shared libraries keep global symbols in a separate ELF section
            # called '.dynsym'. '--strip-all/-s' does not touch the dynamic
            # symbol entries which makes this safe to do.
            *177*E*L*F*0000020\ 00[23]\ *)
                run strip -s -R .comment -R .note "$pkg_dir/$file"
            ;;
        esac
    esac done < "$pkg_dir/$pkg_db/$1/manifest" || :
}

# could be subshell function before local version
# $1 repo_name : repository name / package name
pkg_fix_deps() {
    local func_name='pkg_fix_deps'
    local repo_name="$1"
    # Dynamically look for missing runtime dependencies by checking each
    # binary and library with 'ldd'. This catches any extra libraries and or
    # dependencies pulled in by the package's build suite.
    log "$func_name" "$repo_name" "looking for dependencies (using ${cmd_elf##*/})"

    [ "$1" != "$repo_name" ] && log "$func_name" '$1 != $repo_name' "$1 != $repo_name"

    log "$func_name" '$PWD' "$PWD"
    log "$func_name" 'ls -al depends' "$(eval ls -al depends)"
    log "$func_name" "depends before fix" "$(cat depends)"
    log "$func_name" 'before push $_stack_second' "$_stack_second"
    log "$func_name" 'before push $_stack_top' "$_stack_top"

    stack_push "$func_name" "$PWD/depends"
    log "$func_name" 'after push $_stack_second' "$_stack_second"
    log "$func_name" 'after push $_stack_top' "$_stack_top"

    stack_slot "$func_name" "depends-fixed"

    set +f
    set -f -- "$sys_db/"*/manifest

    unset _fdep_seen

    # False positive (not a write).
    # shellcheck disable=2094
    while read -r _file; do [ -h "$_file" ] || case $_file in
        # Look only in these locations for files of interest (libraries,
        # programs, etc). This includes all subdirectories. Old behavior
        # would run ldd on all files (upwards of 4000 for Python).
        */sbin/?*[!/]|*/bin/?*[!/]|*/lib/?*[!/]|\
        */lib??/?*[!/]|*/lib???/?*[!/]|*/lib????/?*[!/])

        log "$func_name" '$_file' "$_file"

        # The readelf mode requires ldd's output to resolve the library
        # path for a given file. If ldd fails, silently skip the file.
        ldd=$(ldd -- "$pkg_dir/$_file" 2>/dev/null) || continue

        # Attempt to get information from readelf. If this fails (or we
        # are in ldd mode), do full ldd mode (which has the downside of
        # listing dependencies of dependencies (and so on)).
        elf=$("$cmd_elf" -d "$pkg_dir/$_file" 2>/dev/null) || elf=$ldd

        # Iterate over the output of readelf or ldd, extract file names,
        # resolve their paths and finally, figure out their owner.
        while read -r lib; do case $lib in *NEEDED*\[*\]|*'=>'*)
            # readelf: 0x0000 (NEEDED) Shared library: [libjson-c.so.5]
            lib=${lib##*\[}
            lib=${lib%%\]*}

            # Resolve library path.
            # ldd: libjson-c.so.5 => /lib/libjson-c.so.5 ...
            case $cmd_elf in
                *readelf) lib=${ldd#*"	$lib => "} ;;
                *)        lib=${lib##*=> } ;;
            esac
            lib=${lib%% *}

            # Skip files owned by libc, libc++ and POSIX.
            case ${lib##*/} in
                ld-*           |\
                lib[cm].so*    |\
                libc++.so*     |\
                libc++abi.so*  |\
                libcrypt.so*   |\
                libdl.so*      |\
                libgcc_s.so*   |\
                libmvec.so*    |\
                libpthread.so* |\
                libresolv.so*  |\
                librt.so*      |\
                libstdc++.so*  |\
                libtrace.so*   |\
                libunwind.so*  |\
                libutil.so*    |\
                libxnet.so*    |\
                ldd)
                    continue
            esac

            # Skip files we have seen before.
            case " $_fdep_seen " in
                *" $lib "*) continue ;;
                *) _fdep_seen="$_fdep_seen $lib"
            esac

            resolve_path "$lib"

            # Skip file if owned by current package
            ! pkg_owner -e "$_rpath" manifest ||
                continue

            ! pkg_owner -e "$_rpath" "$@" ||
                printf '%s\n' "$_owns"

        esac done <<EOF || :
$elf
EOF
    esac done < manifest |

    # Sort the depends file (including the existing depends file) and
    # remove any duplicate entries. This can't take into account comments
    # so they remain rather than being replaced.
    sort -uk1,1 "$_stack_second" - > "$_stack_top"

    # If the depends file was modified, show a diff and replace it.
    ! [ -s "$_stack_top" ] || {
        diff -U 3 "$_stack_second" "$_stack_top" 2>/dev/null || :

        # Replace the existing depends file if one exists, otherwise this
        # just moves the file to its final resting place.
        mv -f "$_stack_top" depends
        log "$func_name" "depends after fix" "$(cat depends)"
        # Generate a new manifest as we may be the creator of the depends
        # file. This could otherwise be implemented by inserting a line
        # at the correct place in the existing manifest.
        pkg_manifest "${PWD##*/}" "$pkg_dir"
    }
}

# could be subshell function before local version
# $1 pkg                : package name
# $2 pkg_dir / tar_dir  : package directory / extracting directory
pkg_manifest() {
    local func_name='pkg_manifest'
    local pkg="$1"
    local pkg_dir="$2"
    # Generate the package's manifest file. This is a list of each file
    # and directory inside the package. The file is used when uninstalling
    # packages, checking for package conflicts and for general debugging.
    log "$func_name" "$pkg" "Generating manifest"

    stack_slot "$func_name" "manifest"

    # Create a list of all files and directories. Append '/' to the end of
    # directories so they can be easily filtered out later. Also filter out
    # all libtool .la files and charset.alias.
    {
        printf '%s\n' "$pkg_dir/$pkg_db/$pkg/manifest"

        ! [ -d "$pkg_dir/etc" ] ||
        printf '%s\n' "$pkg_dir/$pkg_db/$pkg/etcsums"

        find "$pkg_dir" ! -path "$pkg_dir" -type d -exec printf '%s/\n' {} + \
            -o \( ! -type d -a ! -name \*.la -a ! -name charset.alias \) -print

        # Sort the output in reverse. Directories appear after their contents.
    } | sort -ur > "$_stack_top"

    # Remove the prefix from each line.
    while read -r file; do
        printf '%s\n' "${file#"$pkg_dir"}"
    done < "$_stack_top" > "$pkg_dir/$pkg_db/$pkg/manifest"
}

# $1 $_pkg
pkg_manifest_validate() {
    local func_name='pkg_manifest_validate'
    # NOTE: _pkg comes from caller.
    local _pkg="$1"
    log "$func_name" "$_pkg" "Checking if manifest valid"

    debug "$func_name" '$PWD' "$PWD"

    log "$func_name" '$tar_dir' "$tar_dir"
    log "$func_name" '"$pkg_db/$_pkg/manifest"' "$pkg_db/$_pkg/manifest"

    shift 1

    while read -r line; do
        [ -e "$tar_dir$line" ] || [ -h "$tar_dir$line" ] || {
            printf '%s\n' "$line"
            set -- "$@" "$line"
        }
    done < "$pkg_db/$_pkg/manifest"

    for f do
        log "$func_name" '$f' "$f"
        die "$func_name" "$_pkg" "manifest contains $# non-existent files"
    done
}

pkg_manifest_replace() {
    local func_name='pkg_manifest_replace'
    # Replace the matching line in the manifest with the desired replacement.
    # This used to be a 'sed' call which turned out to be a little
    # error-prone in some cases. This new method is a tad slower but ensures
    # we never wipe the file due to a command error.
    stack_slot "$func_name" "manifest-replace-${2##*/}"

    while read -r line; do
        ! equ "$line" "$2" || line=$3

        printf '%s\n' "$line"
    done < "$sys_db/$1/manifest" | sort -r > "$_stack_top"

    mv -f "$_stack_top" "$sys_db/$1/manifest"
}

# $@ :
pkg_etcsums() {
    local func_name='pkg_etcsums'
    # Generate checksums for each configuration file in the package's /etc/
    # directory for use in "smart" handling of these files.
    log "$func_name" "$repo_name" "Generating etcsums"
    log "$func_name" '$@' "$@"

    # Minor optimization - skip packages without /etc/.
    [ -d "$pkg_dir/etc" ] || return 0

    # Create a list of all files in etc but do it in reverse.
    while read -r etc; do case $etc in /etc/*[!/])
        set -- "$pkg_dir/$etc" "$@"
    esac done < manifest

    sh256 "$@" > etcsums
}

# $1 pkg : package name
pkg_tar() {
    local func_name='pkg_tar'
    log "$func_name" 'global $pkg' "$pkg"
    local pkg="$1"
    log "$func_name" 'local $pkg' "$pkg"

    # Create a tarball from the built package's files. This tarball also
    # contains the package's database entry.
    #
    # NOTE: repo_ comes from caller.
    log "$func_name" "$pkg" "Creating tarball"
    # tree "$pkg_dir"

    _tar_file=$bin_dir/$pkg@$repo_ver-$repo_rel.tar.$KISS_COMPRESS
    repofile="repo.index"

    # Use 'cd' to avoid needing tar's '-C' flag which may not be portable
    # across implementations.
    cd "$pkg_dir"

    # Create a tarball from the contents of the built package.
    tar cf - . | case $KISS_COMPRESS in
        bz2)  bzip2 -z ;;
        gz)   gzip -6  ;;
        lzma) lzma -z  ;;
        lz)   lzip -z  ;;
        xz)   xz -zT0  ;;
        zst)  zstd -z  ;;
    esac > "$_tar_file"

    # Remove any instances of this package in the index
    # This will leave only the latest version
    touch $bin_dir/$repofile
    sed -i "/$1@/d" $bin_dir/$repofile

    # Write the checksum to the repo file
    cs=$(_sh256 "$_tar_file")
    echo "$cs  $_tar_fn" >> "$bin_dir/$repofile"
    log "$func_name" "$1" "Updated repo index"

    cd "$OLDPWD"

    log "$func_name" "$pkg" "Successfully created tarball"
    log "$func_name" '$_tar_file'

    # arg1: post-package
    # arg2: package name
    # arg3: path to tarball
    run_hook post-package "$pkg" "$_tar_file"
}

# $@ packages name
pkg_build_all() {
    local func_name='pkg_build_all'
    # Build packages and turn them into packaged tarballs.
    # Order the argument list and filter out duplicates.

    # Mark packages passed on the command-line explicit.
    # Also resolve dependencies for all explicit packages.
    for pkg do
        pkg_depends "$pkg" expl filter
        explicit="$explicit $pkg "
    done

    # If this is an update, don't always build explicitly passsed packages
    # and instead install pre-built binaries if they exist.
    ok "$prefer_cache" || explicit_build=$explicit

    # If cross building, make sure the build machine has the correct deps
    set -- $makedeps
    [ "$#" -gt 0 ] && die "$func_name" "You need the following packages on your build machine: $*"

    set --

    # If an explicit package is a dependency of another explicit package,
    # remove it from the explicit list.
    for pkg in $explicit; do
        contains "$deps" "$pkg" || set -- "$@" "$pkg"
    done
    explicit_cnt=$#
    explicit=$*

    log "$func_name" "" "Building: explicit $*${deps:+, implicit: ${deps## }}"

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    set -- $deps "$@"

    # Ask for confirmation if extra packages need to be built.
    equ "$#" "$explicit_cnt" || prompt

    log "$func_name" "" "Checking for pre-built dependencies"

    # Install any pre-built dependencies if they exist in the binary
    # directory and are up to date.
    for pkg in "$@"; do
        local tar_file="$(pkg_cache "$pkg" | awk 'BEGIN{ RS = ""; FS = "\n" }{print $NF}')"
        if ! contains "$explicit_build" "$pkg" && ok "$tar_file"; then
            log "$func_name" "$pkg" "Found pre-built binary"

            # Intended behavior.
            # shellcheck disable=2030,2031
            (export KISS_FORCE=1; args i "$tar_file")
        else
            set -- "$@" "$pkg"
        fi
        shift
    done

    for pkg do
        tmp_dirs "$pkg" "reset"
        pkg_source "$pkg"
        ! [ -f "$repo_dir/sources" ] || pkg_verify "$repo_dir" "$pkg"
    done

    log "$func_name" '$KISS_ROOT'   "$KISS_ROOT"
    log "$func_name" 'Building on $KISS_XBUILD_TRIPLE'  "$KISS_XBUILD_TRIPLE"
    log "$func_name" 'Building for $KISS_XHOST_TRIPLE'  "$KISS_XHOST_TRIPLE"
    log "$func_name" 'Binary repo $bin_dir'             "$bin_dir"
    log "$func_name" '$CC'          "$CC"
    log "$func_name" '$CXX'         "$CXX"
    log "$func_name" '$CFLAGS'      "$CFLAGS"
    log "$func_name" '$CXXFLAGS'    "$CXXFLAGS"
    log "$func_name" '$LDFLAGS'     "$LDFLAGS"

    # Finally build and create tarballs for all passed packages and
    # dependencies.
    for pkg do
        log "$func_name" "$pkg" "Building package ($((_build_cur+=1))/$#)"

        pkg_find_version_split "$pkg"

        # arg1: queue-status
        # arg2: package name
        # arg3: number in queue
        # arg4: total in queue
        run_hook queue "$pkg" "$_build_cur" "$#"

        ! [ -f "$repo_dir/sources" ] || pkg_extract  "$pkg"

        pkg_build    "$pkg"
        pkg_manifest "$pkg" "$pkg_dir"
        pkg_strip    "$pkg"

        cd "$pkg_dir/$pkg_db/$pkg"

        pkg_fix_deps "$pkg"
        pkg_etcsums
        pkg_tar      "$pkg"

        if equ "${prefer_cache:=0}" 1 || ! contains "$explicit" "$pkg"; then
            log "$func_name" "$pkg" "Needed as a dependency or has an update, installing"

            # Intended behavior.
            # shellcheck disable=2030,2031
            (export KISS_FORCE=1; args i "$pkg")
        fi
    done

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    ! equ "${build_install:=1}" 1 || ! equ "${KISS_PROMPT:=1}" 1 ||
        ! prompt "Install built packages? [$explicit]" || (args i $explicit)
}

# could be subshell function before local version
# $1 pkg_name
pkg_build() {
    local func_name='pkg_build'
    local pkg="$1"
    # Install built packages to a directory under the package name to
    # avoid collisions with other packages.

    log "$func_name" '$pkg_root'
    log "$func_name" '$pkg_dir'
    log "$func_name" '$1'   "$1"
    log "$func_name" '$pkg' "$pkg"
    log "$func_name" '$pkg_db'
    log "$func_name" '$pkg_dir/$pkg_db'

    mkcd "$func_name" "$mak_dir" "$pkg_dir/$pkg_db"

    log "$func_name" "$pkg" "Starting build"

    # arg1: pre-build
    # arg2: package name
    # arg3: path to build directory
    run_hook pre-build "$pkg" "$mak_dir"

    # # Attempt to create the log file early so any permissions errors are caught
    # # before the build starts. 'tee' is run in a pipe and POSIX shell has no
    # # pipe-fail causing confusing behavior when tee fails.
    # : > "$log_dir/build.log"

    meson_build=$(find "$pkg_dir" -type f -name "meson.build")
    [ -n "$meson_build" ] && meson setup --wipe

    if [ -z "${USE_GMAKE}" ]; then
        printf "%s\n" "BSD make used" > /dev/stderr
    else
        printf "%s\n" "GNU make used" > /dev/stderr
        [ "$(readlink "${bin_dir}/gunzip")" != "/usr/bin/pigz"  ] && \ln -sf "/usr/bin/pigz"  "${bin_dir}/gunzip"
        [ "$(readlink "${bin_dir}/make")"   != "/usr/bin/gmake" ] && \ln -sf "/usr/bin/gmake" "${bin_dir}/make"
        export PATH="${bin_dir}:$PATH"
    fi

    # Call the build script, log the output to the terminal and to a file.
    # There's no PIPEFAIL in POSIX shell so we must resort to tricks like kill.
    {
        # Give the script a modified environment. Define toolchain program
        # environment variables assuming a generic environment by default.
        #
        # Define DESTDIR and GOPATH to sane defaults as their use is mandatory
        # in anything using autotools, meson, cmake, etc. Define KISS_ROOT as
        # the sanitized value used internally by the package manager. This is
        # safe to join with other paths.
        AR="${AR:-ar}" \
        CC="${CC:-cc}" \
        CXX="${CXX:-c++}" \
        NM="${NM:-nm}" \
        RANLIB="${RANLIB:-ranlib}" \
        DESTDIR="$pkg_dir" \
        RUSTFLAGS="--remap-path-prefix=$PWD=. $RUSTFLAGS" \
        GOFLAGS="-trimpath -modcacherw $GOFLAGS" \
        GOPATH="$PWD/go" \
        KISS_ROOT="$KISS_ROOT" \
        \
        "$repo_dir/build" "$pkg_dir" "$repo_ver" 2>&1 || {
            log "$func_name" "$pkg" "Build failed"
            log "$func_name" "$pkg" "Log stored to $log_dir/build.log"

            # arg1: build-fail
            # arg2: package name
            # arg3: path to build directory
            (run_hook build-fail "$pkg" "$mak_dir") || :

            # pkg_clean
            kill 0
        }
    } | tee "$log_dir/build.log"

    # # Delete the log file if the build succeeded to prevent the directory
    # # from filling very quickly with useless logs.
    # equ "$KISS_KEEPLOG" 1 || rm -f "$log_dir/build.log"

    # Copy the repository files to the package directory.
    cp -LRf "$repo_dir" "$pkg_dir/$pkg_db/"

    log "$func_name" "$pkg" "Successfully built package"

    # arg1: post-build
    # arg2: package name
    # arg3: path to DESTDIR
    run_hook post-build "$pkg" "$pkg_dir"
}

pkg_checksum() {
    local func_name='pkg_checksum'
    local pkg="$1"

    pkg_source "$pkg" c

    [ -f "$repo_dir/sources" ] || return 0

    pkg_checksum_gen

    if ok "$hash"; then
        printf '%s\n' "$hash" > "$repo_dir/checksums"
        log "$func_name" "$pkg" "Generated checksums"

    else
        log "$func_name" "$pkg" "No sources needing checksums"
    fi
}

# $@ :
pkg_checksum_gen() {
    local func_name='pkg_checksum_gen'
    # Generate checksums for packages.
    #
    # NOTE: repo_ comes from caller.
    while read -r src dest || ok "$src"; do
        pkg_source_resolve "$repo_name" "$src" "$dest" >/dev/null

        case ${_res##git+*} in */*[!.])
            set -- "$@" "$_res"
        esac
    done < "$repo_dir/sources"

    _sh256 "$@"
}

# $1 pkg : package name
pkg_verify() {
    local func_name='pkg_verify'
    local repo_dir="$1"
    local pkg="$2"
    # Verify all package checksums. This is achieved by generating a new set
    # of checksums and then comparing those with the old set.
    #
    # NOTE: repo_dir comes from caller.
    log "$func_name" "$repo_name" "Verifying sources"

    # Generate a new set of checksums to compare against.
    pkg_checksum_gen >/dev/null

    # Intentional, globbing disabled.
    # shellcheck disable=2038,2086
    set -- $hash

    # Check that the first column (separated by whitespace) match in both
    # checksum files. If any part of either file differs, mismatch. Abort.
    null "$1" || while read -r chk _ || ok "$1"; do
        printf '%s\n%s\n' "- ${chk:-missing}" "+ ${1:-no source}"

        equ "$1-${chk:-null}" "$chk-$1" ||
        equ "$1-${chk:-null}" "$1-SKIP" ||
            die "$func_name" "$repo_name" "Checksum mismatch"

        shift "$(($# != 0))"
    done < "$repo_dir/checksums"
}

# $1 _pkg : package name
pkg_conflicts() {
    local func_name='pkg_conflicts'
    # Check to see if a package conflicts with another.
    # _pkg comes from the caller.
    local _pkg="$1"

    log "$func_name" "$_pkg" "Checking for package conflicts"

    stack_slot "$func_name" "manifest-files"
    stack_slot "$func_name" "found-conflicts"

    # Filter the tarball's manifest and select only files. Resolve all
    # symlinks in file paths as well.
    while read -r file; do case $file in *[!/])
        resolve_path "$file"

        printf '%s\n' "$_rpath"
    esac done < "$PWD/$pkg_db/$_pkg/manifest" > "$_stack_second"

    cd "$tar_dir"
    set +f
    set -f "$sys_db"/*/manifest

    # Remove the current package from the manifest list.
    replace " $* " " $sys_db/$_pkg/manifest " " "

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    set -- $_fnr

    # Return here if there is nothing to check conflicts against.
    ! equ "$#" 0 || return 0

    # Store the list of found conflicts in a file as we'll be using the
    # information multiple times. Storing things in the cache dir allows
    # us to be lazy as they'll be automatically removed on script end.
    grep -Fxf "$_stack_second" -- "$@" 2>/dev/null > "$_stack_top" || :

    # Enable alternatives automatically if it is safe to do so.
    # This checks to see that the package that is about to be installed
    # doesn't overwrite anything it shouldn't in '/var/db/kiss/installed'.
    grep -q ":/var/db/kiss/installed/" "$_stack_top" || safe=1

    if ! equ "$KISS_CHOICE" 1 && equ "$safe" 1 && [ -s "$_stack_top" ]; then
        # This is a novel way of offering an "alternatives" system.
        # It is entirely dynamic and all "choices" are created and
        # destroyed on the fly.
        #
        # When a conflict is found between two packages, the file
        # is moved to a directory called "choices" and its name
        # changed to store its parent package and its intended
        # location.
        #
        # The package's manifest is then updated to reflect this
        # new location.
        #
        # The 'kiss alternatives' command parses this directory and
        # offers you the CHOICE of *swapping* entries in this
        # directory for those on the filesystem.
        #
        # The alternatives command does the same thing we do here,
        # it rewrites manifests and moves files around to make
        # this work.
        #
        # Pretty nifty huh?
        while IFS=: read -r _ con; do
            printf '%s\n' "Found conflict $con"

            # Create the "choices" directory inside of the tarball.
            # This directory will store the conflicting file.
            mkdir -p "$PWD/$cho_db"

            # Construct the file name of the "db" entry of the
            # conflicting file. (pkg_name>usr>bin>ls)
            replace "$con" '/' '>'

            # Move the conflicting file to the choices directory
            # and name it according to the format above.
            mv -f "$PWD$con" "$PWD/$cho_db/$_pkg$_fnr" 2>/dev/null || {
                log "$func_name" "File must be in ${con%/*} and not a symlink to it"
                log "$func_name" "This usually occurs when a binary is installed to"
                die "$func_name" "/sbin instead of /usr/bin (example)"
            }
        done < "$_stack_top"

        log "$func_name" "$_pkg" "Converted all conflicts to choices (kiss a)"

        # Rewrite the package's manifest to update its location
        # to its new spot (and name) in the choices directory.
        pkg_manifest "$_pkg" "$tar_dir"

    elif [ -s "$_stack_top" ]; then
        log "$func_name" "Package '$_pkg' conflicts with another package" "!>"
        log "$func_name" "Run 'KISS_CHOICE=1 kiss i $_pkg' to add conflicts" "!>"
        die "$func_name" "as alternatives." "!>"
    fi
}

# $@ :
pkg_alternatives() {
    local func_name='pkg_alternatives'
    if equ "$1" -; then
        while read -r pkg path; do
            pkg_swap "$pkg" "$path"
        done

    elif ok "$1"; then
        pkg_swap "$@"

    else
        # Go over each alternative and format the file
        # name for listing. (pkg_name>usr>bin>ls)
        set +f; for pkg in "$sys_ch/"*; do
            replace "${pkg##*/}" '>' '/'
            printf '%s %s\n' "${_fnr%%/*}" "/${_fnr#*/}"
        done
    fi
}

pkg_swap() {
    local func_name='pkg_swap'
    # Swap between package alternatives.
    [ -d "$sys_db/$1" ] || die "$func_name" "'$1' not found"

    replace "$1$2" '/' '>'

    [ -f "$sys_ch/$_fnr" ] || [ -h "$sys_ch/$_fnr" ] ||
        die "$func_name" "" "Alternative '$1 ${2:-null}' doesn't exist"

    if [ -f "$KISS_ROOT$2" ]; then
        pkg_owner "/${2#/}" ||
            die "$func_name" "" "File '$2' exists on filesystem but isn't owned"

        log "$func_name" "Swapping '$2' from '$_owns' to '$1'"

        # Convert the current owner to an alternative and rewrite its manifest
        # file to reflect this.
        cp -Pf "$KISS_ROOT$2" "$sys_ch/$_owns>${_fnr#*>}"
        pkg_manifest_replace "$_owns" "$2" "/$cho_db/$_owns>${_fnr#*>}"
    fi

    # Convert the desired alternative to a real file and rewrite the manifest
    # file to reflect this. The reverse of above.
    mv -f "$sys_ch/$_fnr" "$KISS_ROOT/$2"
    pkg_manifest_replace "$1" "/$cho_db/$_fnr" "$2"
}

file_rwx() {
    local func_name='file_rwx'
    # Convert the output of 'ls' (rwxrwx---) to octal. This is simply
    # a 1-9 loop with the second digit being the value of the field.
    #
    # NOTE: This drops setgid/setuid permissions and does not include
    # them in the conversion. This is intentional.
    unset oct o

    rwx=$(ls -ld "$1")

    for c in 14 22 31 44 52 61 74 82 91; do
        rwx=${rwx#?}

        case $rwx in
            [rwx]*) o=$((o + ${c#?})) ;;
             [st]*) o=$((o + 1)) ;;
        esac

        case $((${c%?} % 3)) in 0)
            oct=$oct$o
            o=0
        esac
    done
}

pkg_install_files() {
    local func_name='pkg_install_files'
    # Copy files and create directories (preserving permissions).
    # The 'test $1' will run with '-z' for overwrite and '-e' for verify.
    while { read -r file && _file=$KISS_ROOT$file; } do case $file in
        */)
            # Skip directories if they already exist in the file system.
            # (Think /usr/bin, /usr/lib, etc).
            [ -d "$_file" ] || {
                file_rwx "$2/${file#/}"
                mkdir -m "$oct" "$_file"
            }
        ;;

        *)
            # Skip directories and files which exist in verify mode.
            [ -d "$_file" ] || ! test "$1" "$_file" ||
                continue

            case $file in /etc/*[!/])
                # Handle /etc/ files in a special way (via a 3-way checksum) to
                # determine how these files should be installed. Do we overwrite
                # the existing file? Do we install it as $file.new to avoid
                # deleting user configuration? etc.
                #
                # This is more or less similar to Arch Linux's Pacman with the
                # user manually handling the .new files when and if they appear.
                pkg_etc || continue
            esac

            if [ -h "$_file" ]; then
                # Copy the file to the destination directory overwriting
                # any existing file.
                cp -fP "$2$file" "${_file%/*}/."

            else
                # Construct a temporary filename which is a) unique and
                # b) identifiable as related to the package manager.
                local __tmp=${_file%/*}/__kiss-tmp-$_pkg-${file##*/}-$KISS_PID

                # Copy the file to the destination directory with the
                # temporary name created above.
                cp -fP "$2$file" "$__tmp" &&

                # Atomically move the temporary file to its final
                # destination. The running processes will either get
                # the old file or the new one.
                mv -f "$__tmp" "$_file"
            fi
    esac || return 1; done
}

pkg_remove_files() {
    local func_name='pkg_remove_files'
    # Remove a file list from the system. This function runs during package
    # installation and package removal. Combining the removals in these two
    # functions allows us to stop duplicating code.
    while read -r file; do
        case $file in /etc/?*[!/])
            sh256 "$KISS_ROOT/$file" >/dev/null

            read -r sum_pkg <&3 ||:

            equ "$hash" "$sum_pkg" || {
                printf 'Skipping %s (modified)\n' "$file"
                continue
            }
        esac

        local _file=${KISS_ROOT:+"$KISS_ROOT/"}${file%%/}

        # Queue all directory symlinks for later removal.
        if [ -h "$_file" ] && [ -d "$_file" ]; then
            case $file in /*/*/)
                set -- "$@" "$_file"
            esac

        # Remove empty directories.
        elif [ -d "$_file" ]; then
            rmdir "$_file" 2>/dev/null || :

        # Remove everything else.
        else
            rm -f "$_file"
        fi
    done

    # Remove all broken directory symlinks.
    for sym do
        [ -e "$sym" ] || rm -f "$sym"
    done
}

pkg_etc() {
    local func_name='pkg_etc'
    sh256 "$tar_dir/$file" "$KISS_ROOT$file" >/dev/null

    local sum_new=${hash%%"$newline"*}
    local sum_sys=${hash#*"$newline"}

    read -r sum_old <&3 2>/dev/null ||:

    # Compare the three checksums to determine what to do.
    case ${sum_old:-null}${sum_sys:-null}${sum_new} in
        # old = Y, sys = X, new = Y
        "${sum_new}${sum_sys}${sum_old}")
            return 1
        ;;

        # old = X, sys = X, new = X
        # old = X, sys = Y, new = Y
        # old = X, sys = X, new = Y
        "${sum_old}${sum_old}${sum_old}"|\
        "${sum_old:-null}${sum_sys}${sum_sys}"|\
        "${sum_sys}${sum_old}"*)

        ;;

        # All other cases.
        *)
            war "$func_name" "$_pkg" "saving $file as $file.new"
            _file=$_file.new
        ;;
    esac
}

pkg_removable() {
    local func_name='pkg_removable'
    # Check if a package is removable and die if it is not.
    # A package is removable when it has no dependents.
    log "$func_name" "$pkg" "Checking if package removable"

    cd "$sys_db"
    set +f

    local pkg="$1"

    ! grep -lFx -- "$pkg" */depends ||
        die "$func_name" "$pkg" "Not removable, has dependents"

    set -f
    cd "$OLDPWD"
}

# $1 pkg : package name
# could be subshell function before local version
pkg_remove() {
    local func_name='pkg_remove'
    local pkg="$1"
    # Remove a package and all of its files. The '/etc' directory is handled
    # differently and configuration files are *not* overwritten.
    [ -d "$sys_db/$pkg" ] || die "$func_name" "'$pkg' not installed"

    # Intended behavior.
    # shellcheck disable=2030,2031
    equ "$KISS_FORCE" 1 || pkg_removable "$pkg"

    # Block being able to abort the script with 'Ctrl+C' during removal.
    # Removes all risk of the user aborting a package removal leaving an
    # incomplete package installed.
    trap '' INT

    # arg1: pre-remove
    # arg2: package name
    # arg3: path to installed database
    run_hook_pkg pre-remove "$pkg"
    run_hook     pre-remove "$pkg" "$sys_db/$pkg"

    log "$func_name" 'fucking $pkg' "$pkg"
    # Make a backup of any etcsums if they exist.
    stack_push "$func_name" "$sys_db/$pkg/etcsums"

    log "$func_name" "$pkg" "Removing package"
    [ -f "$sys_db/$pkg/manifest" ] && pkg_remove_files < "$sys_db/$pkg/manifest" 3< "$_stack_top"

    # Reset 'trap' to its original value. Removal is done so
    # we no longer need to block 'Ctrl+C'.
    trap pkg_clean EXIT INT

    log "$func_name" "$pkg" "Removed successfully"
}

# could be subshell function before local version
# $1 pkg      : package name
# $2 depends  : depends file address
# $3 missing  : missing package(s)
pkg_installable() {
    local func_name='pkg_installable'
    local pkg="$1"
    local depents="$2"
    local missing="$3"
    # Check if a package is removable and die if it is not.
    # A package is removable when all of its dependencies
    # are satisfied.
    log "$func_name" "$pkg" "Checking if package installable"

    log "$func_name" '$PWD'     "$PWD"
    log "$func_name" '$pkg'     "$pkg"
    log "$func_name" '$depents' "$depents"

    null "$missing" || log "$func_name" '$missing' "$missing"

    # False positive.
    # shellcheck disable=2094
    ! [ -f "$depents" ] ||

    while read -r dep dep_type || ok "$dep"; do
        debug "$func_name" '$dep'    "$dep"
        debug "$func_name" '$sys_db' "$sys_db"
        case "$dep $dep_type" in [!\#]?*\ )
            [ ! -d "$sys_db/$dep" ] && log "$func_name" 'Can not find $dep' "$dep"
            [ ! -d "$sys_db/$dep" ] || continue

            debug "$func_name" '$dep'      "$dep"
            war   "$func_name" '$dep'      "$dep"
            debug "$func_name" '$dep_type' "$dep_type"
            war   "$func_name" '$dep_type' "$dep_type"
            missing=$(($missing + 1))
            set -- "$pkg" "$depents" "$missing"
            # set -- "$1" "$2" "$(($3 + 1))"
        esac
    done < "$depents"
    null "$missing" || log "$func_name" '$missing' "$missing"
    # log "$func_name" '$3' "$3"
    case ${missing:-0} in [1-9]*)
        die "$func_name" "$pkg" "Package not installable, missing $missing package(s)"
    esac
}

# $1 pkg : package name
pkg_install() {
    local func_name='pkg_install'
    local pkg="$1"
    log "$func_name" '$pkg' "$pkg"
    # Install a built package tarball.
    #
    # Package installation works similarly to the method used by Slackware in
    # some of their tooling. It's not the obvious solution to the problem,
    # however it is the best solution at this given time.
    #
    # When an installation is an update to an existing package, instead of
    # removing the old version first we do something different.
    #
    # The new version is installed overwriting any files which it has in
    # common with the previously installed version of the package.
    #
    # A "diff" is then generated between the old and new versions and contains
    # any files existing in the old version but not the new version.
    #
    # The package manager then goes and removes these files which leaves us
    # with the new package version in the file system and all traces of the
    # old version gone.
    #
    # For good measure the package manager will then install the new package
    # an additional time. This is to ensure that the above diff didn't contain
    # anything incorrect.
    #
    # This is the better method as it is "seamless". An update to busybox won't
    # create a window in which there is no access to all of its utilities.
    (
        local tar_file
        local _pkg
        # Install can also take the full path to a tarball. We don't need to check
        # the repository if this is the case.
        case $pkg in
            *.tar.*)
                log "$func_name" 'tar $pkg'

                [ -f "$pkg" ] || die "$func_name" "File '$pkg' does not exist"

                tar_file="$pkg"
                _pkg="${pkg##*/}"
                _pkg="${_pkg%@*}"
                log "$func_name" '$_pkg' "$_pkg"
                log "$func_name local" '$tar_file' "$tar_file"
                ;;

            *)
                log "$func_name" 'non tar $pkg' "$pkg"

                tar_file="$(pkg_cache "$pkg" | awk 'BEGIN{ RS = ""; FS = "\n" }{print $NF}')" || die "$func_name" "$pkg" "Not yet built"
                _pkg="$pkg"
                log "$func_name" '$_pkg' "$_pkg"
                log "$func_name local" '$tar_file' "$tar_file"
                ;;
        esac

        log "$func_name" '$tar_dir' "$tar_dir"
        mkcd "$func_name" "$tar_dir"

        # The tarball is extracted to a temporary directory where its contents are
        # then "installed" to the filesystem. Running this step as soon as possible
        # allows us to also check the validity of the tarball and bail out early
        # if needed.

        log "$func_name" '$tar_file' "$tar_file"
        decompress "$tar_file" | tar xf -

        # Naively assume that the existence of a manifest file is all that
        # determines a valid KISS package from an invalid one. This should be a
        # fine assumption to make in 99.99% of cases.
        [ -f "$PWD/$pkg_db/$_pkg/manifest" ] || die "$func_name" "Not a valid KISS package"

        # Intended behavior.
        # shellcheck disable=2030,2031
        equ "$KISS_FORCE" 1 || {
            pkg_manifest_validate "$_pkg"
            pkg_installable "$_pkg" "$PWD/$pkg_db/$_pkg/depends"
        }
        log "$func_name" '$PWD' "$PWD"
        # arg1: pre-install
        # arg2: package name
        # arg3: path to extracted package
        run_hook pre-install "$_pkg" "$PWD"

        pkg_conflicts "$_pkg"

        log "$func_name" "$_pkg" "Installing package (${tar_file##*/})"

        # If the package is already installed (and this is an upgrade) make a
        # backup of the manifest and etcsums files.
        stack_push "$func_name" "$sys_db/$_pkg/manifest"
        log "$func_name" '$_pkg'
        log "$func_name" '$pkg'

        stack_push "$func_name" "$sys_db/$_pkg/etcsums"
        log "$func_name" '$_pkg'
        log "$func_name" '$pkg'

        stack_slot "$func_name" "manifest-diff"

        tar_man=$PWD/$pkg_db/$_pkg/manifest

        # Generate a list of files which exist in the currently installed manifest
        # but not in the newer (to be installed) manifest.
        grep -vFxf "$tar_man" "$_stack_bottom" > "$_stack_top" 2>/dev/null ||:

        # Reverse the manifest file so that we start shallow and go deeper as we
        # iterate over each item. This is needed so that directories are created
        # going down the tree.
        stack_slot "$func_name" "manifest-reverse"
        sort "$tar_man" > "$_stack_top"

        # Block being able to abort the script with Ctrl+C during installation.
        # Removes all risk of the user aborting a package installation leaving
        # an incomplete package installed.
        trap '' INT

        if
            # Install the package's files by iterating over its manifest.
            pkg_install_files -z "$PWD" < "$_stack_top" 3< "$_stack_bottom" &&

            # This is the aforementioned step removing any files from the old
            # version of the package if the installation is an update. Each file
            # type has to be specially handled to ensure no system breakage occurs.
            pkg_remove_files < "$_stack_second" 3< "$_stack_bottom" &&

            # Install the package's files a second time to fix any mess caused by
            # the above removal of the previous version of the package.
            pkg_install_files -e "$PWD" < "$_stack_top" 3< "$_stack_bottom"

        then
            # Reset 'trap' to its original value. Installation is done so we no longer
            # need to block 'Ctrl+C'.
            # trap pkg_clean EXIT INT

            # arg1: post-install
            # arg2: package name
            # arg3: path to installed package database
            run_hook_pkg post-install "$_pkg"
            run_hook     post-install "$_pkg" "$sys_db/$_pkg"

            log "$func_name" '$repo_dir'              "$repo_dir"
            log "$func_name" '$PWD'                   "$PWD"
            log "$func_name" '$sys_db'                "$sys_db"
            log "$func_name" '$pkg_db'                "$pkg_db"
            log "$func_name" '$_pkg'                  "$_pkg"
            log "$func_name" '$tar_dir'               "$tar_dir"
            log "$func_name" '$pkg_dir'               "$pkg_dir"
            log "$func_name" '$pkg_dir/$pkg_db/$_pkg' "$pkg_dir/$pkg_db/$_pkg"
            log "$func_name" '$PWD/$pkg_db/$_pkg'     "$PWD/$pkg_db/$_pkg"

            [ -d "$pkg_dir/$pkg_db/$_pkg" ] || echo "Directory does not exist"
            # [ -d "$PWD/$pkg_db/$_pkg" ] || echo "Directory does not exist"

            ver="$(cat "$pkg_dir/$pkg_db/$_pkg/version" | awk '{print $1 "-" $2}')"
            index=0
            case "$repo_dir" in
                *"${sys_db}"*)
                    packages="$(find "$REPO_ROOT" \( -type d -o -type l \) -path "$sys_db" -prune -o -name "${_pkg}" -print)"
                    if [ -n "$packages" ]; then
                        matched=0
                        for pack in $packages; do
                            # Guaranteed performance with step-by-step filtering
                            if diff -bwurB "$sys_db/$_pkg/version" "$pack/version" > /dev/null 2>&1 &&
                                diff -bwurB "$sys_db/$_pkg/build" "$pack/build" > /dev/null 2>&1; then

                                found_diff=0
                                temp=
                                diff_list=$(diff -qrN "$sys_db/$_pkg" "$pack" | awk '{print $2}' | tr "\n" " ")
                                for f in $diff_list; do
                                    fn=$(basename $f)
                                    [ "keys" != "$fn" ] &&
                                    [ "manifest" != "$fn" ] &&
                                    [ "etcsums" != "$fn" ] &&
                                    [ "depends" != "$fn" ] &&
                                    temp="$f $temp"
                                done
                                [ -n "$temp" ] && {
                                    found_diff=1
                                    for file in $temp; do
                                        log "$func_name" "diff [ $(basename $file) ]" "$file"
                                    done
                                }
                                [ ${found_diff} -eq 0 ] && {
                                    log "$func_name" "${_pkg} [ $(cat "$pack/version" | awk '{print $1 "-" $2}') ]" "$pack"
                                    [ -f "$sys_db/$_pkg/keys" ] && {
                                        while IFS= read -r line || [ -n "$line" ]; do
                                            key="$(echo $line | awk '{print $1}')"
                                            value="$(echo $line | awk '{print $2}')"
                                            [ -n "$key" ] && [ -n "$value" ] &&
                                            [ "$ver" != "$key" ] && [ "$value" != "$pack" ] && {
                                                printf "%-4s %-15s = %s\n" "$index" "$key" "$value" > /dev/stderr
                                                printf "%-15s %s\n" "$key" "$value" >> "$sys_db/$_pkg/keys-temp"
                                            }
                                        done < "$sys_db/$_pkg/keys"
                                    }
                                    printf "%-15s %s\n" "$ver" "$pack" >> "$sys_db/$_pkg/keys-temp"
                                    \mv -f "$sys_db/$_pkg/keys-temp" "$sys_db/$_pkg/keys"
                                    matched=1
                                    break
                                }
                                index=$(($index + 1))
                            fi
                        done
                        [ $matched -eq 0 ] && {
                            echo "No repositories contain this version of package. Please back it up manually."
                        }
                    else
                        log "$func_name" "backup $sys_db/$_pkg to" "$repo_main/extra/"
                        rsync -aqz "$sys_db/$_pkg" "$repo_main/extra/"
                    fi
                    ;;
                *)
                    [ -f "$sys_db/$_pkg/keys" ] && {
                        while IFS= read -r line || [ -n "$line" ]; do
                            key="$(echo $line | awk '{print $1}')"
                            value="$(echo $line | awk '{print $2}')"
                            [ -n "$key" ] && [ -n "$value" ] &&
                            [ "$ver" != "$key" ] && [ "$value" != "$repo_dir" ] && {
                                printf "%-4s %-15s = %s\n" "$index" "$key" "$value" > /dev/stderr
                                printf "%-15s %s\n" "$key" "$value" >> "$sys_db/$_pkg/keys-temp"
                            }
                            index=$(($index + 1))
                        done < "$sys_db/$_pkg/keys"
                    }
                    printf "%-15s %s\n" "$ver" "$repo_dir" >> "$sys_db/$_pkg/keys-temp"
                    \mv -f "$sys_db/$_pkg/keys-temp" "$sys_db/$_pkg/keys"
                    log "$func_name" "repo [ $(cat "$sys_db/$_pkg/keys" | grep "$ver" | awk '{print $1}') ]" \
                        "$(cat "$sys_db/$_pkg/keys" | grep "$ver" | awk '{print $2}')"
                    ;;
            esac

            log "$func_name" "$_pkg" "Installed successfully"

        else
            # pkg_clean
            log "$func_name" "$_pkg" "Failed to install package." ERROR
            die "$func_name" "$_pkg" "Filesystem now dirty, manual repair needed."
        fi
    )
}

pkg_update() {
    local func_name='pkg_update'
    log "$func_name" "" "Updating repositories"

    # Create a list of all repositories.
    # Intentional, globbing disabled.
    # shellcheck disable=2046,2086
    { IFS=:; set -- $KISS_PATH; unset IFS; }

    # Update each repository in '$KISS_PATH'.
    for repo do
        local repo_type
        if git -C "$repo" rev-parse 'HEAD@{upstream}' >/dev/null 2>&1; then
            repo_type=git

            # Get the Git repository root directory.
            local subm=$(git -C "$repo" rev-parse --show-superproject-working-tree)
            repo=$(git -C "${subm:-"$repo"}" rev-parse --show-toplevel)

        elif ! [ -d "$repo" ]; then
            continue

        else
            unset repo_type
        fi

        pkg_update_repo $repo_type $repo
    done

    pkg_upgrade
}

# $1 repo_type
# $2 repo
pkg_update_repo() {
    local func_name='pkg_update_repo'
    local repo_type=$1
    local repo=$2
    cd "$repo" || die "$func_name" "Repository '$repo' inaccessible"

    contains "$repos" "$PWD" || {
        repos="$repos $PWD"

        log "$func_name" '$PWD' "$PWD"

        am_owner "$PWD" || {
            printf 'Need "%s" to update\n' "$user"
            set -- as_user
        }

        # arg1: pre-update
        # arg2: need su?
        # arg3: owner
        # env:  PWD is path to repository
        run_hook pre-update "$#" "$user"

        case $repo_type in git)
            pkg_update_git "$@"
        esac

        # arg1: post-update
        # env:  PWD is path to repository
        run_hook post-update
    }
}

pkg_update_git() {
    local func_name='pkg_update_git'
    # Display whether or not signature verification is enabled.
    case $(git config --get merge.verifySignatures) in true)
        printf 'Signature verification enabled.\n'
    esac

    "$@" git pull
    "$@" git submodule update --remote --init -f
}

pkg_upgrade() {
    local func_name='pkg_upgrade'
    log "$func_name" "Checking for new package versions"
    set +f

    for pkg in "$sys_db/"*; do set -f
        pkg_find_version "$func_name" "${pkg##*/}" "" "" "$sys_db"
        pkg_find_version "$func_name" "${pkg##*/}"

        # Detect repository orphans (installed packages with no
        # associated repository).
        case $repo_dir in */var/db/kiss/installed/*)
            _repo_orp="$_repo_orp$newline${pkg##*/}"
        esac

        # Compare installed packages to repository packages.
        equ "$ver_pre-$rel_pre" "$repo_ver-$repo_rel" || {
            set -- "$@" "${pkg##*/}"

            printf '%s %s => %s\n' \
                "${pkg##*/}" "$ver_pre-$rel_pre" "$repo_ver-$repo_rel"
        }
    done

    case $_repo_orp in *?*)
        war "$func_name" "" "Packages without repository$_repo_orp"
    esac

    build_install=0
    prefer_cache=1

    ! contains "$*" kiss || {
        log "$func_name" "" "Detected package manager update"
        log "$func_name" "" "The package manager will be updated first"

        prompt
        pkg_build_all kiss

        log "$func_name" "" "Updated the package manager"
        log "$func_name" "" "Re-run 'kiss update' to update your system"
        return 0
    }

    for _ do
        pkg_order "$@"

        # Intentional, globbing disabled.
        # shellcheck disable=2046,2086
        set -- $order

        prompt "Packages to update ($#): $*"
        pkg_build_all "$@"
        log "$func_name" "" "Updated all packages"
        return 0
    done

    log "$func_name" "" "Nothing to do"
}

pkg_clean() {
    local func_name='pkg_clean'
    # Clean up on exit or error. This removes everything related to the build.
    # If _KISS_LVL is (1) we are the top-level process - the entire cache will
    # be removed. If _KISS_LVL is any other value, remove only the tar directory.

    log "$func_name" '$pkg'        "$pkg"
    log "$func_name" '$action'     "$action"
    debug "$func_name" '$tar_dir'    "$tar_dir"
    debug "$func_name" '$KISS_DEBUG' "$KISS_DEBUG"
    debug "$func_name" '$_KISS_LVL'  "$_KISS_LVL"

    case $action in
        i|install)
            tmp_clean
    esac

    case ${KISS_DEBUG:-0}-${_KISS_LVL:-1} in
        0-1) [ -n "$proc" ] && [ "$proc/$pkg" != "/$pkg" ] && \rm -rf "$proc/$pkg" ;;
        0-*) [ -n "$tar_dir" ] && [ "$(occurrences "$tar_dir" "/")" -ne "1" ] && \rm -rf "$tar_dir"
    esac
}

# $@ :
pkg_help_ext() {
    local func_name='pkg_help_ext'
    log "$func_name" "" 'Installed extensions (kiss-* in PATH)'
    debug "$func_name" '$#' "$#"

    # Intentional, globbing disabled.
    # shellcheck disable=2046,2030,2031
    set -- $(pkg_find "$pkg" kiss-\* all -x "$PATH")

    # To align descriptions figure out which extension has the longest
    # name by doing a simple 'name > max ? name : max' on the basename
    # of the path with 'kiss-' stripped as well.
    #
    # This also removes any duplicates found in '$PATH', picking the
    # first match.
    for path do
        p=${path#*/kiss-}

        case " $seen " in *" $p "*)
            shift
            continue
        esac

        seen=" $seen $p "
        max=$((${#p} > max ? ${#p}+1 : max))
    done

    IFS=\#$IFS

    # Print each extension, grab its description from the second line
    # in the file and align the output based on the above max.
    for path do
        # Open the extension as a file descriptor.
        exec 3< "$path"

        # Grab the second line in the extension.
        { read -r _ && IFS=\#$IFS read -r _ cmt; } <&3

        printf "%b->%b %-${max}s %s\\n" \
            "$c1" "$c3" "${path#*/kiss-}" "$cmt"
    done >&2
}

trap_on() {
    local func_name='trap_on'
    # Catch errors and ensure that build files and directories are cleaned
    # up before we die. This occurs on 'Ctrl+C' as well as success and error.
    trap trap_INT  INT
    trap trap_EXIT EXIT
}

trap_INT() {
    local func_name='trap_INT'
    run_hook SIGINT
    exit 1
}

trap_EXIT() {
    local func_name='trap_EXIT'
    pkg_clean
    run_hook SIGEXIT
}

trap_off() {
    local func_name='trap_off'
    # Block being able to abort the script with 'Ctrl+C'. Removes all risk of
    # the user aborting a package install/removal leaving an incomplete package
    # installed.
    trap "" INT EXIT
}

init_dirs() {
    local func_name='init_dirs'

    cd "/tmp/kiss/$uid"
    list=$(ls -x /tmp/kiss/$uid)
    for dir in $list; do
        [ "$dir" != "${ppid}" ] && [ "$(expr substr $dir 1 1)" != '/' ] && \rm -rf "$dir";
    done
    cd $ppwd

    log_dir_original="/tmp/kiss/$uid/$ppid"
    mkdir -p "$log_dir_original"
    null "$log_dir" && log_dir="$log_dir_original"

    # Root directory.
    KISS_ROOT=${KISS_ROOT%"${KISS_ROOT##*[!/]}"}

    # This allows for automatic setup of a KISS chroot and will
    # do nothing on a normal system.
    mkdir -p "$KISS_ROOT/" 2>/dev/null || :

    # System package database.
    sys_db=$KISS_ROOT/${pkg_db:=var/db/kiss/installed}
    sys_ch=$KISS_ROOT/${cho_db:=var/db/kiss/choices}

    # Top-level cache directory.
    cac_dir=${XDG_CACHE_HOME:-"${HOME%"${HOME##*[!/]}"}/.cache"}
    cac_dir=${cac_dir%"${cac_dir##*[!/]}"}/kiss

    # Persistent cache directories.
    src_dir=$cac_dir/sources


    # Top-level Temporary cache directory.
    proc=${KISS_TMPDIR:="$cac_dir/proc"}
    proc=${proc%"${proc##*[!/]}"}

    log "$func_name" '${time%-*}' "${time%-*}"
    log "$func_name" '${time}'    "${time}"
    log "$func_name" '$sys_db'    "$sys_db"
    log "$func_name" '$log_dir'   "$log_dir"
}

tmp_dirs() {
    local func_name='tmp_dirs'
    local pkg="$1"

    null "$log_dir_original" && die "$func_name" "\$log_dir_original is not defined"

    pkg_root="$proc/${pkg}"

    # Temporary cache directories.
    mak_dir=$pkg_root/build
    pkg_dir=$pkg_root/pkg
    tar_dir=$pkg_root/extract
    tmp_dir=$pkg_root/tmp
    # log_dir=$pkg_root/logs/${time%-*}
    log_dir=$pkg_root/logs
    bin_dir=$pkg_root/bin

    if [ -d "${pkg_root}" ] && equ "reset" "$2"; then
        [ "$mak_dir" != "/build" ] && \rm -rf "$mak_dir";
        [ "$tmp_dir" != "/tmp" ]   && \rm -rf "$tmp_dir";
        [ "$bin_dir" != "/bin" ]   && \rm -rf "$bin_dir";
    fi

    # set +e will bypass the following exit
    # [ -d "${pkg_root}" ] && equ "reset" "$2" && \rm -rf "$pkg_root"
    # Removing "|| :", and adding the following line will get the same effect
    # [ $? -ne 0 ] && log "$func_name" "" "[] error occurred"

    mkdir -p "$src_dir" "$log_dir" "$bin_dir" \
        "$mak_dir" "$pkg_dir" "$tar_dir" "$tmp_dir"

    log "$func_name" '$log_dir_original'

    [ "$(readlink "${log_dir}/build.log")" != "${log_dir_original}/build.log" ] &&
    ln -sf "${log_dir_original}/build.log" "${log_dir}/build.log"

    # [ -z "$time" ] && time=$(date +%Y-%m-%d-%H:%M)

    debug "$func_name" '$pkg'       "$pkg"
    log "$func_name" '$log_dir'   "$log_dir"

    # printf "%s" "$pkg_root"
}

tmp_clean() {
    [ -L "${log_dir}/build.log" ] &&
    [ "${log_dir}/build.log" != "/build.log" ] &&
    [ -f "${log_dir_original}/build.log" ] &&
    [ "${log_dir_original}/build.log" != "/build.log" ] &&
    [ "$(readlink "${log_dir}/build.log")" = "${log_dir_original}/build.log" ] && {
        \rm -f "${log_dir}/build.log"
        \mv -f "${log_dir_original}/build.log" "${log_dir}/build.log"
        \rm -rf "${log_dir_original}"
    }
}

args() {
    local func_name='args'
    # Parse script arguments manually. This is rather easy to do in our case
    # since the first argument is always an "action" and the arguments that
    # follow are all package names.
    action="$1"
    log "$func_name" '$action' "$action"

    shift "$(($# != 0))"

    local pkg

    # Ensure that arguments do not contain invalid characters. Wildcards can
    # not be used here as they would conflict with kiss extensions.
    case $action in
        a|alternatives)
            case $1 in *\**|*\!*|*\[*|*\ *|*\]*|*/*|*"$newline"*)
                die "$func_name" "Invalid argument: '!*[ ]/\\n' ($1)";
            esac
        ;;

        b|build|c|checksum|d|download|i|install|l|list|r|remove)
            for _arg do case ${action%%"${action#?}"}-$_arg in
                i-*\!*|i-*\**|i-*\[*|i-*\ *|i-*\]*|i-*"$newline"*)
                    die "$func_name" "Invalid argument: '!*[ ]\\n' ('$_arg')"
                    ;;

                [!i]-*\!*|[!i]-*\**|[!i]-*\[*|[!i]-*\ *|\
                [!i]-*\]*|[!i]-*/*|[!i]-*"$newline"*)
                    die "$func_name" "Invalid argument: '!*[ ]/\\n' ('$_arg')"
                    ;;
            esac done

            # When no arguments are given on the command-line, use the basename
            # of the current directory as the package name and add the parent
            # directory to the running process' KISS_PATH.
            case ${action%%"${action#?}"}-$# in [!l]-0)
                export KISS_PATH=${PWD%/*}:$KISS_PATH
                set -- "${PWD##*/}"
            esac

            # Search the installed database first when removing packages. Dependency
            # files may differ when repositories change. Removal is not dependent on
            # the state of the repository.
            case $action in r|remove)
                export KISS_PATH=$sys_db:$KISS_PATH
            esac

            # Order the argument list based on dependence.
            pkg_order "$@"

            # Intentional, globbing disabled.
            # shellcheck disable=2046,2086
            set -- $order
            ;;
    esac

    # Need to increment _KISS_LVL here to ensure we don't wipe the cache
    # early by non-asroot invocations.
    export _KISS_LVL=$((_KISS_LVL + 1))

    # Rerun the script as root with a fixed environment if needed. We sadly
    # can't run singular functions as root so this is needed.
    #
    # Intended behavior.
    # shellcheck disable=2030,2031

    case $action in a|alternatives|i|install|r|remove)
        if ok "$action" && ! am_owner "$KISS_ROOT/"; then
            trap_off
            as_user env \
                LOGNAME="$user" \
                HOME="$HOME" \
                XDG_CACHE_HOME="$XDG_CACHE_HOME" \
                KISS_COMPRESS="$KISS_COMPRESS" \
                KISS_PATH="$KISS_PATH" \
                KISS_FORCE="$KISS_FORCE" \
                KISS_ROOT="$KISS_ROOT" \
                KISS_CHOICE="$KISS_CHOICE" \
                KISS_COLOR="$KISS_COLOR" \
                KISS_TMPDIR="$KISS_TMPDIR" \
                KISS_PID="$KISS_PID" \
                _KISS_LVL="$_KISS_LVL" \
                "$0" "$action" "$@"

            trap_on
            return
        fi
        ;;
    esac

    # Clear temporary files

    # # This will cancell the process on busybox 1.35.0-2, when test variables has definition
    # # and set -e
    # [ -z "$pkg" ] || log "$func_name" '$pkg is not empty test' "$pkg"
    # [ -z "$KISS_DEBUG" ] || log "$func_name" '$KISS_DEBUG' "$KISS_DEBUG"
    # null "$KISS_DEBUG" ||
    # log "$func_name" '$KISS_DEBUG' "$KISS_DEBUG"

    # This will recover the process
    # [ -z "$KISS_DEBUG" ] || { :; log "$func_name" '$KISS_DEBUG' "$KISS_DEBUG"; }
    null "$KISS_DEBUG" || { :
        log "$func_name" '$KISS_DEBUG' "$KISS_DEBUG"
    }

    # # This will cancell the process on busybox 1.35.0-2, when test variables has definition
    # # and set -e
    # if [ -z "$pkg" ]; then
    #     die "$func_name check" '$pkg' "$pkg"
    # else
    #     log "$func_name check" '$pkg' "$pkg"
    # fi

    ok "$pkg" && {
        tmp_dirs "$pkg"
        log "$func_name tmp_dirs" '$pkg_root' "$pkg_root"
        log "$func_name tmp_dirs" '$src_dir'  "$src_dir"
    }

    # Actions can be abbreviated to their first letter. This saves keystrokes
    # once you memorize the commands.
    case $action in
        a|alternatives) pkg_alternatives "$@" ;;
        b|build)        pkg_build_all "$@" ;;
        c|checksum)     for pkg do pkg_checksum "$pkg"; done ;;
        d|download)     for pkg do pkg_source "$pkg"; done ;;
        H|help-ext)     pkg_help_ext "$@" ;;
        i|install)      for pkg do pkg_install "$pkg"; done ;;
        l|list)         pkg_list_version "$func_name" "$@" ;;
        r|remove)       for pkg in $redro; do pkg_remove "$pkg"; done ;;
        s|search)       for pkg do pkg_find "$pkg" all; done ;;
        u|update)       pkg_update ;;
        U|upgrade)      pkg_upgrade ;;
        v|version)      printf '5.5.28\n' ;;

        '')
            log "$func_name" 'kiss [a|b|c|d|i|l|r|s|u|U|v] [pkg]...'
            log "$func_name" 'alternatives List and swap alternatives'
            log "$func_name" 'build'    'Build packages'
            log "$func_name" 'checksum' 'Generate checksums'
            log "$func_name" 'download' 'Download sources'
            log "$func_name" 'install'  'Install packages'
            log "$func_name" 'list'     'List installed packages'
            log "$func_name" 'remove'   'Remove packages'
            log "$func_name" 'search'   'Search for packages'
            log "$func_name" 'update'   'Update the system and repositories'
            log "$func_name" 'upgrade'  'Update the system'
            log "$func_name" 'version'  'Package manager version'

            printf '\nRun "kiss [H|help-ext]" to see all actions\n'
            ;;

        *)
            # _KISS_LVL must be reset here so the that any extensions
            # which call the package manager do not increment the value
            # further than the parent instance.
            log "$func_name" '$#' "$#"
            log "$func_name" '$0' "$0"
            log "$func_name" '$1' "$1"
            log "$func_name" '$2' "$2"
            log "$func_name" '$3' "$3"
            log "$func_name" '$4' "$4"
            log "$func_name" '$5' "$5"
            log "$func_name" '$2-$#' "$2-$#"
            for item in $@; do
                log "$func_name" '$item' "$item"
            done

            log "$func_name" 'esceval'
            esceval "$@"

            null "$pkg" && pkg="$1"
            log "$func_name" '$pkg' "$pkg"

            pkg_find "$pkg" "kiss-$action*" "" -x "$PATH"

            log "$func_name" '$sys_db'   "$sys_db"
            log "$func_name" '$repo_dir' "$repo_dir"


            _KISS_LVL=0 "$repo_dir" "$@"
            ;;
    esac
}

# Need a nicer way of detecting architecture
determine_arch(){
    local func_name='determine_arch'
    local _arch="$($cmd_elf -a -W $1 | grep 'Machine:')"
    local _endian="$($cmd_elf -a -W $1 | grep 'Data:')"

    case "$_arch $_endian" in
        *AArch64*little*)   arch="aarch64-linux-musl";;
        *AArch64*big*)      arch="aarch64_be-linux-musl";;
        *ARM*)              arch="armv7-linux-musleabihf";;
        *Intel*80386*)      arch="i686-linux-musl";;
        *PowerPC64*little*) arch="powerpc64le-linux-musl";;
        *PowerPC64*big*)    arch="powerpc64-linux-musl";;
        *PowerPC*little*)   arch="powerpcle-linux-musl";;
        *PowerPC*big*)      arch="powerpc-linux-musl";;
        *X86-64*)           arch="x86_64-linux-musl";;
        *RISC-V*)           arch="riscv64-linux-musl";;
        *) die "$func_name" "Unknown architecture: $_arch / $_endian";;
    esac

    echo $arch
}

cross_flags() {
    local func_name='cross_flags'
    export KISS_XBUILD_TRIPLE="$(clang -print-target-triple | sed 's/-unknown//')"
    export KISS_XHOST_TRIPLE="${KISS_XHOST_TRIPLE:-$(determine_arch $KISS_ROOT/usr/bin/bzip2)}"

    set -f
    old_ifs=$IFS
    IFS=-

    set -- $KISS_XBUILD_TRIPLE
    export KISS_XBUILD_ARCH=$1
    export KISS_XBUILD_SYS=$2
    export KISS_XBUILD_ABI=$3

    set -- $KISS_XHOST_TRIPLE
    export KISS_XHOST_ARCH=$1
    export KISS_XHOST_SYS=$2
    export KISS_XHOST_ABI=$3

    IFS=$old_ifs
    set +f

    # Flags used for pkg-config
    export PKG_CONFIG_PATH=
    export PKG_CONFIG_LIBDIR=${KISS_ROOT}/usr/lib/pkgconfig:${KISS_ROOT}/usr/share/pkgconfig
    export PKG_CONFIG_SYSROOT_DIR=${KISS_ROOT}

    # Don't carry over flags if this is a cross build
    if [ ! -z $KISS_ROOT ]; then
        unset CFLAGS
        unset CXXFLAGS
        unset LDFLAGS
    fi

    # Allow setting of chroot-specific cflags
    flagfile="$KISS_ROOT/etc/os-buildflags"
    if [ -f "$flagfile" ]; then
        source $flagfile
    fi

    # Set the compiler target architecture
    if [ -z "$KISS_ROOT" ]; then
        # Local build. Allow user-set CFLAGS as per normal KISS, or override them in /etc/os-buildflags
        export CC="${CC:-clang}"
        export CXX="${CXX:-clang++}"
    else
        # Cross build. CFLAGS will always come from $KISS_ROOT/etc/os-buildflags
        flags="--target=$KISS_XHOST_TRIPLE --sysroot=${KISS_ROOT} -fPIC"
        export   CFLAGS="$flags $CFLAGS"
        export CXXFLAGS="$flags $CXXFLAGS"
        export  LDFLAGS="--sysroot=$KISS_ROOT $LDFLAGS"
        export       CC="clang $CFLAGS"
        export      CXX="clang++ $CXXFLAGS"
    fi
}

repo_setup() {
    local func_name='repo_setup'
    # Set variables which help with cross building
    if [ -z "$KISS_BINREPO" ]; then
        cross_flags

        # Bin repo will be "local" for normal builds, for chroot builds
        # it will be the last part of $KISS_ROOT appended with md5sum of
        # the full $KISS_ROOT path. This keeps packages built for different
        # root directories in separate directories.
        local lastbit="${KISS_ROOT##*/}"
        if null "$lastbit"; then
            binrepo="local"
        else
            binrepo="${lastbit}_$(echo "$KISS_ROOT" | md5sum | cut -c1-32)"
        fi
    else
        binrepo="$KISS_BINREPO"
    fi
}


main() {
    local func_name='kiss'
    # http://mywiki.wooledge.org/BashFAQ/105
    # Globally disable globbing and enable exit-on-error.
    set -f # set -ef

    # Store the original working directory to ensure that relative paths
    # passed by the user on the command-line properly resolve to locations
    # in the filesystem.
    ppwd=$PWD

    # Store the date and time of script invocation to be used as the name of
    # the log files the package manager creates during builds.
    time=$(date +%Y-%m-%d-%H:%M)

    ppid="$(echo $PPID)"
    uid="$(id -u)"

    # Color can be disabled via the environment variable KISS_COLOR. Colors are
    # also automatically disabled if output is being used in a pipe/redirection.
    equ "$KISS_COLOR" 0 || { :; ! [ -t 2 ]; } || { :
        if [ -z "$KISS_ROOT" ]; then
            c1='\033[1;33m'
            c2='\033[1;34m'
            c3='\033[m'
        else
            c1='\033[1;33m'
            c2='\033[1;35m'
            c3='\033[m'
        fi
    }

    init_dirs

    log "$func_name" 'esceval'
    esceval "$@"

    log "$func_name" '$KISS_ROOT' "$KISS_ROOT"


    # Never know when you're gonna need one of these.
    newline="
"

    # Defaults for environment variables.
    : "${KISS_COMPRESS:=gz}"
    : "${KISS_PID:=$$}"
    : "${LOGNAME:?POSIX requires LOGNAME be set}"

    # Figure out which 'sudo' command to use based on the user's choice or what
    # is available on the system.
    cmd_su=${KISS_SU:-"$(
        command -v /usr/bin/ssu  ||
        command -v /usr/bin/doas ||
        command -v /usr/bin/sudo ||
        command -v /usr/bin/su
    )"} || cmd_su=/usr/bin/su

    # Figure out which utility is available to dump elf information.
    cmd_elf=${KISS_ELF:-"$(
        command -v /usr/bin/readelf      ||
        command -v /usr/bin/eu-readelf   ||
        command -v /usr/bin/llvm-readelf
    )"} || cmd_elf=/usr/bin/ldd

    # Figure out which sha256 utility is available.
    cmd_sha=${KISS_CHK:-"$(
        command -v /usr/bin/openssl   ||
        command -v /usr/bin/sha256sum ||
        command -v /usr/bin/sha256    ||
        command -v /usr/bin/shasum    ||
        command -v /usr/bin/digest
    )"} || die "$func_name" "No sha256 utility found"

    # Figure out which download utility is available.
    cmd_get=${KISS_GET:-"$(
        command -v /usr/bin/aria2c ||
        command -v /usr/bin/axel   ||
        command -v /usr/bin/curl   ||
        command -v /usr/bin/wget   ||
        command -v /usr/bin/wget2
    )"} || die "$func_name" "No download utility found (aria2c, axel, curl, wget, wget2)"


    repo_setup

    log "$func_name" "$@"
    # Catch errors and ensure that build files and directories are cleaned
    # up before we die. This occurs on 'Ctrl+C' as well as success and error.
    # trap pkg_clean EXIT INT
    trap_off
    # trap_on

    args "$@"

    tmp_clean
    :
}

main "$@"

# vi:   set filetype=sh syntax=sh :
# vim:  set filetype=sh syntax=sh :
# nvim: set filetype=sh syntax=sh :
