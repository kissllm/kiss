#! /bin/sh -e
# Alter a package (default dialed by kiss::subshell_all)

[ ! -z "${IS_KISS+x}" ] && set -Eau || set -au

check_pipefail="$(set -o | grep pipefail | awk "{print \$1}")"
[ "$check_pipefail" != "pipefail" ] || set -o pipefail
# Independent usage (using current environment variables)
# kiss-install /var/db/kiss/lm/extra/luajit

# Into the kiss environment (default design)
# kiss (no need to import kiss/share and kiss every time it dials)
# Usage
# i luajit
# . /usr/bin/kiss-install /var/db/kiss/lm/extra/luajit

[ -n "${HEADER+x}" ] ||
printf '%s %s\n' '$HEADER' "not defined"

SCRIPT_NAME="kiss-alter" && export SCRIPT_NAME

[ -z "${KISS_INNER_PIPE+x}" ] || unset KISS_INNER_PIPE
[ -z "${mute_err+x}" ] || unset mute_err
[ -z "${KEEP_DEPRECATED+x}" ] || unset KEEP_DEPRECATED
: "${SESSION_PID:="$$"}" && export SESSION_PID
: "${SESSION_PPID:="${PPID}"}" && export SESSION_PPID
: "${KISS_PID:=$$}" && export KISS_PID
: "${KISS_TMPDIR:="/tmp/$(whoami)/kiss"}" && export KISS_TMPDIR
[ -d "$KISS_TMPDIR" ] ||
	# // as_own "$KISS_ROOT/" \mkdir -p "$KISS_TMPDIR"
	\mkdir -p "$KISS_TMPDIR"
log_dir="$KISS_TMPDIR/logs"
[ -d "$log_dir" ] ||
	# // as_own "$KISS_ROOT/" mkdir -p "$log_dir"
	\mkdir -p "$log_dir"
: "${USER_OUTPUT:="$KISS_TMPDIR/logs/build.log"}" && export USER_OUTPUT

# interrupt_type="$(type "interrupt" > /dev/null && type "interrupt")" || :
# is_repos_type="$(type "is_repos" > /dev/null && type "is_repos")" || :
# {
#   [ ! -z "${interrupt_type:+x}" ] &&
#   [ -z "${interrupt_type##*"alias"*}" ] &&
#   [ ! -z "${is_repos_type:+x}" ] &&
#   [ -z "${is_repos_type##*"function"*}" ]
#   # set | grep -q _level > /dev/null &&
#   # [ -n "${HEADER+x}" ]
# } || {

# [ ! -z "${KISS_ALTER_AS_LIBRARY+x}" ] || {
#   # # shellcheck source=/usr/include/kiss/share
#   # . /usr/include/kiss/share
#   # # . /usr/include/kiss/share > /dev/null 2>&1
#   #
#   # Recursively calling if dial current script in an individual process
#   # shellcheck source=/usr/bin/kiss
#   . /usr/bin/kiss --
#   #
#   # # shellcheck source=/usr/bin/kiss-impl
#   # . /usr/bin/kiss-impl
#
#   [ -t 0 ] || // die 'fd 0' "does not work"
#
#   # -ash: //: Permission denied -- // is not defined
#
# }

// log 'inside' "kiss-alter"

# Usage:
# // ver_mount "$KISS_ROOT/usr/lib/clang" "$mount_point_name" "$version_target"
ver_mount() {
	local location="$1"
	local mount_point_name="$2"
	local version_target="$3"

	# cd "$KISS_ROOT/usr/lib/clang"
	cd "$location" || // die '$location' "'$location' can not be accessed by '$LOGNAME'"

	is_folder "$mount_point_name" && {
		# [ ! -d ".backup" ] || \rm -rf ".backup"
		rsync -aqz "$mount_point_name" ".backup/" && sync
		\rm -rf "$mount_point_name"
		$cmd_link -- "$version_target" "$mount_point_name"
	} || {
		# {
		# 	[ ! -d "$mount_point_name" ] || [ -h "$mount_point_name" ]
		# } && {
		[ ! -h "$mount_point_name" ] && {
			[ ! -f "$mount_point_name" ] || rm -f "$mount_point_name"
			$cmd_link -- "$version_target" "$mount_point_name"
		} ||
		[ "$(readlink -fn "$mount_point_name")" = "$(readlink -fn "$version_target")" ] || {
			rm -f "$mount_point_name"
			$cmd_link -- "$version_target" "$mount_point_name"
		}
	}
}

# Double included kiss/share
# type_include "is_repos" "function" "/usr/bin/kiss"
#
# check_is_repos="$(type "is_repos" 2> /dev/null)" || :
# printf '%s %s\n' '$check_is_repos' "$check_is_repos"
# [ -n "${check_is_repos:+x}" ] &&
# [ -z "${check_is_repos##*"function"*}" ] || {
#   . /usr/bin/kiss
# }

# could be subshell function before local version
# $1 repo_urn  : package repo url/uri
# $2 depends   : depends file address
# $3 missing   : missing package(s)
installable() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	local depends="$2"
	local missing=0
	# Check if a package is removable and die if it is not.
	# A package is removable when all of its dependencies
	# are satisfied.
	// log "$repo_name" "checking if package installable"

	// log '$PWD' "$PWD"
	// log '$repo_name' "$repo_name"
	// log '$depends' "$depends"

	null "$missing" || // log '$missing' "$missing"

	# False positive.
	# shellcheck disable=2094
	[ ! -f "$depends" ] ||
	while read -r dep dep_type || ok "$dep"; do
		// debug '$dep' "$dep"
		case "$dep $dep_type" in
			[!\#]?*"\ ")
			[ ! -d "$KISS_ROOT/$db/$dep" ] || ! is_repos "$KISS_ROOT/$db/$dep" || continue

			// war '$dep' "'$dep' not found"

			// debug '$dep' "$dep"
			// war '$dep' "$dep"
			// debug '$dep_type' "$dep_type"
			// war '$dep_type' "$dep_type"
			: $((missing += 1))
			set -- "$repo_name" "$depends" "$missing"
		esac
	done < "$depends"
	null "$missing" || // log '$missing' "$missing"
	// debug '$missing' "$missing"
	case ${missing:-0} in
		[1-9]*)
		// die "$repo_name" "not installable, missing $missing package(s)"
	esac
}

pkg_etc() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	shift 1

	local file="$1"
	local hash="$(// delegate -- "sh256" \
		"$EXTRACT_ROOT/$repo_name/$file" "$KISS_ROOT/${file#/}")"

	local sum_new="${hash%%"$newline"*}"
	local sum_sys="${hash#*"$newline"}"
	local sum_old
	read -r sum_old <&3 2>/dev/null ||
	// war "$repo_urn/etcsums" "3: Bad file descriptor"

	# Compare the three checksums to determine what to do.
	case ${sum_old:-null}${sum_sys:-null}${sum_new} in
		# old = Y, sys = X, new = Y
		"${sum_new}${sum_sys}${sum_old}")
			return 1
			;;

		# old = X, sys = X, new = X
		# old = X, sys = Y, new = Y
		# old = X, sys = X, new = Y
		"${sum_old}${sum_old}${sum_old}"|\
		"${sum_old:-null}${sum_sys}${sum_sys}"|\
		"${sum_sys}${sum_old}"*)

			;;

		# All other cases.
		*)
			// war "$repo_name" "saving $file as $file.new"
			_file=$_file.new
			;;
	esac
}

file_rwx() {
	_level_2
	# Convert the output of 'ls' (rwxrwx---) to octal. This is simply
	# a 1-9 loop with the second digit being the value of the field.
	#
	# NOTE: This drops setgid/setuid permissions and does not include
	# them in the conversion. This is intentional.
	local oct= o=

	rwx="$(\ls -ld "$1" | awk '{print $1}')"

	for c in 14 22 31 44 52 61 74 82 91; do
		rwx="${rwx#?}"

		case $rwx in
			[rwx]*) o="$((o + ${c#?}))" ;;
			 [st]*) o="$((o + 1))" ;;
		esac

		case $((${c%?} % 3)) in 0)
			oct=$oct$o
			o=0
		esac
	done
	printf "$RS%s" "$oct"
}

remove_files() {
	_level_2
	# Remove a file list from the system. This function runs during package
	# installation and package removal. Combining the removals in these two
	# functions allows us to stop duplicating code.
	while read -r file; do
		case $file in
			/etc/?*[!/])
				local hash="$(// delegate -- "sh256" "$KISS_ROOT/${file#/}")"
				local sum_pkg
				read -r sum_pkg <&3 ||
				// war "$repo_urn/etcsums" "3: Bad file descriptor"

				equ "$hash" "$sum_pkg" || {
					// log "skipping" "$file (modified)"
					continue
				}
		esac

		local _file=${KISS_ROOT:+"$KISS_ROOT/"}"${file%%/}"

		# Queue all directory symlinks for later removal.
		if [ -h "$_file" ] && [ -d "$_file" ]; then
			case $file in
				/*/*/)
				set -- "$@" "$_file"
			esac

		# Remove empty directories.
		elif [ -d "$_file" ]; then
			as_own "$KISS_ROOT/" \rmdir "$_file" 2>/dev/null || :

		# Remove everything else.
		else
			as_own "$KISS_ROOT/" \rm -f "$_file"
		fi
	done

	# Remove all broken directory symlinks.
	for sym do
		[ -e "$sym" ] || as_own "$KISS_ROOT/" \rm -f "$sym"
	done
}

install_files() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
		repo_urn="$(// delegate -- repo_trace "$repo_name")"
	shift 1

	// debug_filter -- // log '$@' "$(esceval "$@")"

	local flag="$1"
	local extract_dir="$2"

	set --
	local kiss_root_user="$(// delegate owner "$KISS_ROOT/")"
	[ "$LOGNAME" = "$kiss_root_user" ] ||
		set -- $(// delegate as_user "$kiss_root_user")

	local _file

	# Copy files and create directories (preserving permissions).
	# The 'test $1' will run with '-z' for overwrite and '-e' for verify.
	while { read -r file && _file=$KISS_ROOT$file; } do case $file in
		*/)
			# Skip directories if they already exist in the file system.
			# (Think /usr/bin, /usr/lib, etc).
			[ -d "$_file" ] || {
				# mkdir: can't create directory '/opt/kiss/usr/include/c++/v1/__string/': Not a directory
				local try_file="${_file%/*}"
				{ [ ! -f "$try_file" ] && [ ! -h "$try_file" ]; } ||
					"$@" \rm -f "$try_file"
				local oct="$(// delegate -- file_rwx "$extract_dir$file")"
				"$@" \mkdir -m "$oct" -p "$_file"
			}
		;;

		*)
			# Skip directories and files which exist in verify mode.
			# [ -d "$_file" ] || ! test "$flag" "$_file" || continue
			{ [ ! -d "$_file" ] && ! test "$flag" "$_file"; } || {
				[ ! -z "$file" ] || continue
				[ ! -d "$_file" ] && continue || "$@" \rm -rf "$_file"
			}

			# Neovim
			# mv to '/usr/share/locale/cs.cp1250/LC_MESSAGES/nvim.mo' failed
			local dir="${_file%/*}"

			[ -d "$dir" ] || {
				local oct="$(// delegate -- file_rwx "$extract_dir${file%/*}")"
				"$@" \mkdir -m "$oct" -p "$dir"
			}

			case $file in /etc/*[!/])
				# Handle /etc/ files in a special way (via a 3-way checksum) to
				# determine how these files should be installed. Do we overwrite
				# the existing file? Do we install it as $file.new to avoid
				# deleting user configuration? etc.
				#
				# This is more or less similar to Arch Linux's Pacman with the
				# user manually handling the .new files when and if they appear.
				[ ! -f "$repo_urn/etcsums" ] ||
				// pkg_etc "$repo_urn" "$file" || continue
			esac

			if [ -h "$_file" ]; then
				# Copy the file to the destination directory overwriting
				# any existing file.
				"$@" \cp -fP "$extract_dir$file" "${_file%/*}/." ||
				// die "cp $extract_dir$file to" "'${_file%/*}/.' failed"

			else

				# Construct a temporary filename which is a) unique and
				# b) identifiable as related to the package manager.
				local __tmp="${_file%/*}"/__kiss-tmp-"$repo_name"-"${file##*/}"-"$KISS_PID"

				[ -h "$extract_dir$file" ] ||
				[ -f "$extract_dir$file" ] || // die "$extract_dir$file" "does not exist"

				# Copy the file to the destination directory with the
				# temporary name created above.
				# cp: can't stat '$EXTRACT_ROOT/llvm/var/db/kiss/choices/llvm>usr>bin>bugpoint': No such file or directory
				# But it was there
				"$@" \cp -fP "$extract_dir$file" "$__tmp" &&

				# Atomically move the temporary file to its final destination.
				# The running processes will either get the old file or the new one.
				#
				"$@" \mv -f "$__tmp" "$_file" ||
				// die "mv $__tmp to" "'$_file' failed"
				# Extremely slow
				# "$@" rsync -aqX --no-o --no-g --remove-source-files "$__tmp" "$_file" ||
				# // die "$@ rsync -aqX --remove-source-files \"$__tmp\" \"$_file\"" "failed"
			fi
	esac || return 1; done
	"$@" sync
}

archive() {
	_level_2
	local base_dir="$1"
	local repo_urn="$2"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"

	local dir= ver= rel= repo_alias= url= reference_type=

	! // || / `pkg_version "$repo_urn" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "dir=\""$1"\"; ver=\""$2"\"; rel=\""$3"\"; \
	repo_alias=\""$4"\"; url=\""$5"\"; reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`

	# Newcomers make their own interal new release numbers
	# # Make room for the newcomers
	# [ ! -d "$base_dir/$repo_name/$version_dir" ] || {
	#     // is_model "$base_dir/$repo_name/$version_dir" "$repo_urn" ||
	#     ! is_repos "$base_dir/$repo_name/$version_dir" || {
	#         \mv -f "$base_dir/$repo_name/$version_dir" \
	#             "$base_dir/$repo_name/$new_release_dir"
	#     }
	# }
	local target_dir=
	local item
	local found_duplicated=
	local ver_new="$ver" rel_new="$rel"
	# for item in $(\ls -1 "$base_dir/$repo_name"); do
	for item in $(// as_own "$base_dir" \
		find -L "$base_dir/$repo_name" -type d \
			-mindepth 2 -maxdepth 2 -name "$repo_name"); do
		is_repos "$item" || continue
		!!
		// is_model "$item" "$repo_urn" "mirror" || continue
		^^
		// log '$item' "'$item' exists as a duplication of${newline}$repo_urn"
		found_duplicated="$item${found_duplicated:+" ${found_duplicated}"}"
		target_dir="$item"
		break
	done

	[ -n "$found_duplicated" ] || {
		local version_dir="$ver-$rel"
		local new_release_dir="$ver-$rel"
		while [ -d "$base_dir/$repo_name/$new_release_dir" ]; do
			rel_new=$((rel_new + 1))
			new_release_dir="$ver_new-$rel_new"
		done

		target_dir="$base_dir/$repo_name/$new_release_dir/$repo_name"
		# [ -d "$base_dir/$repo_name/$version_dir" ] || {
		[ -d "$target_dir/" ] ||
			// as_own "$base_dir" \mkdir -p "$target_dir/"

		// sync_to_left "$target_dir" "$repo_urn" || {
			# rsync -aqzL "$repo_urn/." \
			#   --exclude="keys" \
			#   --exclude="manifest" \
			#   --delete --delete-excluded \
			#   "$base_dir/$repo_name/$new_release_dir/$repo_name/" || {
			// war 'archive' "'$repo_urn/.' was unsuccessful"
			// die 'check' "'$target_dir' for details"
		}
		# }

		equ "$ver" "$ver_new" && equ "$rel" "$rel_new" ||
		printf '%s %s %s %s %s\n' \
		"$ver_new" \
		"$rel_new" \
		"$repo_alias" "$url" "$reference_type" |
		// as_own "$REPO_ROOT_IMPL" tee "$target_dir/version" > /dev/null
	}
	// is_model "$target_dir" "$repo_urn" &&
		// log 'succeeded' "so far" || // war 'archive' "failed"

	# Heterogeneous mixture file structure. Leads to heavy operations, deprecated
	# The most recent repo backup
	# Leads to heavy operations, deprecated
	# // sync_to_left "$base_dir/$repo_name" "$repo_urn" 1 || {
	#   # rsync -aqzL "$repo_urn/." \
	#   #   --exclude="keys" \
	#   #   --exclude="manifest" \
	#   #   --delete --delete-excluded \
	#   #   "$base_dir/$repo_name/" || {
	#   // war 'archive' "'$repo_urn/.' was unsuccessful"
	#   // die 'check' "'$base_dir/$repo_name' for details"
	# }

	# This release number is an internal reference number until you bring it outside
	# printf '$RS%s$FS%s' "$ver_new" "$rel_new"
	// is_model "$target_dir" "$repo_urn" && return 0 || return 1
}

sync_to_left() {
	_level_2
	local target_dir="$1"
	local source_dir="$2"
	local extaneous_delete_avoid="${3-}"
	// log '$target_dir' "$target_dir"
	// log '$source_dir' "$source_dir"
	// log '$extaneous_delete_avoid' "$extaneous_delete_avoid"

	# Heterogeneous mixture file structure. Leads to heavy operations, deprecated
	# set -- $(// delegate '\n' version_dirs "$source_dir" 1)

	local sync_clause="rsync -aqzL \"$source_dir/.\" --exclude=\".backup\" --exclude=\"keys\" --exclude=\"manifest\""

	# Heterogeneous mixture file structure. Leads to heavy operations, deprecated
	# for ver_rel do
	#   [ ! -z "${ver_rel:+x}" ] || continue
	#   sync_clause="$sync_clause --exclude=\"*/$ver_rel*\""
	# done

	[ ! -z "${extaneous_delete_avoid:+x}" ] ||
		sync_clause="$sync_clause --delete --delete-excluded"

	sync_clause="$sync_clause \"$target_dir/\""

	// log '$sync_clause' "$sync_clause"
	[ -d "$target_dir" ] || // as_own "$REPO_ROOT_IMPL" \mkdir -p "$target_dir"
	# Don't quote $sync_clause
	// / "as_own \"$REPO_ROOT_IMPL\" $sync_clause" &&
	# // as_own "$REPO_ROOT_IMPL" $sync_clause &&
	// as_own "$REPO_ROOT_IMPL" sync || return 1

	# rsync -aqzL "$source_dir/." \
	#   --exclude="keys" --exclude="manifest" \
	#   ` pseudocode --exclude="$repo_ver-$repo_rel" ` \
	#   --delete --delete-excluded "$target_dir/" ||
	# // die 'trasfer' "\"$repo_reference/.\" was unsuccessful"
	# sync

	# // is_model "$target_dir" "$source_dir" && return 0 || return 1
}

maintain() {
	_level_2
	local base_dir="$1"
	local repo_urn="$2"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"

	set -- $(// delegate '\n' version_dirs "$repo_urn")

	local folder
	for folder do
		[ ! -z "${folder:+x}" ] || continue
		local nominal_source_dir="$repo_urn/$folder/$repo_name"
		local source_dir="$nominal_source_dir"
		local execute_source_dir="$source_dir"
		is_repos "$nominal_source_dir" || {
			is_repos "${nominal_source_dir%/*}" || {
				[ -d "${nominal_source_dir%/*}" ] || continue
				source_dir="${nominal_source_dir%/*}"
				# local dir_content="$(// as_own "$source_dir" \ls -1 "$source_dir")"
				# [ ! -z "${dir_content:+x}" ] || {
				! empty "$source_dir" || {
					local content="$( \
					// delegate -- prompt "Delete the empty path?${newline}\
						'$source_dir'${newline} [*|n|ctrl+c]"
					)"
					expr "$content" : '[n|N]\+' > /dev/null || {
						// as_own "$source_dir" \rm -rf "$source_dir"
						[ ! -d "$source_dir" ] || \rmdir "$source_dir"
					}
				}
				continue
			}

			source_dir="${nominal_source_dir%/*}"
			local temp_dir="$(mktemp -p "$KISS_TMPDIR" -d XXXXXX)"
			# archive needs the $repo_name cameing from the second argument
			local temp_repo="$temp_dir/$repo_name"
			\mkdir -p "$temp_repo"
			// war '$nominal_source_dir' "'$nominal_source_dir'${newline}\
				is a supposed to be a source but it is not an valid path${newline}\
				'$source_dir' is selected"
			sync_to_left "$temp_repo" "$source_dir" ||
				// die 'sync_to_left' "failed"
			execute_source_dir="$temp_repo"
		}
		// log '$source_dir' "'$source_dir' will be archived"
		archive "$base_dir" "$execute_source_dir" && {
			// war '$source_dir' "'$source_dir' was archived"

			[ "$execute_source_dir" = "$source_dir" ] ||
				// as_own "" \rm -rf "$execute_source_dir"

			local content="$( \
			// delegate -- prompt "Delete the duplicated packages?${newline}\
				'$source_dir'${newline} \
				It has been backuped in '$base_dir' [*|n|ctrl+c]"
			)"
			expr "$content" : '[n|N]\+' > /dev/null || {
				// as_own "$nominal_source_dir" \rm -rf "$source_dir"
				[ ! -d "$source_dir" ] || \rmdir "$source_dir"
			}
		} || {
			// die '$source_dir' "'$source_dir' was not successfully archived"
		}
	done
}

# $1 $repo_name
manifest_validate() {
	_level_2
	# NOTE: repo_name comes from caller.
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	// log "$repo_name" "checking if manifest valid"

	// log '$EXTRACT_ROOT/$repo_name' "$EXTRACT_ROOT/$repo_name"
	// log 'manifest file' "$db/$repo_name/manifest"

	shift 1

	local tar_manifest="$EXTRACT_ROOT/$repo_name/$db/$repo_name/manifest"
	[ -f "$EXTRACT_ROOT/$repo_name/$db/$repo_name/manifest" ] ||
	// die '$tar_manifest' "'$tar_manifest' does not exist"
	local index=0
	local line
	while read -r line; do
		case "$line" in
			"$sys_ch/") continue ;;
			"$sys_ch"*)
			line="${line#"$sys_ch/$repo_name"}"
			line="$(// delegate -- replace "$line" '/' '>')"
		esac
		[ -e "$EXTRACT_ROOT/$repo_name$line" ] ||
		[ -h "$EXTRACT_ROOT/$repo_name$line" ] || {
			: $((index += 1))
			// log '$tar_manifest' "$(delegate -- format "$index") $line"
			set -- "$@" "$line"
		}
	done < "$tar_manifest"

	for f do
		// log '$f' "$f"
		// die "$repo_name" "manifest contains $# non-existent files"
	done
}

# Return recommended repo source's $result_address
# How to use
# dispose "$repo_name" "$base_dir" "${repo_main%/*}" "${reference%/*}" "$index_global"
# equal to
# dispose "$repo_name" "$base_dir" "$repo_main_dir" "$reference_dir" "$index_global"
dispose() (
	_level_2
	local repo_name="$1"
	repo_name="${repo_name%%@*}"
	local base_dir="$2"
	local repo_base="$base_dir/$repo_name"
	# Operating object
	local repo_main_dir="$3"
	local repo_main="$repo_main_dir/$repo_name"
	# target_source of repo_target -- could be $sys_db, main repos, underconstruction, or EXTRACT_ROOT
	local reference_dir="$4"
	local index_global="$5"
	local result_address=
	# repo_main="$(standardize "$repo_main")"
	local repo_target="$KISS_ROOT/$db/$repo_name"

	is_repos "$repo_target" ||
	// die '$repo_target' "'$repo_target' is not a valid repo"

	local repo_reference="$reference_dir/$repo_name"
	is_repos "$repo_reference" ||
	// die '$repo_reference' "'$repo_reference' is not a valid repo"

	// is_model "$repo_target" "$repo_reference" || {
		equ "$repo_reference" "$repo_target" ||
		ok "${repo_reference##*"${db}"*}" || {
			// war '$repo_reference' \
			"$repo_reference cames from $db"
		}
	} ||
	// die '$repo_reference' \
	"'$repo_reference' is not a model of '$repo_target' or itself"

	! equ "$reference_dir" "$repo_main_dir" ||
	// die '$repo_main_dir' \
	"'$repo_main_dir' is pathologically duplicated"

	# Merged into main process of the function
	# is_repos "$repo_main" || {
	#     # Replace the corrupted one
	#     // war "$repo_main" \
	#         "was discarded due to lack of integrity and being removed by now"
	#     if  # is_repos "$repo_reference" &&
	#         # A redundant but needs attention
	#         # ! equ "$reference_dir" "$repo_main_dir" &&
	#         is_in_main "$repo_reference"; then
	#         # Name/repo_name/key conflicted
	#         // prompt "content"  "Delete the packages? '$repo_main'"
	#         \rm -rf "$repo_main"
	#         result_address="$repo_reference"
	#     else # is_repos "$repo_reference" &&
	#         # ! is_in_main "$repo_reference"; then
	#         rsync -aqzL "$repo_reference/." --exclude="keys" --exclude="manifest" \
	#             --delete --delete-excluded "$repo_main/"
	#         sync
	#         result_address="$repo_main"
	#     fi
	#     printf "$RS%s" "$result_address"
	#     return 0
	# }


	if  # is_repos "$repo_reference" &&
		# ! equ "$reference_dir" "$repo_main_dir" &&
		is_in_main "$repo_reference"; then
		# Reundances
		// log '$repo_main' \
			"$repo_main [$index_global]"
		// log '$repo_reference' "$repo_reference"
		local dispose_target=

		local _left_is_lower=
		local dir_l= ver_l= rel_l= alias_l= url_l= reference_type_l=

		! // || / `pkg_version "$repo_main" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "dir_l=\""$1"\"; ver_l=\""$2"\"; rel_l=\""$3"\"; \
		alias_l=\""$4"\"; url_l=\""$5"\"; reference_type_l=\""$6"\"" }' ||
		printf '%s\n' "return 1"`

		local ver_rel_l="$ver_l-$rel_l"

		local dir_r= ver_r= rel_r= alias_r= url_r= reference_type_r=

		! // || / `pkg_version "$repo_reference" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "dir_r=\""$1"\"; ver_r=\""$2"\"; rel_r=\""$3"\"; \
		alias_r=\""$4"\"; url_r=\""$5"\"; reference_type_r=\""$6"\"" }' ||
		printf '%s\n' "return 1"`

		local ver_rel_r="$ver_r-$rel_r"

		_left_is_lower="$(// left_is_lower "$repo_name" "$ver_rel_l" "$ver_rel_r" "$repo_main_dir" "$reference_dir")"

		[ -z "$_left_is_lower" ] || {
			equ "$_left_is_lower" "0" && {
				dispose_target="$repo_main"
				result_address="$repo_reference"
			} || {
				dispose_target="$repo_reference"
				result_address="$repo_main"
			}
		}

		! is_repos "$dispose_target" ||
		// is_model "$dispose_target" "$base_dir/$repo_name" "mirror" ||
		archive "$base_dir" "$dispose_target"

		#         // prompt "content" "Delete the packages? '$repo_main' \
		# ${newline}It has been backuped in '$base_dir'" &&
		local content="$( \
		// delegate -- prompt "Delete the duplicated packages?${newline}\
			'$repo_main'${newline} \
			It has been backuped in '$base_dir' [*|n|ctrl+c]"
		)"
		# { [ ! -z "${content:+x}" ] &&
		#   expr "$content" : '[n|N]\+' > /dev/null; } ||
		expr "$content" : '[n|N]\+' > /dev/null ||
			\rm -rf "$dispose_target"

	# elif ! is_in_main "$repo_reference" &&
	#     ! is_model "$repo_main" "$repo_reference"; then
	else
		# is_model "$repo_main" "$repo_reference" || {

		! is_repos "$repo_main" ||
		// is_model "$repo_main" "$base_dir/$repo_name" "mirror" ||
		archive "$base_dir" "$repo_main"

		# rsync -aqzL "$repo_reference/." \
		#   --exclude="keys" --exclude="manifest" \
		#   --exclude="$repo_ver-$repo_rel" \
		#   --delete --delete-excluded "$repo_main/" ||
		# // die 'trasfer' "\"$repo_reference/.\" was unsuccessful"
		# sync

		// sync_to_left "$repo_main" "$repo_reference" ||
			// die 'trasfer' "\"$repo_reference/.\" was unsuccessful"


		// log "${repo_name} imported to" "$repo_main"

		# }
		result_address="$repo_main"
	fi

	printf "$RS%s" "$result_address"
)

# $1 repo_urn : package repo url/uri
conflicts() {
	_level_2
	# Check to see if a package conflicts with another.
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
		repo_urn="$(// delegate -- repo_trace "$repo_name")"

	// log "$repo_name" "checking for package conflicts"

	local manifest_files="$( \
		// delegate -- slot_aquire "$repo_name" "manifest-files")"
	local found_conflicts="$( \
		// delegate -- slot_aquire "$repo_name" "found-conflicts")"
	local tar_manifest="$EXTRACT_ROOT/$repo_name/$db/$repo_name/manifest"
	[ -f "$tar_manifest" ] || // die "$tar_manifest" "does not exist"
	[ -s "$tar_manifest" ] || // die '$tar_manifest' "'$tar_manifest' is empty"
	# Filter the tarball's manifest and select only files. Resolve all
	# symlinks in file paths as well.
	while read -r file; do case "$file" in *[!/])
		# // resolve_path "$file"
		local rpath="$(// delegate -- resolve_path "$file")"
		printf '%s\n' "$rpath"
	esac done < "$tar_manifest" > "$manifest_files"

	[ -s "$manifest_files" ] || // die '$tar_manifest' "'$tar_manifest' is empty"

	cd "$EXTRACT_ROOT/$repo_name"

	set +f
	# All installed packages manifest
	set -f "$KISS_ROOT/$db"/*/manifest

	# Remove the current package from the manifest list.
	local complement="$( \
		// delegate -- replace " $* " " " " $KISS_ROOT/$db/$repo_name/manifest ")"

	# Intentional, globbing disabled.
	# shellcheck disable=2046,2086
	set -- $complement
	# // log '$@' "$(esceval "$@")"
	# Return here if there is nothing to check conflicts against.
	! equ "$#" 0 || return 0

	# Store the list of found conflicts in a file as we'll be using the
	# information multiple times. Storing things in the cache dir allows
	# us to be lazy as they'll be automatically removed on script end.
	grep -Fxf "$manifest_files" -- "$@" 2>/dev/null > "$found_conflicts" || :

	local safe=
	# Enable alternatives automatically if it is safe to do so.
	# This checks to see that the package that is about to be installed
	# doesn't overwrite anything it shouldn't in '$KISS_ROOT/$db'.
	grep -q ":$sys_db/" "$found_conflicts" || safe=1

	[ -s "$found_conflicts" ] || return 0

	// war '$found_conflicts' "$found_conflicts"
	local index=0
	while read -r line; do
		: $((index += 1))
		// debug '$found_conflicts' "$(delegate -- format "$index") $line" &
	done < "$found_conflicts"

	[ -z "${KISS_CHOICE+x}" ] || ! equ "$safe" 1 || {
		// log "Package '$repo_name' conflicts with another package" "!>"
		// log "Run 'KISS_CHOICE= kiss i $repo_name' to add conflicts" "!>"
		// die "as alternatives." "!>"
	}

	# [ -z "${KISS_CHOICE+x}" ] && equ "$safe" 1 && [ -s "$found_conflicts" ]
	# This is a novel way of offering an "alternatives" system.
	# It is entirely dynamic and all "choices" are created and
	# destroyed on the fly.
	#
	# When a conflict is found between two packages, the file
	# is moved to a directory called "choices" and its name
	# changed to store its parent package and its intended
	# location.
	#
	# The package's manifest is then updated to reflect this new location.
	#
	# The 'kiss alternatives' command parses this directory and
	# offers you the CHOICE of *swapping* entries in this
	# directory for those on the filesystem.
	#
	# The alternatives command does the same thing we do here,
	# it rewrites manifests and moves files around to make this work.
	#
	# Pretty nifty huh?
	local source
	while IFS=: read -r _ source; do
		source="$(standardize "$source")"
		local nominal_target_dir="${source%/*}"
		local real_source="$PWD$source"
		local db_target="$PWD/$db/$repo_name"
		// debug 'conflict source' "$real_source" &
		# Create the "choices" directory inside of the tarball.
		# This directory will store the conflicting file.
		mkdir -p "$PWD/$cho_db"

		# Construct the file name of the "db" entry of the
		# conflicting file. ($repo_name>usr>bin>ls)
		local fake_route="$(// delegate -- replace "$source" '>' '/')"

		# [ -d "$real_source" ] || // mkdir -p "$real_source"
		[ -e "$real_source" ] ||
		[ -h "$real_source" ] || {
			// war '$real_source' "'$real_source' does not exist"
			continue
		}
		# rsync -aqz --rsync-path="mkdir -p ${real_source%/*} && rsync" \
		#     "$source" "$real_source" ||
		# // die 'rsync' "failed"

		# Move the conflicting file to the choices directory
		# and name it according to the format above.
		[ -z "${real_source##*"$db_target"*}" ] ||
		mv -f "$real_source" "$PWD/$cho_db/$repo_name$fake_route" 2>/dev/null || {
			// log "File must be in $nominal_target_dir and not a symlink to it"
			// die "This usually occurs when a binary is installed to /sbin" \
				"instead of /usr/bin (example)"
		}
	done < "$found_conflicts"

	// log "$repo_name" "converted all conflicts to choices (kiss a)"

	# Rewrite the package's manifest to update its location
	# to its new spot (and name) in the choices directory.
	// pkg_manifest "$repo_urn" "$EXTRACT_ROOT" & // progress "$repo_name" "$!" "manifest checking"
}

# $1 repo_urn : package path
pkg_install() {
	_level_2
	local repo_urn="$1"
	local action="install"
	// cue 'install' "$repo_urn"

	# Install a built package tarball.
	#
	# Package installation works similarly to the method used by Slackware in
	# some of their tooling. It's not the obvious solution to the problem,
	# however it is the best solution at this given time.
	#
	# When an installation is an update to an existing package, instead of
	# removing the old version first we do something different.
	#
	# The new version is installed overwriting any files which it has in
	# common with the previously installed version of the package.
	#
	# A "diff" is then generated between the old and new versions and contains
	# any files existing in the old version but not the new version.
	#
	# The package manager then goes and removes these files which leaves us
	# with the new package version in the file system and all traces of the
	# old version gone.
	#
	# For good measure the package manager will then install the new package
	# an additional time. This is to ensure that the above diff didn't contain
	# anything incorrect.
	#
	# This is the better method as it is "seamless". An update to busybox won't
	# create a window in which there is no access to all of its utilities.
	local repo_ver repo_rel repo_dir
	local tar_file
	local repo_name
	local target_source=
	local format=
	local reference_type=
	# Install can also take the full path to a tarball. We don't need to check
	# the repository if this is the case.
	case $repo_urn in
		*.tar.*)
			// log 'tar $repo_urn' "$repo_urn"
			tar_file="$repo_urn"
			format="$(// delegate -- repo_type "$repo_urn")"
			# / "IFS=$(printf '%b' "$FS") read -r \
			#   format reference_type \
			#   << $(// here_doc -- repo_type "$repo_urn")" \
			#   > /dev/null || { // die 'repo_type' "failed"; exit 1; }
			// log '$format' "$format"

			[ -f "$tar_file" ] ||
				// die '$tar_file' "File '${tar_file:+"${tar_file} "}'does not exist"

			repo_name="${repo_urn##*/}"
			repo_name="${repo_name%@*}"
			// log '$repo_name' "$repo_name"
			;;

		*)
			// log '$repo_urn' "$repo_urn"

			repo_urn="$(standardize "$repo_urn")"
			repo_name="${repo_urn##*/}"
			is_repos "$repo_urn" ||
				repo_urn="$(// delegate -- repo_trace "$repo_name")"

			# Have to permit $db
			# [ -z "${repo_urn##*"${db}"*}" ] ||
			! is_repos "$repo_urn" || target_source="$repo_urn"

			// tar_file="$(// delegate -- pkg_cache "$repo_urn")"
			ok "$tar_file" || {  # // die "$repo_name" "not yet built"
				{ action=c; ! // pkg_checksum  "$repo_urn" 2>&1; } ||
				{ action=b; ! // build_all "$deps" "$makedeps" "$repo_urn" 2>&1; } ||
				// tar_file="$(// delegate -- pkg_cache "$repo_urn")"
				ok "$tar_file" || // die "$repo_name" "build failed"
			}
			;;
	esac

	repo_target="$KISS_ROOT/$db/$repo_name"

	# Will do pkg_clear
	# // pkg_dirs "$action" "$repo_name"

	// log '$repo_name' "$repo_name"
	// log '$repo_target' "$repo_target"
	# For binary extraction
	local extract_dir="$EXTRACT_ROOT/$repo_name"
	local extract_db_dir="$extract_dir/$db"
	local pkg_dir="$PKG_ROOT/$repo_name"
	local pkg_db_dir="$pkg_dir/$db"
	// log '$extract_dir' "$extract_dir"

	empty "$extract_dir" ||
	# find "$extract_dir" -mindepth 1 -delete
	# for item in $(find "$extract_dir" -type d -mindepth 1 -maxdepth 1); do
	for item in $(// as_own "$EXTRACT_ROOT" \
		find "$extract_dir" -mindepth 1 -maxdepth 1); do
		# choices folder items won't accept removing by normal users even it's is owned by the normal user
		# [ ! -e "$item" ] || [ ! -h "$item" ] ||
		// as_usr "root" \rm -rf "$item"
	done

	empty "$BUF_ROOT/$repo_name" ||
	// as_own "$BUF_ROOT" find "$BUF_ROOT/$repo_name" -mindepth 1 -delete

	// mkcd "$extract_dir" "$extract_db_dir/$repo_name" "$pkg_db_dir/$repo_name" ||
		// die 'mkcd' "failed"

	# The tarball is extracted to a temporary directory where its contents are
	# then "installed" to the filesystem. Running this step as soon as possible
	# allows us to also check the validity of the tarball and bail out early
	# if needed.

	ok "$tar_file" ||
	// die '$tar_file' "${tar_file:+"${tar_file} "}not found [local]"

	// log '$tar_file' "$tar_file [local]"

	// decompress "$tar_file" | tar xf -

	local repo_dir= repo_ver= repo_rel= repo_alias= repo_url= reference_type=

	! // || / `pkg_version "$repo_name" "" "" "$extract_db_dir" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_dir=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"; \
	repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`

	# Naively assume that the existence of a manifest file is all that
	# determines a valid KISS package from an invalid one. This should be a
	# fine assumption to make in 99.99% of cases.
	local tar_manifest="$extract_db_dir/$repo_name/manifest"
	// log '$tar_manifest' "$tar_manifest"
	[ -f "$tar_manifest" ] ||
		// as_own "$extract_dir" touch "$tar_manifest"
		# // die '$tar_manifest' "Not a valid KISS package. \"$tar_manifest\" does not exist"

	# Intended behavior.
	# shellcheck disable=2030,2031
	[ -n "${KISS_FORCE+x}" ] || {
		// manifest_validate "$repo_name" & // progress "$repo_name" "$!" "manifest validating"
		// installable "$repo_name" "$extract_db_dir/$repo_name/depends"
	}

	[ -z "${repo_urn:+x}" ] ||
	[ -n "${repo_urn##*".tar."*}" ] || {

		if [ -d "$repo_dir" ]; then
			repo_urn="$repo_dir/$repo_name"
		else
			# repo_urn="$pkg_db_dir/$repo_name"
			repo_urn="$extract_db_dir/$repo_name"
		fi
		// log '$repo_urn' "$repo_urn"
		# [ -z "${repo_urn##*"${db}"*}" ] ||
		! is_repos "$repo_urn" || target_source="$repo_urn"
	}

	[ ! -z "$format" ] || {
		format="$(// delegate -- repo_type "$repo_urn")"
		# / "IFS=$(printf '%b' "$FS") read -r \
		#   format reference_type \
		#   << $(// here_doc -- repo_type "$repo_urn")" \
		#   > /dev/null || { // die 'repo_type' "failed"; exit 1; }
	}
	// log '$format' "$format"

	[ -d "$target_source" ] ||
		// die '$target_source' "dir \"$target_source\" does not exist"

	// log '$target_source' "$target_source"
	// log '$KISS_ROOT' "$KISS_ROOT"
	// log '$KISS_ROOT/$db' "$KISS_ROOT/$db"
	# $VOLATILE/extract
	// log '$EXTRACT_ROOT' "$EXTRACT_ROOT"
	# $HOME/.cache/kiss/proc/pkg
	// log '$PKG_ROOT' "$PKG_ROOT"
	// log '$db' "$db"
	// log '$repo_name' "$repo_name"
	// log '$pkg_db_dir/$repo_name' "$pkg_db_dir/$repo_name"
	// log '$extract_db_dir/$repo_name' "$extract_db_dir/$repo_name"

	local repo_dir= repo_ver= repo_rel= repo_alias= repo_url= reference_type=

	! // || / `pkg_version "$target_source" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_dir=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"; \
	repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`


	# https://www.shellcheck.net/wiki/SC2316
	// log '$repo_ver' "$repo_ver"
	// log '$repo_rel' "$repo_rel"
	// log '$repo_dir' "$repo_dir"

	// log '$PWD' "$PWD"

	# arg1: pre-install
	# arg2: package name
	# arg3: path to extracted package
	// run_hook     pre-install "$repo_name" "$extract_dir"
	// run_hook_pkg pre-install "$repo_name" "$repo_ver" "$repo_rel" "$repo_dir"

	// conflicts "$repo_name" & // progress "$repo_name" "$!" "conflicts checking"

	// log "$repo_name" "installing package (${tar_file##*/})"


	local manifest_diff="$(// delegate -- slot_aquire "$repo_name" "manifest-diff")"
	// log '$manifest_diff' "$manifest_diff"

	# If the package is already installed (and this is an upgrade) make a
	# backup of the manifest and etcsums files.
	[ ! -f  "$repo_target/manifest" ] || {
		local manifest="$( \
			// delegate -- slot_push "$repo_name" \
				"$repo_target/manifest")"
		// log '$manifest' "$manifest"

		# Generate a list of files which exist in the currently installed manifest
		# but not in the newer (to be installed) manifest.
		# grep -vFxf "$tar_manifest" "$manifest" > "$manifest_diff" 2>/dev/null ||
		grep -vFxf "$tar_manifest" "$manifest" \
			> "$manifest_diff" 2>/dev/null || :
		# // war 'grep' "'$manifest_diff' exception occurred"
	}
	# Reverse the manifest file so that we start shallow and go deeper as we
	# iterate over each item. This is needed so that directories are created
	# going down the tree.
	local manifest_reverse="$( \
	// delegate -- slot_aquire "$repo_name" "manifest-reverse")"
	sort "$tar_manifest" > "$manifest_reverse"

	# Block being able to abort the script with Ctrl-C during installation.
	# Removes all risk of the user aborting a package installation leaving
	# an incomplete package installed.
	// trap_off    # trap '' INT

	local overwrite="$repo_urn -z $extract_dir < $manifest_reverse"
	local remove="< $manifest_diff"
	local verify="$repo_urn -e $extract_dir < $manifest_reverse"
	[ ! -f "$repo_target/etcsums" ] || {
		local etcsums_clone="$( \
			// delegate -- slot_push "$repo_name" "$repo_target/etcsums")"
		// log '$etcsums_clone'  "$etcsums_clone"
		exec 3< "$etcsums_clone"
		overwrite="$overwrite 3< $etcsums_clone"
		remove="$remove 3< $etcsums_clone"
		verify="$verify 3< $etcsums_clone"
	}

	// log '$overwrite' "$overwrite"
	// log '$remove'    "$remove"
	// log '$verify'    "$verify"
	{
		# Install the package's files by iterating over its manifest.
		{
			/ // install_files $overwrite &&

		# This is the aforementioned step removing any files from the old
			# version of the package if the installation is an update. Each file
			# type has to be specially handled to ensure no system breakage occurs.
			/ // remove_files $remove &&

		# Install the package's files a second time to fix any mess caused by
			# the above removal of the previous version of the package.
			/ // install_files $verify;

		} || {
			// clean_all "i" "$repo_name"    # clean_all
			// war "$repo_name" "Failed to install package"
			// die "$repo_name" "The file system is currently in a dirty state and requires manual maintenance"
		}
	} & install_id=$!
	// progress "$repo_name" "$install_id" "installing"

	# Reset 'trap' to its original value. Installation is done so we no longer
	# need to block 'Ctrl-C'.
	// trap_on "install" "$repo_name" # trap clean_all EXIT INT

	# arg1: post-install
	# arg2: package name
	# arg3: path to installed package database
	// run_hook_pkg post-install "$repo_name" "$repo_ver" "$repo_rel" "$repo_dir"
	// run_hook     post-install "$repo_name" "$extract_dir"


	equ "$repo_target" "$target_source" || {
		// is_model "$repo_target" "$target_source" "mirror" ||
		# Passing array to --exclude won't work on POSIX shell

		// sync_to_left "$repo_target" "$target_source" ||
		// die 'trasfer' "\"$target_source/.\" was unsuccessful"

		# // as_own "$REPO_ROOT_IMPL/" \
		#   rsync -aqzL "$target_source/." \
		#   --exclude="keys" \
		#   --exclude="manifest" \
		#   --exclude="$repo_ver-$repo_rel" \
		#   --delete --delete-excluded "$repo_target/" && // as_own "$REPO_ROOT_IMPL/" sync

		// is_model "$repo_target" "$target_source" "mirror" ||
		// die '$repo_target' "${repo_target:+"${repo_target} "}is neither a mirror nor a copy of itself"
	}

	[ -n "${REPO_ROOT:+x}" ] || // die '$REPO_ROOT' "$REPO_ROOT"
	[ -n "${KISS_REPO:+x}" ] || // die '$KISS_REPO' "$KISS_REPO"
	[ -d "$KISS_REPO" ] || // die '$KISS_REPO' "'$KISS_REPO' directory does not exist"

	# package repo might be in $sys_db / main repo / others
	# We want to create the relation between $sys_db and main repo
	# Serial key occupied : value identical : key in main repo
	#   1      0            check checksum?            0          # Key global conflicts free. Double keys might have the same repo
	#   1      0            check checksum?            0          # Copy $repo_target to main repo
	#   2      1                   1                   1          # Keep it: target_source="$repo"
	#   3      1                   1                   0          # Copy $repo_target to main repo
	#   4      1                   0                   0          # To invent a wheel? Auto version and link to it? "archive", "choices"?

	# Move to pick_up? No, because you don't know if it will be built
	# [ -n "${target_source##*${db}*}" ] || {

	# target_source is in $sys_db
	local index_global=-1
	local condidates=

	# local base_dir="$KISS_REPO/base"
	local base_dir="$REPO_BASE"
	local repo_base="$base_dir/$repo_name"
	[ -d "$repo_base" ] || // as_own "$KISS_ROOT/" \mkdir -p "$repo_base"

	# Will include submodules
	# Search outside $sys_db
	# for repo_main in $(find "$KISS_REPO" \( -type d -o -type l \) \( \
	#             -path "*/modules" \
	#             -o -path "*/underconstruction" \
	#             -o -path "*/.git" \
	#             \) -prune -o -name "${repo_name}" -print); do
	#             # -o -path "*/base" \

	# In system evironment main repo list
	# Looks like:
	# $KISS_REPO/system/crust
	is_in_main "$target_source" || {
		local repo_main
		local main_list="$(// delegate '\n' repo_trace "$repo_name" "pure" "-d" "$KISS_PATH")"
		local index=0

		for repo_main in $main_list; do : $((index += 1)); done

		local repo_slot

		[ "$index" -gt "1" ] && {
			set -- $(// delegate '\n' version_priority "left_is_lower" "$repo_name" $main_list)
			repo_slot="$1"
			shift 1
			for repo do
				archive "$base_dir" "$repo"
			done
		}

		[ "$index" -eq "1" ] && repo_slot="$repo_main"

		[ "$index" -lt "1" ] && repo_slot="$KISS_REPO/extra/$repo_name"

		target_source="$(// delegate -- dispose \
			"$repo_name" \
			"$base_dir" \
			"${repo_slot%/*}" \
			"${target_source%/*}" \
			"$index_global")"

		true ||
		# REPO_DIR does not make sence at this moment
		# null "$REPO_DIR" || main_list="${REPO_DIR}/$repo_name $main_list"
		for repo_main in $( \
			// delegate '\n' repo_trace "$repo_name" "pure" "-d" "$KISS_PATH"); do
			index_global="$((index_global + 1))"
			[ -n "${repo_main:+x}" ] || continue
			[ "${repo_main##*/}" = "$repo_name" ] || continue
			ok "${repo_main##*"${repo_base}"*}" ||
			// die '$repo_main' "$repo_main [$index_global]"
			// log '$repo_main' "$repo_main [$index_global]"
			// log '$target_source' "$target_source"

			target_source="$(// delegate -- dispose \
				"$repo_name" \
				"$base_dir" \
				"${repo_main%/*}" \
				"${target_source%/*}" \
				"$index_global")"

			ok "${target_source##*"${repo_base}"*}" ||
				// die '$target_source' "$target_source [$index_global]"

			! // is_in_main "$target_source" &&
			# $repo_main without being removed
			[ -d "$repo_main" ] || continue
			#
			# // prompt "content" "What!!! The following code was deprecated"
			#
			local content="$( \
			// delegate -- prompt "What!!! The following code should be deprecated.${newline}\
				Unless you modified repo identicals manually")"
			# continue
			local ver rel dir
			# Guaranteed performance with step-by-step filtering
			diff -bwurB "$repo_target/version" "$repo_main/version" > /dev/null 2>&1 || continue
			diff -bwurB "$repo_target/build" "$repo_main/build" > /dev/null 2>&1 || continue
			! // is_model "$repo_target" "$repo_main" "mirror" || {
				# First run
				# If is_model == true, and target_source is not in main repo list, get it

				local dir= ver= rel= repo_alias= repo_url= reference_type=

				! // || / `pkg_version "$repo_main" |
					awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
				END { print "dir=\""$1"\"; ver=\""$2"\"; rel=\""$3"\"; \
				repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
				printf '%s\n' "return 1"`

				// log "${repo_name}" "$repo_main [$ver-$rel] [$dir/$repo_name]"
				ok "${repo_main##*"${repo_base}"*}" ||
					// die '$repo_main' "$repo_main [$index_global]"
				target_source="$repo_main"
				continue
			}

			# key matched/conflicts repos has different content with target_source
			# Key conflicts and content does not match / inconsistency
			# First run
			target_source="$(// delegate -- dispose \
				"$repo_name" \
				"$base_dir" \
				"${repo_main%/*}" \
				"${repo_target%/*}" \
				"$index_global")"
			ok "${repo_main##*"${repo_base}"*}" ||
			// die '$repo_main' "$repo_main [$index_global]"

			// log "${repo_name} imported" "$repo_main [$ver-$rel]"
		done
	}

	[ -d "$repo_target" ] &&
	// is_model "$repo_target" "$target_source" ||
	equ "$repo_target" "$target_source" ||
	// die '$repo_target' "${repo_target:+"${repo_target} "}is demaged"

	# }

	true ||
	# package repo source is in other paths or just in sys_db
	// is_in_main "$target_source" ||
	// is_in_base "$target_source" || {
		// log "$repo_name imported" "$KISS_REPO/extra/$repo_name"
		# Dead link
		[ -d "$KISS_REPO/extra/$repo_name" ] ||
		// as_own "$KISS_REPO/extra/$repo_name" \
			\rm -f "$KISS_REPO/extra/$repo_name"

		// sync_to_left "$KISS_REPO/extra/$repo_name" "$repo_target" ||
			// die 'trasfer' "\"$repo_target/.\" was unsuccessful"

		# // as_own "$KISS_ROOT/" \
		# rsync -aqzL "$repo_target" "$KISS_REPO/extra/"
		# // as_own "$KISS_ROOT/" sync

		# package repo is in main repo
		target_source="$KISS_REPO/extra/$repo_name"
	}

	// is_in_main "$target_source" ||
	// is_in_base "$target_source" ||
	// die '$target_source' "${target_source:+"${target_source} "}is weird imported"

	// log '$repo_target' "$repo_target"
	// log '$target_source' "$target_source"

	# # Keys design begin
	# local repo_source_encoded="$(// delegate -- encode "$target_source" "KISS_REPO" "$KISS_REPO")"
	# repo_source_encoded="$(standardize "$repo_source_encoded")"
	# repo_dir_encoded="${repo_source_encoded%/*}"
	# // log '$repo_dir_encoded' "$repo_dir_encoded"
	# // log '$repo_source_encoded' "$repo_source_encoded"
	# # Keys design end

	printf '%s %s %s %s %s\n' "$repo_ver" "$repo_rel" "$repo_alias" \
		"$repo_url" "$reference_type" |
		// as_own "$target_source/version" tee "$target_source/version" > /dev/null
	printf '%s %s %s %s %s\n' "$repo_ver" "$repo_rel" "$repo_alias" \
		"$repo_url" "$reference_type" |
		// as_own "$repo_target/version" tee "$repo_target/version" > /dev/null

	local target_ancestor=
	local ancester_list=
	ancestors "ancester_list" "$repo_urn" "$@"
	for target_ancestor in $ancester_list; do
		break
	done

	# # Keys design begin
	# [ -z "${USE_KEYS:+x}" ] || {
	#   local index_key=0
	#   local version_list=
	#   local ifs="$IFS"
	#   local IFS="$(printf '%b' "$FS")"
	#   [ ! -s "$repo_target/keys" ] ||
	#   while IFS=$' ' read -r ver rel repo; do
	#       null "$ver" || null "$rel" || null "$repo" ||
	#       { [ "$ver" = "$repo_ver" ] && [ "$rel" = "$repo_rel" ] && [ "$repo" = "$target_source" ]; } || {
	#           local found=0
	#           for item in $version_list; do
	#               [ "$item" = "${ver} ${rel} ${repo}" ] || continue
	#               found=1
	#               break
	#           done
	#           equ "$found" "1" || {
	#               length_trim "ver" "$LENGTH_VER"
	#               length_trim "rel" "$TABSTOP"
	#               local color_child_origin="$color_child"
	#               IFS="$ifs"
	#               # // log "$(printf "%-${TABSTOP}s %-${LENGTH_VER}s" "$index_key" "$ver")" \
	#               # "$(printf "%-${TABSTOP}s %-2s %s" "$rel" "" "$repo")"
	#               // density_out "$repo" "${target_ancestor-}" "$index_key"
	#               IFS="$(printf '%b' "$FS")"
	#               color_child="$color_child_origin"
	#               version_list="$version_list${ver} ${rel} ${repo}${IFS}"
	#           }
	#       }
	#       : $((index_key += 1))
	#   done < "$repo_target/keys"
	#   # No \n at the end
	#   version_list="$version_list${repo_ver} ${repo_rel} ${repo_source_encoded}"
	#   : > "$repo_target/keys"
	#   for item in $version_list; do
	#       printf "%s\n" "$item" >> "$repo_target/keys"
	#   done
	#   IFS="$ifs"

	#   [ -f "$repo_target/keys" ] || // die '$repo_target/keys' "\"$repo_target/keys\" should exist but not"
	#   local last_sentence="$(// delegate -- valid_tail "$repo_target/keys")"
	#   [ -n "${last_sentence:+x}" ] || // die '$repo_target/keys' "keys file \"$repo_target/keys\" is invalid"
	#   IFS=$' ' read -r _ver _rel _repo_source \
	#       < <(printf '%s\n' "$last_sentence" | grep "$repo_ver" | grep "$repo_rel") > /dev/null || {
	#       cat "$repo_target/keys"
	#       // die '$repo_target/keys' "query failed on \"$repo_target/keys\""
	#   }
	# }
	# # Keys design end

	// log '$repo_name' "$repo_name"

	local _dir= _ver= _rel= _alias= _url= _reference_type=

	! // || / `pkg_version "$repo_name" "" "-d" "$KISS_ROOT/$db" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "_dir=\""$1"\"; _ver=\""$2"\"; _rel=\""$3"\"; \
	_alias=\""$4"\"; _url=\""$5"\"; _reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`


	[ "$repo_ver" = "$_ver" ] && [ "$repo_rel" = "$_rel" ] ||
	// die '$repo_name' "$repo_name"

	// density_out "$repo_target"   "${target_ancestor-}" "0"
	// density_out "$target_source" "${target_ancestor-}" "1"

	// cue "$repo_name" "Installed successfully"
}

removable() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	set -- "$repo_name"
	# Check if a package is removable and die if it is not.
	# A package is removable when it has no dependents.
	// log "$repo_name" "checking if package removable"

	cd "$KISS_ROOT/$db"
	set +f
	repo_name="$1"
	// log '$repo_name' "$repo_name"

	[ -n "${KISS_FORCE+x}" ] ||
	! grep -lFx -- "$repo_name" */depends ||
		// die "$repo_name" "Not removable, has dependents"

	set -f
	cd "$OLDPWD"
}

# $1 repo_urn : package repo url/uri
# could be subshell function before local version
pkg_remove() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	local repo_target="$KISS_ROOT/$db/$repo_name"
	// log '$repo_target' "$repo_target"
	# Remove a package and all of its files. The '/etc' directory is handled
	# differently and configuration files are *not* overwritten.
	[ -d "$repo_target" ] || // die '$repo_name' "'$repo_name' is not installed"

	# Intended behavior.
	# shellcheck disable=2030,2031
	[ -n "${KISS_FORCE+x}" ] || // removable "$repo_name"

	# Block being able to abort the script with 'Ctrl-C' during removal.
	# Removes all risk of the user aborting a package removal leaving an
	# incomplete package installed.
	# trap '' INT
	// trap_off

	local repo_dir= repo_ver= repo_rel= repo_alias= repo_url= reference_type=

	! // || / `pkg_version "$repo_target" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_dir=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"; \
	repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`

	# arg1: pre-remove
	# arg2: package name
	# arg3: path to installed database
	// run_hook_pkg pre-remove "$repo_name" "$repo_ver" "$repo_rel" "$repo_dir"
	// run_hook     pre-remove "$repo_name" "$repo_target"

	// log '$repo_name' "$repo_name"
	// log "removing package" "$repo_name"
	# Make a backup of any etcsums if they exist.
	[ ! -f "$repo_target/manifest" ] || {
		[ ! -s "$repo_target/etcsums" ] &&
		// remove_files < "$repo_target/manifest" || {
			local etcsums_clone="$( \
				// delegate -- slot_push "$repo_name" "$repo_target/etcsums")"
			// remove_files < "$repo_target/manifest" 3< "$etcsums_clone"
		}
	}

	// as_own "$KISS_ROOT/" \rm -rf "$repo_target"

	# Reset 'trap' to its original value. Removal is done so
	# we no longer need to block 'Ctrl-C'.
	# trap '// clean_all "r" "$repo_name"' EXIT INT
	// trap_on "r" "$repo_name"

	// log "$repo_name" "removed successfully"
}

manifest_replace() {
	_level_2
	local repo_name="$1"
	local found_line="$2"
	local replace_line="$3"
	# Replace the matching line in the manifest with the desired replacement.
	# This used to be a 'sed' call which turned out to be a little
	# error-prone in the some cases. This new method is a tad slower but ensures
	# we never wipe the file due to a command error.
	local manifest_replace_buffer="$( \
		// delegate -- slot_aquire "$repo_name" "manifest-replace-${2##*/}")"

	while read -r line; do
		! equ "$line" "$found_line" || line="$replace_line"

		printf '%s\n' "$line"
	done < "$KISS_ROOT/$db/$repo_name/manifest" | sort -r > "$manifest_replace_buffer"

	mv -f "$manifest_replace_buffer" "$KISS_ROOT/$db/$repo_name/manifest"
}

# Usage:
# file_activate "llvm" "/usr/bin/llvm-ar"
file_activate() {
	_level_2
	// debug '$#' "$#" &
	// debug '$@' "$(esceval "$@")" &

	local repo_activate="$1"
	[ -d "$KISS_ROOT/$db/$repo_activate" ] ||
		// die '$KISS_ROOT/$db/$repo_activate' "'$KISS_ROOT/$db/$repo_activate' not found"

	local target="$2"
	target="$(standardize "$target")"

	# local right_no_leading_slash="$target"
	# [ "$(expr substr "$target" 1 1)" != "/" ] ||
	# 	right_no_leading_slash=="${target#/}"

	# [ -f "$KISS_ROOT/${target#/}" ] ||
	# 	// war '$KISS_ROOT/${target#/}' "'$KISS_ROOT/${target#/}' does not exist"

	local repo_in_use="$3"
	# local repo_not_in_use="$4"

    # local repo_in_use="$(// delegate -- manifest_repo "$target")"
	# # Might be a list?
	# local repo_not_in_use=
	# [ ! -z "$repo_in_use" ] ||
	# [ ! -f "$KISS_ROOT/${target#/}" ] || {
	# 	set +f
	# 	set -f -- "$KISS_ROOT/$db"/*/manifest
	# 	local target_choice="$(// delegate -- replace "$target" '>' '/')"
	# 	# local file_contains_target_choice="$(// as_own "$KISS_ROOT/" grep -lF "$target_choice" "$@" 2>/dev/null)"
	# 	local file_contains_target_choice="$(grep -lF "$target_choice" "$@" 2>/dev/null)"
	# 	// log '$file_contains_target_choice' "$file_contains_target_choice"
	# 	repo_not_in_use="${file_contains_target_choice%/manifest}"
	# 	repo_not_in_use="${repo_not_in_use##*/}"
	# 	[ -z "$repo_in_use" ] &&
	# 	[ ! -z "$repo_not_in_use" ] ||
	# 	// war '$target' "File '$KISS_ROOT/${target#/}' exists on filesystem${newline}\
	# 	but isn't owned by the repos in use"
	# }

	# [ -z "$repo_not_in_use" ] ||
	# [ ! -z "$repo_in_use" ] ||
	# // war '$repo_not_in_use' "$repo_not_in_use" &

	# [ ! -z "$repo_in_use" ] || {
	# 	// war '$repo_in_use' "'$repo_in_use', nothing to do" &
	# 	return 0
	# }

	[ ! -z "$repo_activate" ] ||
	// log '$repo_activate' "$repo_activate" &

	# [ ! -z "$repo_in_use" ] ||
	# [ "$repo_not_in_use" = "$repo_activate" ] ||
	# [ -z "$repo_not_in_use" ] ||
	# {
	# 	// war '$repo_not_in_use != $repo_activate' "'$repo_not_in_use' != '$repo_activate',${newline}\
	# 	use '$repo_not_in_use' '$target' to activate it" &
	# 	return 0
	# }

	[ "$repo_in_use" != "$repo_activate" ] || {
		// war '$repo_in_use = $repo_activate' "'$repo_in_use' = '$repo_activate', nothing to do" &
		return 0
	}

	# [ -z "$repo_not_in_use" ] ||
	# [ -d "$KISS_ROOT/$db/$repo_not_in_use" ] ||
	# 	// die '$KISS_ROOT/$db/$repo_not_in_use' "'$KISS_ROOT/$db/$repo_not_in_use' not found"
	# Swap between package alternatives.
	[ -z "$repo_in_use" ] ||
	[ -d "$KISS_ROOT/$db/$repo_in_use" ] ||
		// die '$KISS_ROOT/$db/$repo_in_use' "'$KISS_ROOT/$db/$repo_in_use' not found"

	[ -z "$repo_in_use" ] || {
		local repo_in_use_choice="$(// delegate -- replace "$repo_in_use$target" '>' '/')"
		// debug '$repo_in_use_choice' "$repo_in_use_choice" &
	}

	local repo_activate_choice="$(// delegate -- replace "$repo_activate$target" '>' '/')"
	// debug '$repo_activate_choice' "$repo_activate_choice" &

	local activate_path="$KISS_ROOT/$cho_db/$repo_activate_choice"
	[ -h "$activate_path" ] ||
	[ -f "$activate_path" ] || {
		# [ -h "$activate_path" ] ||
		# Here are some symbollinks point to local address that might not exist
		# activate_path="$(readlink -fn "$activate_path")"
		# [ -f "$activate_path" ] ||
		// die "$activate_path" "alternative to '$repo_in_use' doesn't exist"
	}

	[ -z "$repo_in_use" ] ||
	# Based on above centences, only files need to be copied/backuped
	if [ -f "$activate_path" ]; then

		// log "$activate_path" "gonna cover '$target'" &

		# Convert the current owner to an alternative and rewrite its manifest
		# file to reflect this.
		# // as_own "$KISS_ROOT/" cp -Pf "$KISS_ROOT/${target#/}" "$sys_ch/$repo_in_use>${target#*>}"
		[ ! -f "$KISS_ROOT/${target#/}" ] ||
		// as_own "$KISS_ROOT/" cp -Pf "$KISS_ROOT/${target#/}" "$KISS_ROOT/$cho_db/$repo_in_use_choice"
		// manifest_replace "$repo_in_use" "$target" "/$cho_db/${repo_in_use_choice#*/}"
	fi

	# Convert the desired alternative to a real file and rewrite the manifest
	# file to reflect this. The reverse of above.
	# mv -f "$activate_path" "$KISS_ROOT/${target#/}"
	cp -Pf "$activate_path" "$KISS_ROOT/${target#/}"
	// manifest_replace "$repo_activate" "/$cho_db/$repo_activate_choice" "$target"
}

# Usage:
# Outside kiss debug environment
# kiss a llvm
# Inside  kiss debug environment
#      a llvm
# pkg_alternatives llvm /usr/bin/llvm-ar
# pkg_alternatives llvm
# pkg_alternatives llvm -
# pkg_alternatives -
# pkg_alternatives
pkg_alternatives() {
	_level_2
	local repo_activate=
	[ -z "${1:+x}" ] || {
		repo_activate="$1"
		equ "$repo_activate" - ||
		[ -d "$KISS_ROOT/$db/$repo_activate" ] ||
			// die '$KISS_ROOT/$db/$repo_activate' "'$KISS_ROOT/$db/$repo_activate' not found"
		shift 1
	}

	if equ "$repo_activate" -; then
		// war '-' "Input repo name and new binary path like${newline}\
			 'llvm /usr/bin/llvm-ar' to perform the swapping${newline}\
			Ctrl-C to quit"
		while read -r repo_activate target; do
			// file_activate "$repo_activate" "$target"
		done

	elif ok "$repo_activate" && [ "$#" -eq "0" ]; then
		(
			local item target index
			set +f

			# llvm wIll lose 14 items (which are links) ? and will give full path
			# index=0
			# for item in $(\ls -1 "$KISS_ROOT/$cho_db/"* 2> /dev/null | grep "${repo_activate}>"); do
			# 	target="$(// delegate -- replace "/${item#*"${repo_activate}>"}" '/' '>')"
			# 	// debug_filter -- printf '%s %s\n' "$repo_activate" "$target" >> "$KISS_TMPDIR/logs/choices_00.log" &
			# 	// log "$repo_activate" "$target" &
			# 	: $((index += 1))
			# done
			# Without full path
			# index=0
			# for item in $(\ls -1 "$KISS_ROOT/$cho_db/" 2> /dev/null | grep "${repo_activate}>"); do
			# 	target="$(// delegate -- replace "/${item#*"${repo_activate}>"}" '/' '>')"
			# 	// debug_filter -- printf '%s %s\n' "$repo_activate" "$target" >> "$KISS_TMPDIR/logs/choices_01.log" &
			# 	// log "$repo_activate" "$target" &
			# 	: $((index += 1))
			# done

			index=0

			set -- "$KISS_ROOT/$db"/*/manifest
			local complement="$( \
				// delegate -- replace " $* " " " " $KISS_ROOT/$db/$repo_activate/manifest ")"
			set -- $complement

			# local item_valid= target_choice repo_in_use= repo_not_in_use= \
			local item_valid= target_choice repo_in_use= \
				target_manifest_or_null file_contains_target_choice
			local target_manifest="$KISS_ROOT/$db/$repo_activate/manifest"
			for item in "$KISS_ROOT/$cho_db/"*; do
				# set -f
				case "$item" in *"/$repo_activate>"*)
					// debug '$item' "$item" &
					target_choice="${item#*"${repo_activate}>"}"
					// debug '$target_choice' "$target_choice" &
					# local target_manifest_or_null="$(// as_own "$KISS_ROOT/" grep -lF "$item" "$KISS_ROOT/$db/$repo_activate/manifest" 2>/dev/null)"
					# set -x
					# grep -lF ">$target_choice" "$target_manifest" 2> /dev/null || :
					target_manifest_or_null="$(grep -lF ">$target_choice" "$target_manifest" 2> /dev/null || :)"
					# set +x
					// debug '$target_manifest_or_null' "$target_manifest_or_null" &

					[ "$target_manifest_or_null" = "$target_manifest" ] || continue

					target="$(// delegate -- replace "/$target_choice" '/' '>')"
					// debug_filter -- printf '%s %s\n' "$repo_activate" "$target" >> "$KISS_TMPDIR/logs/choices_02.log" &

					{
						[ ! -z "$repo_in_use" ] &&
						[ "$(// delegate -- manifest_repo "$target" "$KISS_ROOT/$db/$repo_in_use/manifest")" = "$repo_in_use" ]
					} ||
    				repo_in_use="$(// delegate -- manifest_repo "$target" "$@")"

					# When run alternative twice, $repo_in_use will be empty
					# [ ! -z "$repo_in_use" ] || continue

					# Might be a list?
					# repo_not_in_use=

					# [ ! -z "$repo_in_use" ] ||
					# [ ! -f "$KISS_ROOT/${target#/}" ] || {
					# 	# set +f
					# 	# set -f -- "$KISS_ROOT/$db"/*/manifest
					# 	# local target_choice="$(// delegate -- replace "$target" '>' '/')"
					# 	# local file_contains_target_choice="$(// as_own "$KISS_ROOT/" grep -lF "$target_choice" "$@" 2>/dev/null)"
					# 	file_contains_target_choice="$(grep -lF "$target_choice" "$@" 2>/dev/null)"
					# 	// log '$file_contains_target_choice' "$file_contains_target_choice" &
					# 	repo_not_in_use="${file_contains_target_choice%/manifest}"
					# 	repo_not_in_use="${repo_not_in_use##*/}"
					# 	[ -z "$repo_in_use" ] &&
					# 	[ ! -z "$repo_not_in_use" ] ||
					# 	// war '$target' "File '$KISS_ROOT/${target#/}' exists on filesystem${newline}\
					# 	but isn't owned by the repos in use"
					# }

					// cue "$repo_activate" "$target" &&
					# // file_activate "$repo_activate" "$target" "$repo_in_use" "$repo_not_in_use"
					// file_activate "$repo_activate" "$target" "$repo_in_use" &

					: $((index += 1))
				esac
			done
			set -f
			[ "$index" -eq "0" ] &&
			// war '$index' "'$(// delegate -- format $index)' file  processed" ||
			// war '$index' "'$(// delegate -- format $index)' files processed"
		) & // progress "$repo_activate" "$!" "activate $repo_activate"
	elif ok "$repo_activate" && equ "$1" "-"; then
		// war '$repo_activate' "Input new binary path like '/usr/bin/llvm-ar'${newline}\
			which beclong to repo '$repo_activate', please${newline}\
			Ctrl-C to quit"
		while read -r target; do
			// file_activate "$repo_activate" "$target"
		done

	elif ok "$repo_activate" && [ "$#" -ge "1" ]; then
		// file_activate "$repo_activate" "$@"

	else
		# Go over each alternative and format the file name for listing.
		# item>usr>bin>ls
		local item target index=0
		set +f; for item in "$KISS_ROOT/$cho_db/"*; do
			target="$(// delegate -- replace "${item##*/}" '/' '>')"
			# printf '%s %s\n' "${target%%/*}" "/${target#*/}"
			// log "${target%%/*}" "/${target#*/}" &
			: $((index += 1))
		done
		set -f
	fi
}

subshell_all() {
	_level_2
	[ -t 0 ] || { // war 'fd 0' "recovered"; exec </dev/tty; }
	local action="$1"
	shift 1
	if equ "$#" "1"; then
		// log '$#' "$# package needs to be proceeded"
	elif [ "$#" -gt "1" ]; then
		// log '$#' "$# packages need to be proceeded"
	fi
	// log '$_KISS_LVL' "$_KISS_LVL [before enter \"$action\" subshell]"
	local executer
	case $action in
		i|install)
			# pkg_install "$@"
			executer="pkg_install"
			;;
		r|remove)
			executer="pkg_remove"
			local redro=
			local parameter
			for parameter do
				local item
				for item in $(kiss-revdepends "$parameter" |
					awk -F / '{print $1}' 2> /dev/null)
				do
					redro="${redro:+"${redro} "}$item"
				done
			done
			set -- $redro "$@"
			;;
		a|alternatives)
			pkg_alternatives "$@"
			# executer="pkg_alternatives"
			return 0
			;;
		archive)
			executer="archive $REPO_BASE"
			;;
		maintain)
			executer="maintain $REPO_BASE"
			;;
	esac

	# printf '%s' "" | as_own "$KISS_ROOT/" tee "$ROOT_OUTPUT"
	# // log '$USER_OUTPUT' "$USER_OUTPUT"
	# // log '$ROOT_OUTPUT' "$ROOT_OUTPUT"

	# // kill_pipe 'PID_LOG' "$PID_LOG"
	# // kill_pipe 'PID_SAY' "$PID_SAY"

	local install_state=0
	# printf '%s\n' "$install_state" > "$KISS_TMPDIR/logs/install_state"

	// trap_off
	local index=0
	# {} | tee -a "$user_output" will disable colors and lost variable modifications
	# {
	for repo_urn do
		local repo_name="${repo_urn##*/}"
		repo_name="${repo_name%%@*}"
		// log '$index' "$index"
		# Current file name with full path
		// log '$0' "$0"
		// log '$action' "$action"
		// log '$repo_urn' "$repo_urn"
		// log '$repo_name' "$repo_name"
		[ -n "${REPO_DIR:+x}" ] || REPO_DIR=""
		! is_repos "$repo_urn" || REPO_DIR="${repo_urn%/*}"
		// log '$REPO_DIR' "$REPO_DIR"

		# Let real local whoami determine who am I. Don't set it from outside
		# LOGNAME="$LOGNAME" \
		# HOME="$HOME" \
		# XDG_CACHE_HOME="$XDG_CACHE_HOME" \
		# KISS_TMPDIR="$KISS_TMPDIR" \
		# KISS_FORCE="${KISS_FORCE-}" \
		# KISS_CHOICE="${KISS_CHOICE-}" \
		# KISS_COLOR="${KISS_COLOR-}" \
		# PID_SAY="$PID_SAY" \
		# PID_LOG="$PID_LOG" \

		# Modifying "readonly USER_OUTPUT" in "as root env" calling is not a good design
		# USER_OUTPUT=\"$ROOT_OUTPUT\" \

		# Readonly
		# KISS_PATH=\"$KISS_PATH\" \
		# _KISS_LVL=\"$((_KISS_LVL + 1))\" \
		# SESSION_PPID=\"$SESSION_PPID\" \
		# SHELL_OPTIONS=\"e$(printf '%s' "$-")\" \

		local env_variables=" RUSTFLAGS=\"--remap-path-prefix=${PWD=.} -Clinker=rust-lld ${RUSTFLAGS-}\" "
		# environment ENV_VARIABLES "RUSTFLAGS" "--remap-path-prefix=${PWD=.} -Clinker=rust-lld ${RUSTFLAGS-}"
		env_variables="$env_variables KISS_XHOST_ARCH=\"$KISS_XHOST_ARCH\" "
		# environment ENV_VARIABLES "KISS_XHOST_ARCH" "$KISS_XHOST_ARCH"
		env_variables="$env_variables KISS_XBUILD_ARCH=\"$KISS_XHOST_ARCH\" "
		# environment ENV_VARIABLES "KISS_XBUILD_ARCH" "$KISS_XHOST_ARCH"
		env_variables="$env_variables CHOST=\"${KISS_XHOST_TRIPLE}\" "
		# environment ENV_VARIABLES "CHOST" "$KISS_XHOST_TRIPLE"
		env_variables="$env_variables CBUILD=\"${KISS_XBUILD_TRIPLE}\" "
		# environment ENV_VARIABLES "CBUILD" "$KISS_XBUILD_TRIPLE"
		env_variables="$env_variables KISS_XHOST_ABI=\"$KISS_XHOST_ABI\" "
		# environment ENV_VARIABLES "KISS_XHOST_ABI" "$KISS_XHOST_ABI"
		env_variables="$env_variables KISS_XBUILD_ABI=\"$KISS_XBUILD_ABI\" "
		# environment ENV_VARIABLES "KISS_XBUILD_ABI" "$KISS_XBUILD_ABI"
		env_variables="$env_variables KISS_XHOST_TRIPLE=\"$KISS_XHOST_ARCH-linux-$KISS_XHOST_ABI\" "
		# environment ENV_VARIABLES "KISS_XHOST_TRIPLE" "$KISS_XHOST_ARCH-linux-$KISS_XHOST_ABI"
		env_variables="$env_variables KISS_XBUILD_TRIPLE=\"$KISS_XBUILD_ARCH-linux-$KISS_XBUILD_ABI\" "
		# environment ENV_VARIABLES "KISS_XBUILD_TRIPLE" "$KISS_XBUILD_ARCH-linux-$KISS_XBUILD_ABI"
		env_variables="$env_variables DEST_ROOT=\"$DEST_ROOT\" "
		# environment ENV_VARIABLES "DEST_ROOT" "$DEST_ROOT"
		env_variables="$env_variables KISS_COMPRESS=\"$KISS_COMPRESS\" "
		# environment ENV_VARIABLES "KISS_COMPRESS" "$KISS_COMPRESS"
		env_variables="$env_variables KISS_ROOT=\"$KISS_ROOT\" "
		# environment ENV_VARIABLES "KISS_ROOT" "$KISS_ROOT"
		env_variables="$env_variables KISS_REPO=\"$KISS_REPO\" "
		# environment ENV_VARIABLES "KISS_REPO" "$KISS_REPO"
		env_variables="$env_variables SESSION_PID=\"$SESSION_PID\" "
		# environment ENV_VARIABLES "SESSION_PID" "$SESSION_PID"
		env_variables="$env_variables KISS_PID=\"$KISS_PID\" "
		# environment ENV_VARIABLES "KISS_PID" "$KISS_PID"
		env_variables="$env_variables CROSS_ACTION=\"${CROSS_ACTION:-"$action"}\" "
		# CROSS_ACTION="${CROSS_ACTION:-"$action"}"
		# environment ENV_VARIABLES "CROSS_ACTION" "${CROSS_ACTION:-"$action"}"
		env_variables="$env_variables SHELL_OPTIONS=\"$SHELL_OPTIONS\" "
		# environment ENV_VARIABLES "SHELL_OPTIONS" "$SHELL_OPTIONS"
		env_variables="$env_variables REPO_BASE=\"$REPO_BASE\" "
		# environment ENV_VARIABLES "REPO_BASE" "$REPO_BASE"
		env_variables="$env_variables REPO_DIR=\"$REPO_DIR\" "

		# ENV_VARIABLES might be readonly ?
		# environment ENV_VARIABLES "REPO_DIR" "$REPO_DIR"

		env_variables="$env_variables SRC_ROOT=\"$SRC_ROOT\" "
		# environment ENV_VARIABLES "SRC_ROOT" "$SRC_ROOT"
		env_variables="$env_variables MAKE_ROOT=\"$MAKE_ROOT\" "
		# environment ENV_VARIABLES "MAKE_ROOT" "$MAKE_ROOT"
		env_variables="$env_variables OBJ_ROOT=\"$OBJ_ROOT\" "
		# environment ENV_VARIABLES "OBJ_ROOT" "$OBJ_ROOT"
		env_variables="$env_variables DESTDIR=\"$PKG_ROOT/$repo_name\" "
		# DESTDIR="$PKG_ROOT/$repo_name"
		# environment ENV_VARIABLES "DESTDIR" "$PKG_ROOT/$repo_name"

		# OUTPUT_DIR="$OBJ_ROOT/$repo_name"
		env_variables="$env_variables OUTPUT_DIR=\"$OBJ_ROOT/$repo_name\" "
		# environment ENV_VARIABLES "OUTPUT_DIR" "$OBJ_ROOT/$repo_name"

		[ -z "${DEBUG_AT_BACKGROUND+x}" ] || {
			env_variables="$env_variables DEBUG_AT_BACKGROUND=\"$DEBUG_AT_BACKGROUND\" "
			# environment ENV_VARIABLES "DEBUG_AT_BACKGROUND" "$DEBUG_AT_BACKGROUND"
		}
		[ -z "${KISS_FORCE+x}" ] || {
			env_variables="$env_variables KISS_FORCE=\"$KISS_FORCE\" "
			# environment ENV_VARIABLES "KISS_FORCE" "$KISS_FORCE"
		}
		# Pipe design hides the standard output
		# $ROOT_OUTPUT is not necessary
		# as_own "$KISS_ROOT/" sh -c "tee -a $ROOT_OUTPUT < $pipe" &

		env_variables="$env_variables KISS_ALTER_AS_LIBRARY=\"\" "
		# environment ENV_VARIABLES "KISS_ALTER_AS_LIBRARY" "${KISS_ALTER_AS_LIBRARY-}"

		# / "$env_variables \
		#   . \"/usr/bin/kiss-alter\" \"$action\" \"$repo_urn\" 2>&1" && {

		# / "as_own \"$KISS_ROOT/\" \
		#   env \
		#   $env_variables \
		#     \"/usr/bin/kiss-alter\" \"$action\" \"$repo_urn\" 2>&1" && {
		#
		# Try command ENV_VARIABLES, problematic
		# export $ENV_VARIABLES
		# /usr/bin/kiss: export: line 1390: --remap-path-prefix: bad variable name
		# export $env_variables

		! // || / "$executer \"$repo_urn\"" 2>&1 && {

			// cue '$repo_name' "'$repo_name' $action succeeded"
			// log '$repo_urn' "$repo_urn"
			// log 'test' "test_-2"
			: $((index += 1))
			// log '$index' "$index"
			// log 'test' "test_-1"
		} || {
			# \"/usr/bin/kiss\" \"$action\" \"$repo_urn\" 2>&1" || {

			# sh -c -e '/usr/bin/kiss $action $repo_urn > $pipe' 2>&1" || {
			# "$0" "$action" "$repo_urn" 2>&1 || {

			// war '$repo_urn' "subshell install failed"
			// log '$index' "$index"
			// log '$0' "$0"
			// log '$action' "$action"
			// log '$repo_urn' "$repo_urn"

			[ -z "${KISS_INNER_PIPE:+x}" ] || {
				# \ls -alh "/tmp/$kiss_root_user/kiss/logs/build.log"
				# read -r _

				# [ -z "${USE_SAY_PIPE+x}" ] ||
				clear_outer "PID_SAY"
				clear_outer "PID_LOG"
			}

			install_state=1
			# printf '%s\n' "$install_state" > "$KISS_TMPDIR/logs/install_state"

			# One-time useage of an input, don't modify global user_output, please
			# Pseudo code
			# "$user_output" == "/tmp/$kiss_root_user/kiss/logs/build.log"

			// log "$find_tip" "$USER_OUTPUT"
			# // log "$find_tip" "$ROOT_OUTPUT"

			// log_shift "$cache_dir/logs/$repo_name/build.log" "$USER_OUTPUT"
			# // log_shift "$cache_dir/logs/$repo_name/build.log" "$ROOT_OUTPUT"

			# kill 0 ||
			# // kill_subtree "$KISS_PID"
			// die "$repo_name" "quit current install process"
			interrupt
			# // war \$SESSION_PID "'$SESSION_PID' was gona being killed. \
			#   ${newline}You have to reload kiss"
			# ! pid_alive $SESSION_PID || { kill -KILL $SESSION_PID; }
		} # | tee -a "$USER_OUTPUT"

	# [ "$install_state" -eq "0" ] && {
	#   // cue '$repo_name' "'$repo_name' $action succeeded"
	#   // log '$index' "$index"
	#   // log '$repo_urn' "$repo_urn"
	#   // log 'test' "test_-2"
	#   : $((index += 1))
	#   // log 'test' "test_-1"
	# }
	done
	// log 'test' "test_-0"

	# Pipe here will erase variables inside this scope
	# It means that you have to use files to transfer inside status out or via other means
	# } | tee -a "$USER_OUTPUT"

	// log 'test' "test_00"
	# One-time useage of an input, don't modify global user_output, please
	# Pseudo code
	# "$user_output" == "/tmp/$kiss_root_user/kiss/logs/build.log"

	# \ls -alh "/tmp/$kiss_root_user/kiss/logs/build.log"
	# read -r _

	# Self clean when quit subshell
	# clear_outer "PID_SAY"
	# clear_outer "PID_LOG"

	# install_state="$(cat "$KISS_TMPDIR/logs/install_state")"
	[ "$install_state" -eq "0" ] && {
		// log 'test' "test_01"
		// log '$index' "$index"

		[ "$index" -eq "1" ] ||
		// cue '$action' "'$index' packages $action succeeded"

		# equ "$LOGNAME" "$kiss_root_user" || // log_shift "$USER_OUTPUT" "$ROOT_OUTPUT"

		// log 'test' "test_02"
		// trap_on "$action" "$@"
		// log 'test' "test_03"
	} || {
		// war '$install_state' "$install_state"
		// war '$SESSION_PID' "$SESSION_PID"
		# kill_name "$CROSS_ACTION" "$repo_name"
		# Will kill the main process
		# kill_tree "$SESSION_PID" true
		interrupt    # kill_tree "$SESSION_PID"
		# return "$install_state"
	}
}

# action="$1"
# shift 1
# subshell_all "$action" "$@"







