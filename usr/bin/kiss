#! /bin/sh -e
#! /bin/sh
#! /bin/sh --
#! /proc/parent/exe --
#! /bin/sh -eEauf

# [ "$(cat /etc/hostname 2> /dev/null)" != "kiss" ] &&
# [ ! -z "${IS_KISS+x}" ] && set -Eau || set -au
[ ! -z "${IS_KISS+x}" ] && set -Eau || set -au

[ "$(set -o | grep xtrace | awk '{print $2}')" = "off" ] ||
set -x

check_pipefail="$(set -o | grep pipefail | awk "{print \$1}")"
[ "$check_pipefail" != "pipefail" ] || set -o pipefail

# Outdated option: shellcheck source=/dev/null
#
# Simple package manager written in POSIX shell for https://kisslinux.org
#
# The MIT License (MIT)
#
# Copyright (c) 2019-2021 Dylan Araps
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Coding specifications and conventions (recommended by Tuo Jung)
# Environment variables value convention
# To simplify the conventions of the system, undefined and "" (empty) mean
# different behaviors
# Since "set -u" is a good habit, "" (empty) should be used for satisficing it
# "${KISS_STRIP-}" will be used where citations are required, which means
# the default behavior
# Note the different meanings of the following definitions
# [ -n "${KISS_STRIP:+x}" ] means no stripping (non-null value)
# [ -z "${KISS_STRIP:+x}" ] means stripping (non-null value)
# While
# [ -n "${KISS_DEBUG:+x}" ] means debugging (non-null value)
# [ -z "${KISS_DEBUG:+x}" ] means no debugging (non-null value)
# And readonly makes their values maintaining consistency
# For history compatibility, we check the value of other customary conventions
# after this

# Naming convention/semantics
# XXX_DIR     : parent address for a package   (like dirname, subject depends)
# XXX_FOLDER  : parent dir name for a package  (has no path)
# XXX_ROOT    : search root for target         (further finding needed)
# XXX_PATH    : full address of a package      (like realpath)

# xxx_dir     : parent address for a package   (locally / does not export)

# Search "File Hierarchy" / "init_dirs()" (without quotes) for naming applications

# Levels of structure
#                       |---------------pkg_cache-----------|
#   local_route    |--build--|      |--pkg_cache--|
# src_url -> des -> make -> pkg -> archive -> extract -> install

# Tips
# 1. We know what code does, and codes know what they do. Never break the chain of integration
# 2. Isolation is important, and value return should be flexible
# 3. Line number reports might be interrupted by aliases with broken lines

# https://stackoverflow.com/questions/52659038/how-to-suppress-irrelevant-shellcheck-messages
# shellcheck --exclude=SC1127,SC2016,SC2015,SC3043,SC2155,SC3001,SC3003,SC3014,SC2287,SC2031

[ -t 0 ] || {
	printf '%s %s\n' 'fd 0' "does not work at $LINENO"
	# exec </dev/stdin
	exec </dev/tty
}

# printf '%s %s\n' '$LINENO' "$LINENO"

# Put arguments to the array arg[]
# index=0
# for arg do eval "arg_$index=\$arg"; : "$((index += 1))"; done
# unset index

[ -n "${HEADER+x}" ] ||
printf '%s %s\n' '$HEADER' "not defined"

# [ -z "${USE_SAY_PIPE+x}" ] || unset USE_SAY_PIPE
# KISS_INNER_PIPE defined means using pipe_reader in kiss/share
# : "${KISS_INNER_PIPE:=""}"
# : "${USE_ENV:=""}" && export USE_ENV
[ -z "${KISS_INNER_PIPE+x}" ] || unset KISS_INNER_PIPE
[ -z "${mute_err+x}" ] || unset mute_err
[ -z "${KEEP_DEPRECATED+x}" ] || unset KEEP_DEPRECATED
: "${SESSION_PID:="$$"}"                  && export SESSION_PID
: "${SESSION_PPID:="${PPID}"}"            && export SESSION_PPID
: "${KISS_PID:=$$}"                       && export KISS_PID
: "${KISS_TMPDIR:="/tmp/$LOGNAME/kiss"}"  && export KISS_TMPDIR
# Neither the log folder nor the pipes is created at this moment.
# So don't use the log functions before user_output and pipes/listeners are ready
[ -d "$KISS_TMPDIR" ] || mkdir -p "$KISS_TMPDIR"
log_dir="$KISS_TMPDIR/logs"
[ -d "$log_dir" ] || mkdir -p "$log_dir"
: "${USER_OUTPUT:="$KISS_TMPDIR/logs/build.log"}" && export USER_OUTPUT

interrupt_type="$(type "interrupt" > /dev/null 2>&1 && type "interrupt")" || :
{
	[ ! -z "${interrupt_type:+x}" ] &&
	# [ -z "${interrupt_type##*"alias"*}" ]
	# set | grep -q _level > /dev/null &&
	# [ -n "${-##*x*}" ]
	[ ! -z "${HEADER+x}" ]
} || {

	# Outdated option: shellcheck source=/dev/null
	# shellcheck source=/usr/include/kiss/share
	. /usr/include/kiss/share
	# . /usr/include/kiss/share > /dev/null 2>&1

	[ -t 0 ] || // die 'fd 0' "does not work"
	# export $(cut -d= -f1 /usr/include/kiss/share)

	# -ash: //: Permission denied -- // is not defined
	# // war '$HEADER' "$HEADER"

	# export HEADER=
}

# Test line number calcuation -- searching different typographics have the same line number
# printf '%s %s\n' 'Current line' "New line"
// log 'inside' "kiss"

SCRIPT_NAME="kiss" && export SCRIPT_NAME

# : "${lineno="$((LINENO + 2))"}"
# : "${lineno_scope="$lineno"}"
# // war '$HEADER' "$HEADER"

# Without kiss/share file version
# / "$function_debug_filter"

! // || [ "$lineno" -eq "$LINENO" ] || // war '$lineno : $LINENO' "$lineno : $LINENO"

run() {
	_level_2
	# Print the command, then run it.
	// log "$scope" "$*"
	"$@"
}

! // || [ "$lineno" -eq "$LINENO" ] || // war '$lineno : $LINENO' "$lineno : $LINENO"

# Aquire an empty file in temporary directory for writing into
# it step by step in the future
# $1 repo_urn    : repo name
# $2 src_address : source file full path or file name
slot_aquire() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	local src_address="$(standardize "$2")"
	local src_name="${src_address##*/}"
	src_name="${src_name%\?*}"

	[ "${src_address:0:1}" != '/' ] || src_address="${src_address#/}"

	# Create a uniquely named temporary file and store its absolute path
	# in a variable and return it to the caller (stack_topend).

	# The following comments was deprecated
	# To prevent subshell usage and to handle cases where multiple files
	# are needed, this saves the last two temporary files to variables
	# for access by the caller (allowing 3 files at once).

	# local stack_topend="$TEMP_ROOT/$repo_name/$src_address.$(mktemp -u XXXXXX)"
	local stack_topend="$TEMP_ROOT/$repo_name/$src_address"
	[ ! -f "$stack_topend" ] ||
	[ ! -s "$stack_topend" ] || {
		// war '$stack_topend' \
			"'$stack_topend'\
			${newline}already exists and is not empty \
			${newline}[make sure it's designed that way]"
		# local index=0
		# while read -r line; do
		#     : $((index += 1))
		#     // log '$stack_topend' "$(delegate -- format "$index") $line"
		# done < "$stack_topend"
	}

	local dir_topend="${stack_topend%/*}"
	[ -d "$dir_topend" ] || // as_own "$TEMP_ROOT" \mkdir -p "$dir_topend"

	// as_own "$TEMP_ROOT" touch "$stack_topend" ||
		// die "$src_address" \
			"failed to create the temporary file under $TEMP_ROOT/$repo_name"
	printf "$RS%s" "$stack_topend"
}

! // || [ "$lineno" -eq "$LINENO" ] || // war '$lineno : $LINENO' "$lineno : $LINENO"

# Copy an extarnal file to temporary directory in one time
# Won't create empty file
# $1 repo_urn    : repo name
# $2 src_address : source file full path
slot_push() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	local src_address="$2"
	local src_name="${src_address##*/}"
	src_name="${src_name%\?*}"

	# Create a uniquely named temporary file and make a duplicate of
	# the file in '$src_address' if it exists.
	local stack_top="$(// delegate -- slot_aquire "$repo_name" "$src_address")"
	// log '$stack_top' "'$stack_top' touched"

	[ ! -f "$src_address" ] ||
	null "$stack_top" || {
		// as_own "$TEMP_ROOT" rsync -aqzL "$src_address" "$stack_top" ||
			// die '$src_address' "\"$src_address\" failed to copy"
		// as_own "$TEMP_ROOT" sync
		// log '$src_address' "$src_address"
		// log '$stack_top' "$stack_top"
	}

	printf "$RS%s" "$stack_top"
}

mkcd() {
	_level_2

	ok "$1" || // die "Trying to create an empty directory"

	local target="$1"
	local item
	for item do
		item="$(standardize "$item")"
		// debug '$item' "$item"
		local parent_dir="${item%/*}"
		// debug '$parent_dir' "$parent_dir"
		[ ! -d "$parent_dir" ] ||
		// debug '$(realpath $parent_dir)' "$(realpath $parent_dir)" &

		local index=0
		! literal "$parent_dir" &&
			// die 'mkdir -p $item' 'Trying to modify system root /' ||
			[ -d "$parent_dir" ] ||
			# Have not been created yet
			until
				path_valid "$parent_dir" ||
				[ "$index" -ge "10" ]
			do
				literal "$parent_dir" &&
				[ "x$(printf '%s' "$parent_dir" | tr -d "$IFS")" != "x/" ] &&
					parent_dir="${parent_dir%/*}" || break

				// debug '$parent_dir' "$parent_dir" &
				[ ! -d "$parent_dir" ] ||
				// debug '$(realpath $parent_dir)' "$(realpath $parent_dir)" &
				: $((index += 1))
			done
		path_valid "$parent_dir" ||
			// die 'mkdir -p $item' 'Trying to modify system root / or parent is an invalid path'
		# [ -d "$parent_dir" ] ||
		# 	// die 'mkdir -p $item' 'parent dir does not exist'
		[ "$parent_dir" != "$KISS_ROOT" ] ||
			// die 'mkdir -p $item' 'Trying to modify $KISS_ROOT/'
		// debug '$parent_dir' "$parent_dir" &
		// debug '$item' "$item" &
		// as_own "$parent_dir" \mkdir -p "$item" || // die 'mkdir' "$item"
	done
	cd "$target"
	// log '$PWD' "$PWD"
}

# encode right to left in a pair and left to right in $@ (pairs)
# encode "$source_string" "KISS_REPO" "$KISS_REPO" "REPO_ROOT" "$REPO_ROOT"
#               ^             ^            |             ^           |
#               |             |____________|             |___________|
#               |___________________|_________________________|
[ -z "${KEEP_DEPRECATED+x}" ] ||
# Deprecated
encode() {
	local level=-1
	[ "$level" -eq "-1" ] ||
	_level_2
	// debug_filter -- // debug '$@' "$(esceval "$@")"
	[ "$#" -ge "3" ] || // die '$#' "$# parameters are not enough"
	local str="$1"
	shift 1

	local arguments=

	# local ifs="$IFS"
	# local IFS="$IFS_ORIGIN"
	for index in $(seq 1 2 $#); do
		local target="$(/ "printf '%s' \"\${$index}\"")"
		[ -n "$target" ] || target=\"\"
		local source="$(/ "printf '%s' \"\${$((index + 1))}\"")"
		[ -n "$source" ] || source=\"\"
		case "$target" in
			*"$source"*)
				// die '$target contains $source' "'$target' contains '$source'"
		esac

		# If you have an array, and step in 2 elements at a time
		# set -f -- "$@" "\ " "$target" "$target" "$source" "\\$target" "\ "
		arguments="${arguments:+"${arguments} "}$FS $target $target $source \\$target $FS"

	done
	// debug '$arguments' "$arguments"
	local ifs="$IFS"
	local IFS=$' '
	set +f
	set -f -- $arguments
	set -- "$str" "$@"
	IFS="$ifs"
	// debug '$#' "$#"
	[ "$#" -ge "3" ] || // die '$#' "$# parameters are not enough"

	# Don't quote $arguments in the following line if referenced
	printf "$RS%s" "$(// delegate -- replace "$@")"
}

# decode right to left in a pair and left to right in $@ (pairs)
# decode "$source_string" "$KISS_REPO" "KISS_REPO" "$REPO_ROOT" "REPO_ROOT"
#               ^             ^            |             ^           |
#               |             |____________|             |___________|
#               |___________________|_________________________|
[ -z "${KEEP_DEPRECATED+x}" ] ||
# Deprecated
decode() {
	local level=-1
	[ "$level" -eq "-1" ] ||
	_level_2
	// debug_filter -- // debug '$@' "$(esceval "$@")"
	[ "$#" -ge "3" ] || // die '$#' "$# parameters are not enough"
	local str="$1"
	shift 1

	local arguments=

	# local ifs="$IFS"
	# local IFS="$IFS_ORIGIN"
	# $10 will be treated as $1+0
	# // debug '$10' "$10"
	# // debug '${10}' "${10}"
	for index in $(seq 1 2 $#); do
		// debug '$index' "$index"
		# // debug "\$${index}" "$(/ "echo \"\${$index}\"")"
		# // printf '%s %s\n' "\$${index}" "$(/ "echo \"\${$index}\"")" >> "$USER_OUTPUT"
		local target="$(/ "printf '%s' \"\${$index}\"")"
		[ -n "$target" ] || target=\"\"
		// debug '$target' "$target"
		# // debug "\$$((index+1))" "$(/ "echo \"\${$((index+1))}\"")"
		# // printf '%s %s\n' "\$$((index+1))" "$(/ "echo \"\${$((index+1))}\"")" >> "$USER_OUTPUT"
		local source="$(/ "printf '%s' \"\${$((index + 1))}\"")"
		[ -n "$source" ] || source=\"\"
		// debug '$source' "$source"
		case "$target" in
			*"$source"*)
				// die '$target contains $source' "'$target' contains '$source'"
		esac

		# If you have an array, and step in 2 elements at a time
		# set -f -- "$@" "\ " "\\$source" "$target" "$source" "$source" "\ "
		arguments="${arguments:+"${arguments} "}$FS \\$source $target $source $source $FS"

	done
	// debug '$arguments' "$arguments"
	local ifs="$IFS"
	local IFS=$' '
	set +f
	set -f -- $arguments
	set -- "$str" "$@"
	IFS="$ifs"
	// debug '$#' "$#"
	[ "$#" -ge "3" ] || // die '$#' "$# parameters are not enough"

	# Don't quote $arguments in the following line if referenced
	printf "$RS%s" "$(// delegate -- replace "$@")"
}

# Usage:
# manifest_repo    "$target"
# manifest_repo    "$target" $manifests_list
# manifest_repo -e "$target" $manifests_list
# Return the repo_name of input target
# $1 parameter  : query target if $2 is not provided
# $2 library    : query target
# $3 manifest list
# Pay attention to -x of grep
manifest_repo() {
	_level_2

	ok "${2-}" || { set +f; set -f -- "$1" "$KISS_ROOT/$db"/*/manifest; }
	local repo_name=
	local owns="$(grep -lxF "$@")"
	owns="${owns%/*}"
	repo_name="${owns##*/}"

	# ok "$repo_name"
	printf "$RS%s" "$repo_name"
}

resolve_path() {
	_level_2
	local rpath=$KISS_ROOT/${1#/}
	local parent
	# Attempt to resolve symlinks by using 'cd'.
	# If this fails, fallback to the file's parent
	# directory.
	if cd -P "${rpath%/*}" 2>/dev/null; then
		parent=$PWD
		cd "$OLDPWD"
	else
		parent=${rpath%/*}
	fi

	rpath=${parent#"$KISS_ROOT"}/${rpath##*/}
	printf "$RS%s" "$rpath"
}

run_hook() {
	_level_2
	local command="$1"
	shift 1

	# Run all hooks in KISS_HOOK (a colon separated
	# list of absolute file paths).
	local ifs="$IFS"
	local IFS=$':'

	for hook in ${KISS_HOOK:-}; do
		[ ! -f "$hook" ] ||
		case $hook in
			*?*)
				# // as_own "$KISS_ROOT/" sh "$hook" "$command" "$@" ||
				. "$hook" "$command" "$@" ||
				// die "$command" "hook failed: '$hook'"
		esac
	done

	IFS="$ifs"

	# [ "$command" = "SIGINT" ] ||
	# [ "$command" = "SIGEXIT" ] || return 0
}

# $1 command
# $2 repo_name
# For compatibility, do not change the "$repo_name" parameter
run_hook_pkg() {
	_level_2
	local command="$1"
	shift 1
	local repo_name="$1"
	repo_name="${repo_name%%@*}"
	local repo_ver="$2"
	local repo_rel="$3"
	local repo_dir="$4"
	local repo_urn="$repo_dir/$repo_name"
	local real_command="$repo_urn/$command"
	[ -f "$real_command" ] || {
		# Run a hook from the package's database files.
		# real_command="$sys_db/$repo_name/$command"
		# [ -f "$real_command" ] || {
		// log "$command" "skipping hook: no executable command"
		return 0
		# }
	}
	! command -v "$real_command" > /dev/null 2>&1 || {
		// log "$repo_name" "running $command hook"
		# // as_own "$KISS_ROOT/" sh "$real_command" "$@" ||
		. "$real_command" "$@" ||
		// die '$real_command' "'$real_command' execution failed"
	}
}

# $1 tar_file : tar file
decompress() {
	_level_2
	local tar_file="$1"

	set --
	local tar_dir_user="$(// delegate owner "$TAR_ROOT")"
	[ "$LOGNAME" = "$tar_dir_user" ] ||
		set -- $(// delegate as_user "$tar_dir_user")

	[ -f "$tar_file" ] &&
		// log '$tar_file' "$tar_file [local]" ||
		// die '$tar_file' "${tar_file:+"${tar_file} "}has not yet built [local]"

	case "$tar_file" in
		*.zip)
			local tar_path="${tar_file%/*}"
			"$@" unzip -oq "$tar_file"
			tar_file="${tar_file##*/}"
			tar_file="$tar_path/${tar_file%%.*}.tar"
			"$@" tar -cf "$tar_file" ./
	esac

	case "$tar_file" in
		*.tbz|*.bz2) "$@" bzip2 -d ;;
		*.lzma)      "$@" lzma -dc ;;
		*.lz)        "$@" lzip -dc ;;
		*.tar)       "$@" cat      ;;
		*.tgz|*.gz)  "$@" gzip -d  ;;
		*.xz|*.txz)  "$@" xz -dcT0 ;;
		*.zst)       "$@" zstd -dc ;;
	esac < "$tar_file"

}

sh256() {
	_level_2
	# Higher level sh256 function which filters out non-existent
	# files (and also directories).
	for f do shift
		[ -d "$f" ] || [ ! -e "$f" ] || set -- "$@" "$f"
	done

	local hash="$(// _sh256 "$@")" || // die '_sh256' "$hash"
	printf "$RS%s" "$hash"
}

_sh256() {
	_level_2

	# There's no standard utility to generate sha256 checksums.
	# This is a simple wrapper around sha256sum, sha256, shasum,
	# openssl, digest, ... which will use whatever is available.
	#
	# All utilities must match 'sha256sum' output.
	#
	# Example: '<checksum>  <file>'
	local hash=

	# Skip generation if no arguments.
	! equ "$#" 0 || return 0

	# Set the arguments based on found sha256 utility.
	case ${cmd_sha##*/} in
		openssl) set -- dgst -sha256 -r "$@" ;;
		 sha256) set -- -r "$@" ;;
		 shasum) set -- -a 256 "$@" ;;
		 digest) set -- -a sha256 "$@" ;;
	esac

	local ifs="$IFS"
	local IFS="$newline"

	# Generate checksums for all input files. This is a single
	# call to the utility rather than one per file.
	local sha_list="$("$cmd_sha" "$@")" || // die "Failed to generate checksums"

	# Strip the filename from each element.
	# '<checksum> ?<file>' -> '<checksum>'
	for sum in $sha_list; do
		hash=$hash${hash:+"${IFS}"}${sum%% *}
	done

	printf "$RS%s" "$hash"
	IFS="$ifs"
}

is_version() {
	ok "$1" || return 1
	# local ver="$1"
	# ver="$(// delegate -- replace "$ver" "" ".")"
	# Time consuming
	# ver="$(// replace "$1" "" ".")"
	# is_integer "${ver##*${newline}}"
	# ver="$(printf '%s' "$1" | tr -d '.')"
	is_integer "$(printf '%s' "$1" | tr -d '.')"
}

pkg_base() {
	_level_2
	local repo_name="$1"
	# local repo_urn="$1"
	# repo_urn="$(standardize "$repo_urn")"
	# local repo_name="${repo_urn##*/}"
	# # [ -d "$repo_urn" ] || // die '$repo_urn' "'$repo_urn' directory does not exist"
	# local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	local target_source=

	# # Keys design begin
	# [ -z "${USE_KEYS:+x}" ] || {
	#   # Recover repo from "keys" file
	#   # Keys design was deprecated. "repo_dir" merged into version file
	#   [ ! -f "$repo_urn/keys" ] || {
	#       local last_sentence="$(// delegate -- valid_tail "$repo_urn/keys")"
	#       [ -n "${last_sentence:+x}" ] ||
	#       // die '$repo_urn/keys' "file \"$repo_urn/keys\" is invalid"
	#       IFS=$' ' read -r _ _ target_source \
	#           < <(printf '%s\n' "$last_sentence") > /dev/null || {
	#           cat "$repo_urn/keys"
	#           // die '$repo_urn/keys' "query failed on '$repo_urn/keys'"
	#       }
	#       [ -z "${target_source:+x}" ] || {
	#           target_source="$( \
	#               // delegate -- bicode "code" "$target_source" "KISS_REPO" "$KISS_REPO")"
	#           [ -d "$target_source" ] ||
	#           // die '$target_source' "no such package \"$target_source\""
	#       }
	#   }
	# }
	# # Keys design end

	# [ -n "${target_source:+x}" ] ||
	! is_repos "$REPO_BASE/$repo_name" || target_source="$REPO_BASE/$repo_name"
	[ -n "${target_source:+x}" ] || {
		# ! is_repos "$REPO_UNDERCONSTRUCTION/$repo_name" ||
		# target_source="$REPO_UNDERCONSTRUCTION/$repo_name"

		// log '$target_source' \
			"${target_source:+"${target_source} "}does not exist [$repo_urn] [version issue]"
		printf "$RS%s" ""
		# Normal result
		return 1
	}
	// debug '$target_source' "$target_source"

	# repo_urn is just a repo_name
	# set --
	# local repo_user="$(// delegate -- owner "$repo_urn")"
	# [ "$LOGNAME" = "$repo_user" ] ||
	# set -- $(// delegate -- as_user "$repo_user")
	# "$@" rsync -aqzL "$target_source/." --exclude="keys" --exclude="manifest" "$repo_urn/"
	# "$@" sync
	# is_repos "$repo_urn" && [ -f "$repo_urn/version" ] ||
	#   // die '$repo_urn' "'$repo_urn' recover failed"

	printf "$RS%s" "$target_source"
}

# We don't dig into repo_dir_decoded for further details
# But we do decode it
# Package version of selected $KISS_PATH
# $1 repo_urn
# $2
# $3 -d / -x
# $4 $KISS_PATH / $sys_db / $PATH
pkg_version() {
	_level_2
	# local repo_urn="${1:?"\"repo_urn\" has to be provided"}"
	local repo_urn="$(realpath "$1" 2>/dev/null || echo -n "$1")"
	local list_type="${2-}"
	local target_type="${3-}"
	local search_dir="${4-}"
	local repo_name=

	# local start=`date +%s.%N`

	[ -n "${repo_urn:+x}" ] ||
	// die '$repo_urn' "valid value has not been provided"

	case "$repo_urn" in
		*"KISS_REPO"*|*"REPO_ROOT"*|*"REPO_BASE"*)
			# Decode the url
			repo_urn="$(// delegate -- bicode "code" "$repo_urn" \
				"KISS_REPO" "$KISS_REPO" "REPO_ROOT" "$REPO_ROOT")"
	esac

	repo_urn="$(standardize "$repo_urn")"
	[ -z "${repo_urn##*"/"*}" ] && repo_name="${repo_urn##*/}" ||
		repo_name="$repo_urn"

	repo_name="${repo_name%%@*}"

	is_repos "$repo_urn" || {
		# // debug '$repo_name' "$repo_name"
		# // debug '$repo_urn' "$repo_urn [input]"
		: "${search_dir:="$KISS_PATH"}"
		// debug_filter -- // debug '$search_dir' "$search_dir"
		local repo_retrieved="$(// delegate -- repo_trace "$repo_name" \
				"$list_type" "$target_type" "$search_dir")"

		[ "$repo_retrieved" = "$repo_urn" ] || [ -z "$repo_retrieved" ] || {
			# // debug '$repo_retrieved != $repo_urn' \
			#     "\$repo_urn == '$repo_urn' is mapped to $newline\$repo_retrieved == '$repo_retrieved'"
			repo_urn="$repo_retrieved"
		}
	}

	// debug_filter -- // debug '$repo_urn' "$repo_urn"

	local repo_dir="${repo_urn%/*}"

	local repo_ver= repo_rel= repo_alias= repo_url= reference_type=
	local version_is_valid=0

	[ -d "$repo_urn" ] || {
		// die '$repo_urn' "'$repo_urn' no such package installed"
		printf "$RS%s$FS%s$FS%s$FS%s$FS%s$FS%s" \
			"$repo_dir" "$repo_ver" "$repo_rel" \
			"$repo_alias" "$repo_url" "$reference_type"
		interrupt
	}

	is_repos "$repo_urn" && [ -f "$repo_urn/version" ] || {
		// die '$repo_urn' "'$repo_urn' is not a valid package"
		printf "$RS%s$FS%s$FS%s$FS%s$FS%s$FS%s" \
			"$repo_dir" "$repo_ver" "$repo_rel" \
			"$repo_alias" "$repo_url" "$reference_type"
		interrupt
	}

	# Look, we just read the repo_ver repo_rel of the current "$repo_urn/version" file
	# Normally we do't dig into some repo_dir_decoded for further details since we have a working repo
	# Otherwise, the performance will be terrible
	IFS=$' ' read -r repo_ver repo_rel \
		repo_alias repo_url reference_type 2>/dev/null \
		< "$repo_urn/version" ||
	// die "$repo_name" "failed to read $repo_urn/version"

	[ ! -z "${repo_ver:+x}" ] || repo_ver=
	[ ! -z "${repo_rel:+x}" ] || repo_rel=
	[ ! -z "${repo_alias:+x}" ] || repo_alias=
	[ ! -z "${repo_url:+x}" ] || repo_url=
	[ ! -z "${reference_type:+x}" ] || reference_type=

	[ -z "${repo_alias:+x}" ] ||
		[ ! -z "${repo_url:+x}" ] || repo_alias=

	[ -z "${repo_alias:+x}" ] || {
		case "$repo_urn" in
			*"KISS_REPO"*|*"REPO_ROOT"*|*"REPO_BASE"*)
			# Decode the url
			repo_dir_decoded="$(// delegate -- bicode "code" "$repo_alias" \
				"KISS_REPO" "$KISS_REPO" "REPO_ROOT" "$REPO_ROOT" "REPO_BASE" "$REPO_BASE")"
		esac

		// debug_filter -- // debug '$repo_dir_decoded' "$repo_dir_decoded"
		[ -n "${repo_dir_decoded:+x}" ] ||
		// war '$repo_dir_decoded' "is undefined"
		[ -d "$repo_dir_decoded/$repo_name" ] ||
		// war '$repo_dir_decoded/$repo_name' \
			"'$repo_dir_decoded/$repo_name' directory does not exist"
		is_repos "$repo_dir_decoded/$repo_name" &&
		repo_dir="$repo_dir_decoded" || {
			version_is_valid=1
			for item in $(\ls -1 "$repo_dir_decoded"); do
				[ -d "$item" ] && is_version "${item%%-*}" || continue
				is_repos "$item/$repo_name" || continue
				is_model "$item/$repo_name" "$repo_urn" || continue
				repo_dir="$item"
				break
			done
			[ -n "${repo_dir:+x}" ] || {
				// war '$repo_dir_decoded' \
					"'$repo_dir_decoded' is not a valid repo"
			}
			# printf "$RS%s$FS%s$FS%s$FS%s$FS%s$FS%s" \
			#   "$repo_dir" "$repo_ver" "$repo_rel" \
			#   "$repo_alias" "$repo_url" "$reference_type"
			# return 0
			# interrupt
		}
	}

	# Subshell running function, useles
	# local repo_urn_plain="$(name_plain "$repo_urn")"
	# / "pkg_${repo_urn_plain}_version=\"$repo_ver-$repo_rel\""
	# / "// log '\${pkg_${repo_urn_plain}_version}' \"\${pkg_${repo_urn_plain}_version}\""

	// debug_filter -- // debug '$repo_dir' "$repo_dir"
	// debug_filter -- // debug '$repo_ver' "$repo_ver"
	// debug_filter -- // debug '$repo_rel' "$repo_rel"
	// debug_filter -- // debug '$repo_alias' "$repo_alias"
	// debug_filter -- // debug '$repo_url' "$repo_url"
	// debug_filter -- // debug '$reference_type' "$reference_type"

	# equ "git" "$(// delegate -- pkg_format "$repo_urn")" || {
	# awk like double quotes
	printf "$RS%s$FS%s$FS%s$FS%s$FS%s$FS%s" \
		"$repo_dir" "$repo_ver" "$repo_rel" \
		"$repo_alias" "$repo_url" "$reference_type"

	# (
	# local end=`date +%s.%N`
	# local pkg_ver_time=$(echo "$end - $start" | bc -l)
	# // log '$pkg_ver_time' "$pkg_ver_time"
	# ) &


	return 0

	# }

	# Deprecated
	local repo_dir_decoded=
	local version_is_valid=0

	# [ -n "${repo_alias:+x}" ] ||
	# is_in_main "$repo_urn" ||
	# [ -n "${repo_urn##*"${db}"*}" ] ||
	#     // war '$repo_alias' \
	#         "${repo_alias:+"'${repo_alias}' "}is only in $KISS_ROOT/$db"

	local repo_dir=
	[ -z "${repo_alias:+x}" ] || {
		{
			[ -n "${repo_alias##*"KISS_REPO"*}" ] &&
			[ -n "${repo_alias##*"REPO_ROOT"*}" ]
		} ||
			# Decode the url
		repo_dir_decoded="$(// delegate -- bicode "code" "$repo_alias" \
			"KISS_REPO" "$KISS_REPO" "REPO_ROOT" "$REPO_ROOT")"

		# repo_dir_decoded="$( \
		#   // delegate -- bicode "code" "$repo_alias" "KISS_REPO" "$KISS_REPO")"

		// debug '$repo_dir_decoded' "$repo_dir_decoded"
		[ -n "${repo_dir_decoded:+x}" ] ||
		// war '$repo_dir_decoded' "is undefined"
		[ -d "$repo_dir_decoded/$repo_name" ] ||
		// war '$repo_dir_decoded/$repo_name' \
			"'$repo_dir_decoded/$repo_name' directory does not exist"
		is_repos "$repo_dir_decoded/$repo_name" &&
		repo_dir="$repo_dir_decoded" || {
			version_is_valid=1
			for item in $repo_dir_decoded; do
				is_repos "$item/$repo_name" || continue
				repo_dir="$item"
				break
			done
			[ -n "${repo_dir:+x}" ] || {
				// war '$repo_dir_decoded' \
					"'$repo_dir_decoded' is not a valid repo and reseted"
			}
			# printf "$RS%s$FS%s$FS%s$FS%s$FS%s$FS%s" \
			#   "$repo_dir" "$repo_ver" "$repo_rel" \
			#   "$repo_alias" "$repo_url" "$reference_type"
			# return 0
			# interrupt
		}
	}

	is_version "$repo_rel" || {
		// war '$repo_rel' "$repo_rel"
		// war "$repo_name" "release field not found in version file"
		#
		# Keep pkg_version function read-only
		# repo_rel=0
		#
		version_is_valid=1
	}

	is_version "$repo_ver" ||
	# equ "$repo_ver" "git" ||
	{
		// war '$repo_ver' "$repo_ver"
		# equ "git" "$(// delegate -- pkg_format "$repo_urn")" && {
		#     # Highlight will be ruined by wrong line continuation
		#     # Might recursive calling pkg_version itself in sync_remote (could be avoid)
		#     # Remote fetching tags will be extremely slow even no recursive calling (it means an update)
		#     [ -z "${repo_urn:+x}" ] ||
		#     # null "${repo_urn##*"${db}"*}" ||
		#     ! is_writable "$repo_urn" ||
		#     [ ! -d "$SRC_ROOT/$repo_name" ] ||
		#     # [ -z "${repo_ver:+x}" ] ||
		#     # ok "${repo_ver##*"v"*}" &&
		#     # ok "${repo_ver##*"-"*}" &&
		#     # Just enter for history reason, so don't need to consider real git repos
		#     # [ "git" != "$format" ] ||
		#     # [ "git" != "$repo_ver" ] ||
		#     {
		#         # is_in_main "$repo_urn" || // die 'is_in_main' "did wrong thing"
		#         / "IFS=$(printf '%b' "$FS") read -r repo_ver repo_rel \
		#             << $(// here_doc -- sync_remote "$repo_urn")" \
		#             2>/dev/null || // die 'sync_remote' "failed"

		#         # is_version "$repo_ver" && is_version "$repo_rel" ||
		#         # / "IFS=$(printf '%b' "$FS") read -r repo_ver repo_rel \
		#         #     << $(// here_doc -- sync_remote "$repo_urn")" \
		#         #     2>/dev/null || // die 'sync_remote' "failed"

		#         # // ver_dump "$repo_urn" "$repo_ver" "$repo_rel"

		#         # // density_out "$repo_urn" "$repo_urn"
		#     }

		#     # repo_ver="git"
		# } ||
		#
		# Keep pkg_version function read-only
		# repo_ver=0
		#
		version_is_valid=1
	}


	! is_writable "$repo_urn" ||
	[ "$version_is_valid" -eq "0" ] ||
	# Update version from download_something(), ver_dump won't do the job
	// ver_dump "$repo_urn" "$repo_ver" "$repo_rel"

	// debug '$repo_dir' "$repo_dir"
	// debug '$repo_dir_decoded' "$repo_dir_decoded"
	// debug '$repo_ver' "$repo_ver"
	// debug '$repo_rel' "$repo_rel"
	// debug '$repo_alias' "$repo_alias"
	// debug '$repo_url' "$repo_url"
	// debug '$reference_type' "$reference_type"

	printf "$RS%s$FS%s$FS%s$FS%s$FS%s$FS%s" \
		"$repo_dir_decoded" "$repo_ver" "$repo_rel" \
		"$repo_alias" "$repo_url" "$reference_type"

}

# Package version of $KISS_ROOT/$db
version_installed() {
	_level_2
	local repo_urn
	if ok "$1"; then repo_urn="$1"; else repo_urn="kiss"; fi
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"

	local repo_dir= repo_ver= repo_rel= repo_alias= repo_url= reference_type=

	! // || / `pkg_version "$repo_urn" "" "" "$KISS_ROOT/$db" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_dir=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"; \
	repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`

	// log '$repo_dir'           "$repo_dir"
	// log '$repo_ver-$repo_rel' "$repo_ver-$repo_rel"
	// log '$repo_alias'         "$repo_alias"
	// log '$repo_url'           "$repo_url"
	// log '$branch'             "$branch"
}

# Package version details of selected $KISS_PATH
# Output could be "" -- not an integer/version number series
# Input $1 repo_ver : package version string
ver_split() {
	_level_2
	# local name_major="$1" name_minor="$2" name_patch="$3" name_ident="$4" name_suffix="$5"
	# shift 5
	local repo_ver="$1"

	[ -z "${KISS_DEBUG:+x}" ] ||
	(IFS=$', |' && ! list_contains "$FUNCNAME" $KISS_DEBUG) || {

		# local display log_content
		# IFS="$(printf '%b' "$FS")" read -r display log_content <<- EOF
		# $(see "${lineno_scope-"0"}" "$lineno" '$repo_ver' "$repo_ver")
		# EOF
		# # ! // || / `see "${lineno_scope-"0"}" "$lineno" '$repo_ver' "$repo_ver" |
		# #   awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		# # END { print "display=\""$1"\"; log_content=\""$2"\"" }' ||
		# # printf '%s\n' "return 1"`

		# (printf '%s\n' "$display" > "$TTY" &&
		#   printf '%s\n' "$log_content" > "$log_pipe") &
		printf '%s\n' "$(see "${lineno_scope-"0"}" "$lineno" '$repo_ver' "$repo_ver")" > "$TTY"
	}
	# Pay attention that this following line does not promise these variables do not become to undefined
	local repo_major= repo_minor= repo_patch= repo_ident= repo_suffix=
	# Split the version on '.+-_' to obtain individual components.
	IFS=/.+-_ read -r repo_major repo_minor repo_patch repo_ident repo_suffix \
		< <(printf '%s\n' "$repo_ver") > /dev/null ||
	// die "printf '%s\\n' \"$repo_ver\"" "failed"

	// debug_filter -- // debug '$repo_urn'    "$repo_urn"     &
	// debug_filter -- // debug '$repo_major'  "$repo_major"   &
	// debug_filter -- // debug '$repo_minor'  "$repo_minor"   &
	// debug_filter -- // debug '$repo_patch'  "$repo_patch"   &
	// debug_filter -- // debug '$repo_ident'  "$repo_ident"   &
	// debug_filter -- // debug '$repo_suffix' "$repo_suffix"  &

	local hint_found=

	split_routine() {
		local field_name="${1-}"
		/ "local field=\"\${$field_name}\""
		# [ -z "${field:+x}" ] && field=0 ||
		# ${1-} and eval filtered out undefined case, but is_integer is picky
		[ -z "${field:+x}" ] && {
			{
				[ "$field_name" != "repo_ident" ] &&
				[ "$field_name" != "repo_suffix" ]
			} && {
				{
					[ "$hint_found" -eq "0" ]     && field=0
				} || {
					[ "$hint_found" -eq "9999" ]  && field=9999
				}
			} ||
			field=
		} ||
		// is_integer "$field" || {
			// war "\$$field_name" "$field"
			local field_lower="$(printf '%s' "$field" | tr '[A-Z]' '[a-z]')"
			{
				[ "$field_lower" = "init" ]     && field=0 hint_found=0
			} || {
				[ "$field_lower" = "rolling" ]  && field=9999 hint_found=9999
			} ||
			field="$(// delegate -- extract "" "is_integer" "$field")"
			# field="$(// delegate -- extract "" "is_integer" "$field")" ||
			# field=9999
		}
		/ "$field_name=\"\$field\""
	}

	split_routine "repo_major"

	split_routine "repo_minor"

	split_routine "repo_patch"

	split_routine "repo_ident"

	split_routine "repo_suffix"

	printf "$RS%s$FS%s$FS%s$FS%s$FS%s" \
		"${repo_major-}" "${repo_minor-}" "${repo_patch-}" "${repo_ident-}" "${repo_suffix-}"
	# The above implementation performs better than the following
	# / "$name_major=\"$repo_major\""
	# / "$name_minor=\"$repo_minor\""
	# / "$name_patch=\"$repo_patch\""
	# / "$name_ident=\"$repo_ident\""
	# / "$name_suffix=\"$repo_suffix\""
}

# Parse the versions by package manager
# ver_input_______________________________________
#     |         |          |           |         |
# repo_major repo_minor repo_patch repo_ident repo_suffix
#                                      |         |
# rel_input---------------------------------------
ver_parse() {
	_level_2
	# local repo_ver_name="$1"
	# local repo_rel_name="$2"
	# shift 2
	local ver_input="$1"
	readonly ver_input
	local rel_input="${2-}"
	readonly rel_input
	{
		[ ! -z "${ver_input:+x}" ] || [ ! -z "${rel_input:+x}" ]
	} ||
		// die 'ver-rel [input]' "both empty"
	# Medium variables
	local repo_ver="$ver_input" repo_rel="$rel_input"
	# Final result
	local ver_output= rel_output=
	// log 'ver-rel [input]' "'$ver_input' - '$rel_input'"
	# -n without :+x might get wrong result!!!
	# [ -n "${repo_ver:+x}" || repo_ver="9999.9999.9999.9999"
	# ! -z don't need :+x under this scenario
	# [ ! -z "${ver_input:+x}" ] || repo_ver="9999.9999.9999.9999"
	# [ ! -z "${rel_input:+x}" ] || repo_rel="0"
	# The following two lines require extremely strong specification
	# repo_ver="${ver_input%%-*}"
	# repo_rel="${ver_input##*-}"

	# Remove leading non-numeric characters
	# luajit
	# v2.0.0-beta2-hotfix2
	# v2.0.0-beta8-fixed
	# v2.1.ROLLING
	# llvmorg-15.0.6
	local length="$(expr length "$ver_input")"
	local index=-1
	while [ "$index" -lt "$length" ]; do
		: $((index += 1))
		local element="${ver_input:$index:1}"
		[ ! -z "$element" ] || continue
		! is_integer "$element" || continue
		repo_ver="${repo_ver#"$element"}"
	done

	# while
	#   case "$repo_ver" in
	#       "v"*)
	#           repo_ver="${repo_ver##"v"}"
	#           # echo "$repo_ver"
	#           // debug '$repo_ver' "$repo_ver [leading \"v\" removed]"
	#           ;;
	#       *)
	#           break
	#   esac
	# do
	#   :
	# done

	# After this moment, repo_ver != ver_input
	# luajit
	# v2.0.0-beta2-hotfix2
	# v2.0.0-beta8-fixed
	# v2.1.ROLLING
	# llvmorg-15.0.6
	# llvmorg-19-init
	[ ! -z "${rel_input:+x}" ] || {
		[ ! -z "${repo_ver:+x}" ] &&
		[ -z "${repo_ver##*"."*}" ] && [ -z "${repo_ver##*"-"*}" ] && {
			# [ "$(// delegate -- occurrences "$repo_ver" "-")" -ne "1" ] || {
			# repo_ver lost things after -
			# Don't use ver_input as input, otherwise the leading "v" and leading number's "-" will ruin ver_split
			# llvmorg-15.0.6
			repo_ver="${repo_ver%%-*}"
			# repo_rel="${ver_input##*-}"
			repo_rel="${repo_ver#*-}"
			// debug 'rp_ver - rp_rel' "'$repo_ver' - '$repo_rel'"
			# }
		}
	}

	# Does Semantic Versioning allow 4 components in version numbers?
	# https://softwareengineering.stackexchange.com/questions/298720/does-semantic-versioning-allow-4-components-in-version-numbers
	case "$repo_ver" in
		*"-"*|*"."*|*"+"*|*"_"*|*"/"*)
			local repo_major= repo_minor= repo_patch= repo_ident= repo_suffix=

			# ver_split repo_major repo_minor repo_patch repo_ident repo_suffix "$repo_ver"

			! // || / `ver_split "$repo_ver" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			END { print "repo_major=\""$1"\"; \
			repo_minor=\""$2"\"; \
			repo_patch=\""$3"\"; \
			repo_ident=\""$4"\"; \
			repo_suffix=\""$5"\"" }' ||
			printf '%s\n' "return 1"`

			readonly repo_major repo_minor \
				repo_patch repo_ident repo_suffix

			[ -z "${repo_major:+x}" ] ||
			! // is_integer "$repo_major" ||
				ver_output="$repo_major"

			[ -z "${repo_minor:+x}" ] ||
			! // is_integer "$repo_minor" ||
				ver_output="${ver_output:+"${ver_output}."}$repo_minor"

			[ -z "${repo_patch:+x}" ] ||
			! // is_integer "$repo_patch" ||
				ver_output="${ver_output:+"${ver_output}."}$repo_patch"

			[ -z "${repo_ident:+x}" ] ||
			! // is_integer "$repo_ident" ||
				ver_output="${ver_output:+"${ver_output}."}$repo_ident"
			;;
		*)
			# User defined version
			[ -z "${ver_input:+x}" ] || {
				// war '$ver_input' "'$ver_input' format is not standardized"
				# ver_output="$ver_input"
			}
	esac

	local dot_counts=
	[ -z "${ver_output:+x}" ] ||
	dot_counts="$(// delegate -- occurrences "$ver_output" ".")"

	rel_output="$repo_rel"

	[ -n "${repo_suffix:+x}" ] &&
	rel_output="$repo_suffix" || {
		[ ! -z "${rel_input:+x}" ] ||
		[ -z "${repo_ident:+x}" ] || {
			rel_output="$repo_ident"
			# The Forth element is the $repo_ident
			[ "$dot_counts" -lt "3" ] || {
				ver_output="${ver_output%.*}"
				: $((dot_counts -= 1))
			}
		}
	}

	# Completments
	# 3 fields/components in version numbers (which comes with 2 dots)
	# while [ "$((2 - dot_counts))" -gt "0" ]; do
	#   ver_output="${ver_output:+"${ver_output}."}0"
	#   : $((dot_counts += 1))
	# done

	# is_version "$ver_output" || ver_output="0.0.0"
		# ver_output="9999.9999.9999.9999"

	readonly ver_output

	// debug '$ver_output' "$ver_output" &

	# is_version "$ver_output" ] || // war '$ver_output' "'$ver_output' is not a version"
	# is_version "$rel_output" ] || // war '$rel_output' "'$rel_output' is not a version"

	is_version "$rel_output" ] ||
	! is_version "$ver_output" ] || {
		rel_output=0
		// debug '$rel_output' "'$rel_output' rounded" &
	}
	readonly rel_output

	// debug '$rel_output' "$rel_output" &

	// war 'ver-rel [output]' "'$ver_output' - '$rel_output'"

	# / "$repo_ver_name=\"$ver_output\""
	# / "$repo_rel_name=\"$rel_output\""
	printf "$RS%s$FS%s" "$ver_output" "$rel_output"

	is_version "$ver_output" && is_version "$rel_output" &&
		return 0 ||
		return 1
}

version_dirs() {
	_level_2
	local location="$1"
	local no_release_part="${2-}"
	set --
	local index=0
	while IFS= read -r path || [ ! -z "$path" ]; do
		local item_basename="${path##*/}"
		local item="${item_basename%%-*}"
		is_version "$item" || continue
		# When $no_release_part is not empty, just capture pure version string
		# From this design to improve related dialer's performance if they don't care so precise info
		[ -z "${no_release_part:+x}" ] || item_basename="$item"
		# (IFS="$newline" && list_contains "$item_basename" $result_list) ||
		! (IFS="$newline" && list_contains "$item_basename" "$@") || continue
		# result_list="${result_list:+${result_list}$newline}${item_basename}"
		# set -- "$@" "${item_basename}"

		[ "$index" -eq "0" ] &&
			# delegate: Version 1 / Version 2 / Version 3
			printf "$RS%s" "$item_basename" ||
			# delegate: Version 1 / Version 2 / Version 3
			printf "$FS%s" "$item_basename"

		: $((index += 1))
	done < <(// as_own "$location" find -L "$location" -mindepth 1 -maxdepth 1 -type d)

}

ver_dump() {
	_level_2

	local repo_urn="$1"
	local repo_ver="$2" repo_rel="$3"

	# local ver="$2"
	# local rel="$3"
	# local repo_ver="$2"
	# local repo_rel="$3"

	{
		[ ! -z "${repo_ver:+x}" ] || [ ! -z "${repo_rel:+x}" ]
	} ||
		// die 'repo_ver-repo_rel [input]' "both empty"

	// log 'repo_ver-repo_rel [input]' "'$repo_ver' - '$repo_rel'"

	local format="$(// delegate -- pkg_format "$repo_urn")"

	equ "$format" "git" ||
		// die '$format' "'$format' is not git"

	# local repo_dir="$4"

	// log '$repo_ver' "$repo_ver"
	// log '$repo_rel' "$repo_rel"
	is_version  "$repo_ver" || // die '$repo_ver' "$repo_ver"
	is_version  "$repo_rel" || // die '$repo_rel' "$repo_rel"

	# Read the version file
	local ver_origin rel_origin \
		alias_origin repo_url reference_type
	IFS=$' ' read -r ver_origin rel_origin \
		alias_origin repo_url reference_type 2>/dev/null \
		< "$repo_urn/version" ||
	// die "$repo_name" "failed to read $repo_urn/version"

	// log '$ver_origin' "$ver_origin"
	// log '$rel_origin' "$rel_origin"
	// log '$alias_origin' "$alias_origin"

	local repo_alias="$alias_origin"
	[ -n "${repo_url:+x}" ] || repo_alias=

	# Compare differences between the parsing result and the version file
	! { equ "$ver_origin" "$repo_ver" &&
		equ "$rel_origin" "$repo_rel" &&
		equ "$alias_origin" "$repo_alias"; } ||
	{
		// log 'version update' "is not necessary"
		return 0
	}

	# Check the design
	is_writable "$repo_urn" || // die 'version file' "'$repo_urn/version' is readonly"

	local repo_url_encoded="$repo_url"
	case "$repo_url" in
		*"$REPO_URL"*)
			repo_url_encoded="$( \
			// delegate -- bicode "edoc" "$repo_url" "REPO_URL" "$REPO_URL")"
	esac

	// log '$repo_urn' "$repo_urn"
	// log '$repo_ver' "$repo_ver"
	// log '$repo_rel' "$repo_rel"
	// log '$repo_alias' "$repo_alias"

	is_version "$repo_ver" || repo_ver=0
	is_version "$repo_rel" || repo_rel=0

	# Write the version info to file
	/usr/bin/printf '%s %s %s %s %s\n' \
		"$repo_ver" \
		"$repo_rel" \
		"$repo_alias" \
		"$repo_url_encoded" "$reference_type" |
		// as_own "$repo_urn/version" tee "$repo_urn/version" > /dev/null ||
		// die 'permission denied' "on writting version to file $repo_urn/version"

	# Reading back to verify it
	local _ver _rel _repo_urn _alias _url _reference_type
	IFS=$' ' read -r _ver _rel \
		_alias _url _reference_type < "$repo_urn/version" 2>/dev/null ||
	// die "$repo_name" "failed to read $repo_urn/version"

	local _url_decoded="$_url"
	case "$_url" in
		*"REPO_URL"*)
			_url_decoded="$( \
				// delegate -- bicode "code" "$_url" "REPO_URL" "$REPO_URL")" ;;
		*);;
	esac

	nohup git_sync \
		_ "$_alias" "$_url_decoded" "$_reference_type" \
		> /dev/null 2>&1 &

	[ "$_ver"   = "$repo_ver" ] &&
	[ "$_rel"   = "$repo_rel" ] &&
	[ "$_alias" = "$repo_alias" ] &&
	[ "$_url"   = "$repo_url_encoded" ] &&
	is_repos "$repo_urn" || {
		// log '$_ver'           "$_ver"
		// log '$_rel'           "$_rel"
		// log '$_alias'         "$_alias"
		// log '$_url'           "$_url"
		// log '$_url_decoded'   "$_url_decoded"
		// log '$reference_type' "$reference_type"

		// die 'version update' "failed"
	}

	# // density_out "$repo_urn" "$repo_urn"

}

density_out() (
	_level_2
	[ "$#" -ge "3" ] || // die '$#' "not enough parameters gave $# but needs 3"
	local repo_urn="$1"

	[ ! -z "${repo_urn:+x}" ] || {
		// die '$repo_urn' "'${repo_urn:+"${repo_urn} "}'has not been provided"
		return 1
	}

	local target_ancestor="${2-}"

	# [ -n "${target_ancestor:+x}" ] || {
	#   local ancester_list=
	#   ancestors "ancester_list" "$repo_urn"
	#   local item
	#   for item in $ancester_list; do
	#       target_ancestor="$item"
	#       break
	#   done
	# }

	local repo_target="$KISS_ROOT/$db/${repo_urn##*/}"

	[ ! -L "$repo_urn" ] ||
	repo_urn="$(readlink -fn "$repo_urn")"

	[ ! -L "$target_ancestor" ] ||
	target_ancestor="$(readlink -fn "$target_ancestor")"

	local index="${3-"-1"}"
	local display_header="${4-""}"

	# local repo_dir=
	# local repo_ver=
	# local repo_rel=
	# local repo_alias=
	# local repo_url=
	# local reference_type=

	# shellcheck disable=SC1035
	!!
	local format="$(// delegate -- pkg_format "$repo_urn")"
	^^

	local index_repo_urn=0
	for item in $repo_urn; do
		// debug '$item' "$item"
		: $((index_repo_urn += 1))
	done
	[ "$index_repo_urn" -eq "1" ] || // die '$repo_urn' "\"$repo_urn\" is an array?"
	!!
	# IFS=$' ' read -r repo_ver repo_rel _ 2>/dev/null < "$repo_urn/version" ||
	#     // die "$repo_urn" "failed to read $repo_urn/version"

	local repo_dir= repo_ver= repo_rel= repo_alias= repo_url= reference_type=

	! // || / `pkg_version "$repo_urn" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_dir=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"; \
	repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`


	^^
	local scope_origin="$scope"
	local func_name_origin="$func_name"
	length_trim "repo_ver" "$((2 * TABSTOP))"
	length_trim "repo_rel" "$TABSTOP"
	local route=
	local color_parent_origin="$color_parent"
	local color_line_origin="$color_line"
	local color_child_origin="$color_child"
	local color_content="$color_end"
	# color_child="$color_parent"

	[ -n "${repo_urn##*"$db"*}" ] && {
		! is_model "$repo_target" "$repo_urn" ||
		# { route=">o<"; local color_parent='\033[1;45m'; local color_child='\033[1;07m'; }
		{
			route="$O"
			local color_parent='\033[1;45m'
			local color_line="$color_parent"
			local color_content="$color_parent"
		}
	} ||
		# { route="<x>"; local color_parent='\033[1;45m'; local color_child='\033[1;07m'; }
		{
			route="$I"
			local color_parent='\033[1;45m'
			local color_line="$color_parent"
		}

	[ "$target_ancestor" != "$repo_urn" ] ||
	{
		route="$E"
		local color_parent='\033[1;45m'
		local color_line="$color_parent"
		local color_content="$color_parent"
	}

	[ -z "${display_header:+x}" ] &&
	! equ "$index" "0" || {
		local title='No.'
		local length_index="$((${#title} + 1))"
		local margin_index="$((TABSTOP - length_index))"
		[ "$margin_index" -ge "0" ] || margin_index="$(tabstop_remainder $length_index)"
		// debug '$margin_index' "$margin_index"
		scope='$repo_name'
		func_name="$( \
			printf "%-${TABSTOP}s %-${margin_index}s%s" 'Format' "" "$title")"
			# A title line (no evaluations)
		// cue "$(printf "%-$((2 * TABSTOP))s %-${MARGIN_ROUTE}s%-${TABSTOP}s" \
			'$ver' "" '$rel')" '$repo_urn'
			# '$ver' "" '$rel')" '$repo_urn $route (>o< == out, <x> == in)'
	}

	local length_index="$((${#index} + 1))"
	local margin_index="$((TABSTOP - length_index))"
	[ "$margin_index" -ge "0" ] || margin_index="$(tabstop_remainder $length_index)"
	// debug '$margin_index' "$margin_index"
	scope="${repo_urn##*/}"
	# local index_wrapper="$(printf '%b%b%d%b' "$color_end" "$COLOR_HINT" $index "$color_end")"
	# func_name="$(printf "%-${TABSTOP}s %-${margin_index}s%b" "$format" "" "$index_wrapper")"
	func_name="$(printf "%-${LENGTH_VER}s %-${TABSTOP}d" "${repo_urn##*/}" "$index")"
	[ "$((index % 2))" -eq "0" ] ||
	[ ! -z "$route" ] || {
		color_parent="$COLOR_WARN"
		color_child="$COLOR_HIGH"
		color_line="$color_parent"
	}

	// log "$(printf "%-$((2 * TABSTOP))s %-${MARGIN_ROUTE}s%-${TABSTOP}s" \
		"$repo_ver" "" "$repo_rel")" \
		"$(printf '%b%s%b' "$color_content" "$repo_urn" "$color_end")"
		# "$repo_ver" "" "$repo_rel")" "$repo_urn${route:+" ${route}"}"

	[ "$((index % 2))" -eq "0" ] ||
	[ ! -z "$route" ] || {
		local color_line="$color_line_origin"
		local color_child="$color_child_origin"
		local color_parent="$color_parent_origin"
	}
	func_name="$func_name_origin"
	scope="$scope_origin"
)

valid_tail() (
	_level_2
	local target_file="$1"
	local tail_deep=1
	[ -s "$target_file" ] || // die '$target_file' "'$target_file' is empty"
	local found=
	local lines="$(wc -l "$target_file" | cut -f 1 -d ' ')"
	while [ -z "${found:+x}" ] && [ "$tail_deep" -le "$lines" ]; do
		found="$(tail -n "$tail_deep" "$target_file")"
		: $((tail_deep += 1))
	done
	[ -n "${found:+x}" ] || // die '$target_file' "\"$target_file\" is invalid"
	# Hung up?
	# // log '$found' "'$found'"
	printf "$RS%s" "$found"
)

is_repos() (
	_level_2
	local result=0
	local repo_urn
	for repo_urn do
		local not_repo=1

		[ -d "$repo_urn" ] || return "$not_repo"
		# local repo_urn="$1"
		local repo_name="${repo_urn##*/}"
		repo_name="${repo_name%%@*}"

		// debug_filter -- // debug '$repo_urn' "$repo_urn"

		case "$repo_urn" in
			*.tar|*.tar.??|*.tar.???|*.tar.????|*.t?z|*.zip)
				// debug_filter -- // debug '$repo_urn' "return from tar cases"
				# return 0
				! empty "$EXTRACT_ROOT/$repo_name" || {
					# find "$EXTRACT_ROOT/$repo_name" -mindepth 1 -delete
					# for item in $(// as_own "$EXTRACT_ROOT" \
					#   find "$EXTRACT_ROOT/$repo_name" -mindepth 1 -maxdepth 1); do
					#   # choices folder items won't accept removing by normal users even it's is owned by the normal user
					#   [ ! -e "$item" ] || [ ! -h "$item" ] ||
					#   // as_usr "root" \rm -rf "$item";
					# done
					// mkcd "$EXTRACT_ROOT/$repo_name" ||
						// die 'mkcd' "failed"
					// decompress "$repo_urn" | tar xf -
				}
				repo_urn="$EXTRACT_ROOT/$repo_name/$db/$repo_name"

				# continue
		esac

		# [ ! -x "$repo_urn/build" ] ||
		! command -v "$repo_urn/build" > /dev/null 2>&1 ||
		# [ ! -f "$repo_urn/sources" ] ||
		# Recursively calling between is_repos and pkg_format
		# { [ ! -f "$repo_urn/version" ] &&
		# [ "git" != "$(// delegate -- pkg_format "$repo_urn")" ]; } || {
		[ ! -f "$repo_urn/version" ] ||
		{
			// debug_filter -- // debug '$repo_urn' "return from files check"
			# return 0
			continue
		}
		// debug_filter -- // debug '$repo_name' "$repo_name"
		// debug_filter -- // debug '$not_repo' "$not_repo"
		return "$not_repo"
	done
	return "$result"
)

# repo_name / repo_name
# $KISS_ROOT/$db/$repo_name $REPO_ROOT/main/$repo_dir/$repo_name $REPO_ROOT_IMPL/*/$repo_dir/$repo_name
# repo_target               <- repo_source
# repo_target               <- target_source                        <- target_ancester
ancestors() {
	local ancester_list_name="$1"
	local repo_urn="$2"
	shift 2
	local repo_name="${repo_urn##*/}"
	local target_ancester=
	local ancester_list=
	[ ! -f "$repo_urn/version" ] || {

		local _dir= _ver= _rel= _alias= _url= _reference_type=
		local condidates=

		! // || / `pkg_version "$repo_urn" "" "-d" "${repo_urn%/*}" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "_dir=\""$1"\"; _ver=\""$2"\"; _rel=\""$3"\"; \
		_alias=\""$4"\"; _url=\""$5"\"; _reference_type=\""$6"\"" }' ||
		printf '%s\n' "return 1"`


		[ -z "$_url" ] || {
			{
				[ -n "${_url##*"KISS_REPO"*}" ] &&
				[ -n "${_url##*"REPO_ROOT"*}" ]
			} ||
				_url="$(// delegate -- bicode "code" "$_url" "KISS_REPO" "$KISS_REPO")"

			[ "$#" -ne "0" ] || {
				# query_repos "condidates" "$repo_name"
				condidates="$(// delegate '\n' query_repos "$repo_name")"
				local item
				for item in $condidates; do
					set -- "$@" "$item"
				done
			}

			# git_sync \
			#   condidates "$_alias" "$_url" "$_reference_type"

			local item
			for item do
				[ -f "$item/version" ] || continue

				local i_dir= i_ver= i_rel= i_alias= i_url= i_reference_type=

				! // || / `pkg_version "$item" "" "-d" "${item%/*}" |
					awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
				END { print "i_dir=\""$1"\"; i_ver=\""$2"\"; i_rel=\""$3"\"; \
				i_alias=\""$4"\"; i_url=\""$5"\"; i_reference_type=\""$6"\"" }' ||
				printf '%s\n' "return 1"`

				{
					[ -n "${i_url##*"KISS_REPO"*}" ] &&
					[ -n "${i_url##*"REPO_ROOT"*}" ]
				} ||
					i_url="$(// delegate -- bicode "code" "$i_url" "KISS_REPO" "$KISS_REPO")"

				[ "$i_url" = "$_url" ] || continue
				# is_model "$item" "$repo_urn" || continue
				target_ancester="$item"
				// log '$target_ancester' "$target_ancester"
				(IFS="$newline" &&
					list_contains "$target_ancester" $ancester_list) ||
					ancester_list="${ancester_list:+"${ancester_list}${newline}"}$target_ancester"
			done
		}

		[ -n "${target_ancester:+x}" ] || {
			target_ancester="$repo_urn"
			// log '$target_ancester' "$target_ancester"
			(IFS="$newline" &&
				list_contains "$target_ancester" $ancester_list) ||
				ancester_list="${ancester_list:+"${ancester_list}${newline}"}$target_ancester"
		}
	}

	/ "$ancester_list_name=\"$ancester_list\""

}

query_repos() {
	_level_2
	# local source_list_name="$1"
	local repo_name="$1"

	# When using source_list_name to return results, do not define the folowing line
	# If you define source_list here, it will localize parent scope one
	# local item source_list candidates

	local item candidates

	[ ! -L "${KISS_REPO}" ] || {
		local real_repo_main="$(readlink -fn "${KISS_REPO}")"
		// log '$real_repo_main' "$real_repo_main"
		case "$real_repo_main" in
			*"$REPO_ROOT_IMPL"*) ;;
			*)
				candidates="$( \
					// as_own "$real_repo_main/" find -L "$real_repo_main/" \
					\( -type d -o -type l \) \
					-name "${repo_name}" | sort -u \
					)"
		esac
	}

	candidates="${candidates:+"${candidates}${newline}"}$( \
		// as_own "$REPO_ROOT_IMPL/" find -L "$REPO_ROOT_IMPL/" \
		\( -type d -o -type l \) \
		-not \( -path "$REPO_ROOT_IMPL/choices" -type d -prune \) \
		-not \( -path "$REPO_ROOT_IMPL/installed" -type d -prune \) \
		-not \( -path "$REPO_ROOT_IMPL/hooks" -type d -prune \) \
		-name "${repo_name}" | sort -u \
		)"

		# -not \( -path "$real_repo_main" -type d -prune \) \
	local index=0
	for item in $candidates; do
		is_repos "$item" || continue
		# source_list="${source_list:+"${source_list}${newline}"}$item"
		[ "$index" -eq "0" ] && printf "$RS%s" "$item" ||
		printf "$FS%s" "$item"
		: $((index += 1))
	done
	# // debug '$source_list' "$(esceval $source_list)" &
	# / "$source_list_name=\"\$source_list\""

}

name_plain() {
	# local repo_name="$1"
	# repo_name="${repo_name#/}"
	#
	# Extremely slow
	# local repo_name_plain="$(printf '%s' "$repo_name" | tr '-' '_' | tr '.' '_' | tr '*' '_' | tr '/' '_')"

	# local repo_name_plain="$(printf '%s' "$repo_name" | sed -e 's/-/_/g' -e 's/./_/g')"

	# local repo_name_plain="$(printf '%s' "$repo_name" |
	#   sed 's/[^a-zA-Z0-9]/_/g')"
	#   # sed -e 's/-/_/g' -e 's/\./_/g' -e 's/\*/_/g' -e 's#/#_#g')"
	#
	# printf "$RS%s" "$repo_name_plain"
	# printf '%s' "${1#/}" | sed 's/[^a-zA-Z0-9]/_/g'
	printf '%s' "${1#/}" | tr -c '[a-zA-Z0-9]' '_'
}

# Query package from $REPO_ROOT without being limited by $KISS_PATH
# and install it from the query index (optional)
# $1 repo_urn : package repo url/uri or package  name
# $2 index    : the selected index
pick_up() {
	_level_2
	CROSS_ACTION="pick"
	local index=0
	[ -z "${IS_KISS+x}" ] || {
		trap_print "trap_status" "INT|TERM|QUIT|PIPE|EXIT"
		[ -n "$trap_status" ] || {
			# printf '%s %s\n' 'trap' "definitions at $LINENO"
			// war 'trap' "definitions"
			trap
		}
	}
	# // trap_off

	[ -t 0 ] || { // war 'fd 0' "recovered"; exec </dev/tty; }

	# Final sources
	local install_list=
	# Candidates
	local source_list=
	local indexes_picked=

	# Single target only
	local repo_urn
	local repo_name
	# $KISS_ROOT/$db/$repo_name
	local repo_target
	# is_model "$target_source" "$repo_target" == true
	local target_source
	local mirror_list=

	local explicit= makedeps= deps=

	# trap '' INT TERM QUIT

	print_indexes() {
		local index=
		for index do
			// war '$indexes_picked' "$(delegate -- format "$index") selected"
		done
	}

	local expect_list=
	# Just reference by density_out
	# Output  : target_source
	# Input   : dep_name
	# Input   : candidate_list (positional)
	_mirror_list() {
		_level_2

		local target_source_name="$1"
		local mirror_list_name="$1"
		shift 2
		local dep_name="$1"
		shift 1
		dep_name="${dep_name##*/}"
		local repo_target="$KISS_ROOT/$db/$dep_name"
		local target_source=
		local target_ancestor=
		local result=1
		// debug '$#' "$#"
		# set -x
		local expect_item="$(IFS="$newline" &&
			// delegate filter_contains "key_filter" "$dep_name" $expect_list)"
		[ -z "$expect_item" ] || {
			target_source="$(IFS="$newline" &&
			// delegate filter_contains "key_filter" "$dep_name" $mirror_list)"
			[ -z "${target_source:+x}" ] || result=0
			/ "$target_source_name=\"$target_source\""
			/ "$mirror_list_name=\"$mirror_list\""
			return $result
		}

		# set +x
		for item do
			// is_model "$item" "$repo_target" || continue
			target_source="$item"
			// log '$target_source' "$target_source"
			[ ! -z "$(IFS="$newline" &&
				// delegate filter_contains "key_filter" "$target_source" $mirror_list)" ] ||
				mirror_list="${mirror_list:+"${mirror_list}${newline}"}$target_source"
			break
		done

		# Time consuming, deprecated
		[ -n "${target_ancestor:+x}" ] &&
		[ ! -z "$(IFS="$newline" &&
		// delegate filter_contains "key_filter" "$target_ancestor" $mirror_list)" ] ||
		[ ! -f "$repo_target/version" ] || {
			local ancester_list=
			ancestors "ancester_list" "$repo_urn" "$@" & ancestors_pid=$!
			// progress "$ancestors_pid" "ancestors querying"
			for target_ancestor in $ancester_list; do
				break
			done
		}
		# This is the key step
		local dep_name_plain="$(name_plain "$dep_name")"
		/ "pkg_${dep_name_plain}_ancestor=\"\$target_ancestor\""

		# Keys design begin
		# [ -z "${USE_KEYS:+x}" ] || {
		#     [ -n "${target_ancestor-}" ] ||
		#     [ ! -f "$repo_target/keys" ] || {
		#         local last_sentence="$(// delegate -- valid_tail "$repo_target/keys")"
		#         [ -z "${last_sentence:+x}" ] || {
		#             IFS=$' ' read -r _ _ repo_record < <(printf '%s\n' "$last_sentence") \
		#                 > /dev/null || // die "printf '%s\\n' $last_sentence" "failed"
		#             repo_record="$(// delegate -- bicode "code" "$repo_record" "KISS_REPO" "$KISS_REPO")"
		#             [ ! -d "$repo_record" ] || {
		#                 target_ancestor="$repo_record"
		#                 // log '$target_ancestor' "$target_ancestor"
		#             }
		#         }
		#     }
		# }
		# Keys design end

		[ ! -z "${target_source:+x}" ] &&
			// density_out "$target_source" "$target_ancestor" "-1" ||
			// war '$target_source' "'$target_source' not found"

		[ ! -z "$(IFS="$newline" &&
			// delegate filter_contains "key_filter" "$dep_name" $expect_list)" ] ||
			expect_list="${expect_list:+"${expect_list}${newline}"}$dep_name"

		/ "$target_source_name=\"$target_source\""
		/ "$mirror_list_name=\"$mirror_list\""
	}

	# Out of date
	# For interactive
	# Output: install_list
	_install_list() {
		_level_2
		local indexes_picked="$1"
		shift 1

		# Without {}, highlight will be ruined
		[ "$#" -lt "2" ] || {
			# set -- $(// delegate '\n' version_priority "left_is_lower" "$repo_name" "$@")
			# Saved 10 seconds then above
			set -- $(// delegate '\n' version_priority "left_is_less" "$repo_name" "$@")
		}

		local selected_from_index=

		// debug '$indexes_picked' "$indexes_picked"
		local install_source
		local index_iter=0
		for install_source do
			local dep_name="${install_source##*/}"
			is_repos "$install_source" || continue

			// debug '$install_source' "$install_source"
			local index=
			local ifs="$IFS"
			local IFS=$' ,|'
			# [ -z "${indexes_picked##*"a"*}" ] && {
			#   [ ! -z "$(IFS="$newline" &&
			#   // delegate filter_contains "key_filter" "$install_source" $install_list)" ] || {
			#       install_list="${install_list:+"${install_list}${newline}"}$install_source"
			#       selected_from_index=1

			#       local target_source
			#       // _mirror_list "target_source" "mirror_list" "$repo_urn" "$@"
			#       // density_out "$install_source" "$target_ancestor" "$index_iter"
			#   }
			# } ||
			# null "$indexes_picked" || [ "$index_iter" != "$indexes_picked" ] || {
			for index in $indexes_picked; do
				equ "$index" "$index_iter" || continue
				# This is the key step
				local dep_name_plain="$(name_plain "$dep_name")"
				/ "pkg_${dep_name_plain}_repo=\"\$install_source\""

				# Won't work
				# IFS="$ifs"
				// debug '$indexes_picked' "$indexes_picked"
				// debug '$install_source' "$install_source"
				[ ! -z "$(IFS="$newline" &&
					// delegate filter_contains "key_filter" "$install_source" $install_list)" ] || {
					install_list="${install_list:+"${install_list}${newline}"}$install_source"
					selected_from_index=1

					// _mirror_list "target_source" "mirror_list" "$install_source" "$@"
					/ "local target_ancestor=\"\${pkg_${dep_name_plain}_ancestor}\""
					# Select item as new source and should be highlight
					// density_out "$install_source" "$install_source" "$index" 1
					break
				}
			done
			# }
			IFS="$ifs"
			: $((index_iter += 1))
		done
		# // cue '$install_list' "$install_list"
		# Could not return a list with $newline as delimiter elegantly
		# printf "$RS%s" "$install_list" > /dev/stdout
	}

	check_list() {
		_level_1
		local dep_name="$1"
		shift 1

		local indexes_picked=
		# local indexes_picked="$1"
		# shift 1

		local dep_name_plain="$(name_plain "$dep_name")"

		local install_list=
		local target_source=
		local index_valid=0
		local repo_only
		local selected_from_index=

		// log '$SHLVL' "$SHLVL"
		# [ -t 0 ] || { printf '%s %s\n' 'fd 0' "recovered" >> "$INIT_OUTPUT"; exec </dev/tty; }
		# [ -t 1 ] || { printf '%s %s\n' 'fd 1' "recovered" >> "$INIT_OUTPUT"; exec &>/dev/tty; }
		# [ -t 2 ] || { printf '%s %s\n' 'fd 2' "recovered" >> "$INIT_OUTPUT"; exec &>/dev/tty; }
		[ -t 0 ] || { // war 'fd 0' "recovered"; exec </dev/tty; }
		# Will break return values mechanism
		# [ -t 1 ] || { // war 'fd 1' "recovered"; exec &>/dev/tty; }
		# [ -t 2 ] || { // war 'fd 2' "recovered"; exec &>/dev/tty; }

		# // war 'trap' "definitions"
		# trap
		# trap - INT TERM QUIT
		# trap 'exit' INT TERM
		# -- real code moved to documents because it will ruin the data recovery
		# trap 'stty intr <c-\>; exit' INT TERM

		# -- real code moved to documents because it will ruin the data recovery
		# trap 'stty intr <c-\>; exit' INT TERM QUIT

		# trap 'kill -s INT $$' INT TERM
		# trap 'pkill --pgroup 0' INT TERM
		# trap 'printf '%s\n' ""; return 0' EXIT

		# trap ' \
		# ! pid_alive "$SESSION_PID" || kill -USR1 "$SESSION_PID"; \
		# // kill_name "$CROSS_ACTION" "{kiss}" "${0##*/}"; \
		# ' EXIT

		# trap ' \
		# printf "%s\n" " USR1 triggered "; \
		# // kill_all "{kiss}" "${0##*/}"; \
		# ! pid_alive "$SESSION_PID" || kill -USR1 "$SESSION_PID"; \
		# ' INT TERM QUIT PIPE

		# exit; \

		# trap " \
		# printf '%s\n' \"USR1 triggered\"; \
		# // debug_filter -- printf '%s %s\n' '\$PID_SAY' \"\${PID_SAY-}\"; \
		# // debug_filter -- printf '%s %s\n' '\$PID_LOG' \"\${PID_LOG-}\"; \
		# // pipe_cancel \"\PID_SAY\"; \
		# // pipe_cancel \"\PID_LOG\"; \
		# " USR1
		# trap "kill_all $@" EXIT
		#         trap " \
		# // pipe_cancel \"\PID_SAY\"; \
		# // pipe_cancel \"\PID_LOG\"; \
		# kill_all kiss; \
		# " EXIT

		# listen
		# trap_print "trap_status" "INT|TERM|QUIT|PIPE|EXIT"
		# [ -n "$trap_status" ] || {
		#     # printf '%s %s\n' 'trap' "definitions at $LINENO"
		#     // war 'trap' "definitions"
		#     trap
		# }

		# trap

		# -- real code moved to documents because it will ruin the data recovery
		# stty intr <c-c>; \
		# stty intr <c-\>; \
		#
		# Only process single target
		# local single_target=0

		[ -n "${target_source:+x}" ] || {

			# Deprecated -- multiple dep_name in one list defign
			# local repo_name_global=

			# local index_iter=0
			# for repo_url do
			#   local dep_name="${repo_url##*/}"
			#   [ "$index_iter" -ne "0" ] || repo_name_global="$dep_name"
			#   [ "$dep_name" = "$repo_name_global" ] || { single_target=1; break; }
			#   # [ "$dep_name" != "$repo_name_global" ] &&
			#   # { single_target=1; break; } || continue
			#   : $((index_iter += 1))
			# done

			# [ "$single_target" -eq "1" ] || {
				# repo_target="$KISS_ROOT/$db/$repo_name_global"
			repo_target="$KISS_ROOT/$db/$dep_name"

				# is_model "$target_source" "$repo_target" ||
				# // _mirror_list "target_source" "mirror_list" "$repo_name_global" "$@"
			// _mirror_list "target_source" "mirror_list" "$dep_name" "$@"
			# pkg_${dep_name_plain}_ancestor was just evaluated above
			/ "local target_ancestor=\"\${pkg_${dep_name_plain}_ancestor}\""

			# }
		}

		! is_repos "$target_source" ||
		(IFS="$newline" && list_contains "$target_source" "$@") ||
		set -- "$@" "$target_source"
		# Without {}, highlight will be ruined
		[ "$#" -lt "2" ] || {
			# set -- $(// delegate '\n' version_priority "left_is_lower" "$repo_name" "$@")
			# Saved 10 seconds then above
			set -- $(// delegate '\n' version_priority "left_is_less" "$repo_name" "$@")
		}
		# readonly single_target
		# [ "$single_target" -ne "1" ] ||
		#   // die '$single_target' "'$single_target' equals 1 is not the design"

		# printf '%s\n' ""
		// log '' ""
		local repo_url
		local index_iter=0
		for repo_url do
			# local dep_name="${repo_url##*/}"
			is_repos "$repo_url" || continue
			# Moved to find command
			# {
			#     # Because the package name in depends files is not mutable
			#     # While the folder name assumes the function of the package name
			#     # We don't maintain a pkgname variable in configure files
			#     is_repos "$repo_url" ||
			#     continue
			# }

			# // war '$indexes_picked' "$indexes_picked"
			# // war '$index_iter' "$index_iter"
			# case "$index_iter" in
			#     $indexes_picked)
			local ifs="$IFS"
			local IFS=$' ,|'
			for index in $indexes_picked; do
				equ "$index" "$index_iter" || continue
				# Won't work
				# IFS="$ifs"
				// debug '$indexes_picked' "$indexes_picked"
				// debug '$repo_url' "$repo_url"
				# null "$indexes_picked" || [ "$index_iter" != "$indexes_picked" ] || {
				[ ! -z "$(IFS="$newline" &&
					// delegate filter_contains "key_filter" "$repo_url" $install_list)" ] ||
				install_list="${install_list:+"${install_list}${newline}"}$repo_url"

				# [ "$single_target" -eq "0" ] &&
				# is_repos "$target_source" || {
				#   // _mirror_list "target_source" "mirror_list" "$dep_name" "$@"

				#   ! is_repos "$target_source" ||
				#   [ ! -z "$(IFS="$newline" &&
				#   // delegate filter_contains "key_filter" "$target_source" "$@")" ] ||
				#   set -- "$@" "$target_source"
				# }
				selected_from_index=1
				# }
				break
			done
			# esac
			IFS="$ifs"

			// density_out "$repo_url" "${target_ancestor}" "$index_iter"
			# // density_out "$(realpath "$repo_url" 2>/dev/null ||
			# echo -n "$repo_url")" "$target_source" "$indexes_picked"

			repo_only="$repo_url"
			: $((index_valid += 1))

			local repo_dir="${repo_url%/*}"
			local pkg_selected="${repo_url##*/}"

			// debug '$repo_dir' "$repo_dir"
			// debug '$pkg_selected' "$pkg_selected"
			: $((index_iter += 1))
		done

		[ -z "${install_list:+x}" ] ||
		[ -z "${selected_from_index:+x}" ] ||
		// cue '$install_list' \
			"listed above came from \$indexes_picked == '$indexes_picked'"

		[ -n "${repo_only:+x}" ] || {
			// war '${repo_only##*/}' "NONE"
			# printf "$RS%s" "" > /dev/stdout
			return 0
		}

		[ "$index_valid" -ne "1" ] || {
			install_list="$repo_only"
			// cue '$install_list' "came from the only valid element: '$repo_only'"
			# printf "$RS%s" "$install_list" > /dev/stdout
			for repo in $install_list; do
				// log 'install_list : repo' "$repo"
			done
			indexes_picked=0
			// _install_list "$indexes_picked" "$@"
			return 0
		}

		# // war 'input' "pause"
		# local answer="$(// delegate -- read_line)"
		# // war 'inputed' "$answer"

		[ -z "${install_list:+x}" ] || {
			# // war '$install_list' "$install_list"
			for repo in $install_list; do
				// log 'install_list : repo' "$repo"
			done
		}

		# local indexes_picked=
		# "0" means not using prompt
		[ -z "${KISS_PROMPT+x}" ] || ! equ "$KISS_PROMPT" 0 || {
			// _install_list "$indexes_picked" "$@"

			/ "is_repos \"\${pkg_${dep_name_plain}_repo}\"" &&
			return 0 || {
				// war '$indexes_picked' "'$indexes_picked' is invalid"
				# / "${pkg_${dep_name_plain}_repo}=\"$KISS_ROOT/$db/$dep_name\""
				return 1
			}
		}

		# // prompt "indexes_picked" "1. Choose index numbers(devided by space/comma/bar) \
		# // prompt "indexes_picked" "1. Choose index numbers(1 2/1,2/1|2)${newline}\
		# Or Enter/Ctrl-\\/Ctrl-C for cancel"
		# indexes_picked="$( \
		# // delegate -- prompt "Choose index numbers(1 2/1,2/1|2) ${newline}\
		#   Or Enter/Ctrl-C/Ctrl-\\/Ctrl-D-Enter for cancel")"
		indexes_picked="$( \
			// delegate -- prompt \
			"Input an index number listed above (not editable)${newline}\
			Or Enter/Ctrl-C/Ctrl-\\/Ctrl-D-Enter for cancel${newline}\
			and be patient for remote synchronizing, please")"

		# local indexes_numbers="$(// delegate -- extract " " "is_integer" "$indexes_picked")"
		# local indexes_count="$(// delegate list_length $indexes_numbers)"
		# // log '$indexes_count' "$indexes_count"
		# [ "${indexes_count}" -lt "$target_count" ] || {
		#   print_indexes $indexes_numbers
		#   // _install_list "$indexes_picked" "$@"
		#   // debug '$install_list' "$install_list"
		# }

		# ${newline}2. * for all, \

		# // war '' "1. Choose index numbers(devided by space/comma/bar) \
		# ${newline}2. * for all, \
		# ${newline}Or Enter/Ctrl-\\/Ctrl-C for cancel"
		# Won't work
		# indexes_picked="$(// delegate -- read_line)"

		# read -r indexes_picked </dev/tty
		# readline indexes_picked
		# trap 'kill_all kiss' INT TERM QUIT

		[ -t 0 ] || {
			// war 'fd 0' "does not work"
			# exec </dev/stdin
			exec </dev/tty
		}

		# local control
		# readc control < /dev/tty continue 2> /dev/null

		# [ -t 0 ] || // war 'fd 0' "does not work"
		# [ ! -t 0 ] || {
		#     # stty -g
		#     stty_settings=$(stty -g)
		#     stty -icanon min 1 time 0 || ! pid_alive "$SESSION_PID" || kill -USR1 "$SESSION_PID"
		# }
		# -- real code moved to documents because it will ruin the data recovery
		# control='<c-c>'
		# while
		#     # content=$(dd if=/dev/stdin ibs=1 count=1 </dev/stdin continue 2> /dev/null; echo .)
		#     content=$(dd bs=1 count=1 2> /dev/null; echo .)
		#     # content=$(read -r line </dev/stdin continue 2> /dev/null; echo ${line}.)
		#     content=${content%.}
		#     [ -n "$content" ] &&
		#     eval "control=\${control}"'$content
		#     [ "$(($(printf %s "$control" | wc -m )))" -eq 0 ]'; do
		#     continue
		# done
		# [ ! -t 0 ] ||
		# stty $stty_settings || ! pid_alive "$SESSION_PID" || kill -USR1 "$SESSION_PID"
		#
		# // war '$control' "$control"
		# -- real code moved to documents because it will ruin the data recovery
		# { equ "$control" '<c-c>' || equ "$control" '<c-\>' || equ "$control" '<enter>' ||
		#     equ "$control" "<c-c><enter>" || equ "$control" "<c-\><enter>"; } && {
		#     # ! pid_alive "$SESSION_PID" || kill -USR1 "$SESSION_PID"
		#     # / 'printf %s\n "stty intr \<c-\>"'
		#     // war '$control' "$control"
		#     printf '\n%s' ""
		#     return 0
		#     :
		# } || {
		#     [ ! -t 0 ] || {
		#         stty_settings=$(stty -g)
		#         stty -icanon min 1 time 0 || ! pid_alive "$SESSION_PID" || kill -USR1 "$SESSION_PID"
		#         # stty -icanon min 0 time 0
		#     }
		#     # trap 'tput setf 1; tput hold; read; tput init' DEBUG
		#     # local fd=19
		#     while
		#         # set -x
		#         # indexes_picked="$( \
		#         #     # exec 3<&0
		#         #     read -r <&3 line "$fd" continue 3<&0 {fd}< /dev/tty 2> /dev/null ; echo ${line}.
		#         # )"
		#         indexes_picked="$(read -r line </dev/stdin continue 2> /dev/null ; echo "$control${line}.")"
		#         # exec 3<&-
		#         # set +x
		#         # indexes_picked="$(sed 1q)."
		#         [ "${#indexes_picked}" -eq 0 ]; do
		#         continue
		#     done
		#     [ ! -t 0 ] || stty "$stty_settings" || ! pid_alive "$SESSION_PID" || kill -USR1 "$SESSION_PID"
		#     indexes_picked="${indexes_picked%.}"
		# } # control charater

		# [ -z "$indexes_picked" ] && {
		#     // check_list "$dep_name" "$@" || :
		#     # printf "$RS%s" ""
		#     # return 0
		# } || {
		# [ -z "$indexes_picked" ] || {
		#   local repo_url
		#   index_iter=0
		#   for repo_url do
		#       local dep_name="${repo_url##*/}"
		#       # null "$indexes_picked" && {
		#       #     install_list="${install_list:+"${install_list}${newline}"}$repo_url"
		#       #     break
		#       # }
		#       local ifs="$IFS"
		#       local IFS=$' ,|'
		#       for index in $indexes_picked; do
		#           equ "$index" "$index_iter" || continue
		#           (IFS="$newline" && list_contains "$repo_url" $install_list) || {
		#               install_list="${install_list:+"${install_list}${newline}"}$repo_url"

		#               [ "$single_target" -eq "0" ] && is_repos "$target_source" ||
		#               // _mirror_list "target_source" "mirror_list" "$dep_name" "$@"

		#               // density_out "$repo_url" "$target_ancestor" "$index_iter"
		#               break
		#           }
		#       done
		#       IFS="$ifs"
		#       : $((index_iter += 1))
		#   done
		# }

		# local indexes_numbers="$(// delegate -- extract " " "is_integer" "$indexes_picked")"
		# local indexes_count="$(// delegate list_length $indexes_numbers)"
		# // log '$indexes_count' "$indexes_count"
		[ ! -z "${indexes_picked:+x}" ] &&
		// is_integer "$indexes_picked" || {
			// war '$indexes_picked' "'$indexes_picked' is not an integer"
			// check_list "$dep_name" "$@" || :
		}
		# [ "${indexes_count}" -ge "$target_count" ] && {
		#   print_indexes $indexes_numbers
			// _install_list "$indexes_picked" "$@"
			# pkg_${dep_name_plain}_repo was just evaluated above
			/ "local repo_selected=\"\${pkg_${dep_name_plain}_repo}\""
			// debug '$repo_selected' "$repo_selected"
		# } ||
		# / "is_repos \"\${pkg_${dep_name_plain}_repo}\"" ||
		is_repos "$repo_selected" ||
			// check_list "$dep_name" "$@" || :

		# // prompt "indexes_picked" "Enter if there are no other changes" || :
		# null "$indexes_picked" && break || :
		# // prompt "indexes_picked" "Enter if there are no other changes"
		# // war ''  "Enter if there are no other changes"
		# IFS= read -r indexes_picked </dev/tty

		# } # [ -n "$install_list" ] ||

		# local repo_url
		# local index_iter=0
		# for repo_url in $install_list; do
		#     // density_out "$repo_url" "$target_ancestor" "$index_iter"
		#     : $((index_iter += 1))
		# done

		# [ -n "${KISS_PROMPT+x}" ] && equ "$KISS_PROMPT" 0 ||
		# // prompt "indexes_picked" "Enter if there are no other changes" || :
		# null "$indexes_picked" || // die '$indexes_picked' "cancelled"
		#
		# Could not return a list with $newline as delimiter elegantly
		# printf "$RS%s" "$install_list" > /dev/stdout
	}

	pick_up_perfrom() {
		local explicit="$1"
		local makedeps="$2"
		local deps="$3"
		shift 3

		PREFER_CACHE=

		type_include "pkg_checksum" "function" ||
			// die 'function' "'pkg_checksum' is not defined"
		# // trap_on "p" $1
		local repo_url
		# for repo_url in $explicit $makedeps $deps; do
		#   // cue 'checksum' "$repo_url"
		#   action="checksum"
		#   // pkg_checksum "$repo_url" 2>&1 ||
		#   // die '$repo_url' "pkg_checksum failed"
		# done

		local makedeps_install_list=
		for repo_url in $makedeps; do
			local repo_name="${repo_url##*/}"
			repo_name="${repo_name%%@*}"
			local repo_target="$KISS_ROOT/$db/$repo_name"
			! is_repos "$repo_target" ||
			[ ! -z "$(// delegate filter_contains "key_filter" "$repo_target" $explicit)" ] || continue

			[ -z "$(// delegate filter_contains "key_filter" "$repo_target" $makedeps_install_list)" ] ||
			makedeps_install_list="${makedeps_install_list:+${makedeps_install_list}$newline}$repo_url"
			// cue 'checksum' "$repo_url"
			action="checksum"
			// pkg_checksum "$repo_url" 2>&1 ||
			// die '$repo_url' "pkg_checksum failed"
		done

		local deps_install_list=
		for repo_url in $deps; do
			local repo_name="${repo_url##*/}"
			repo_name="${repo_name%%@*}"
			local repo_target="$KISS_ROOT/$db/$repo_name"
			! is_repos "$repo_target" ||
			[ ! -z "$(// delegate filter_contains "key_filter" "$repo_target" $explicit)" ] || continue

			[ -z "$(// delegate filter_contains "key_filter" "$repo_target" $deps_install_list)" ] ||
			deps_install_list="${deps_install_list:+${deps_install_list}$newline}$repo_url"
			// cue 'checksum' "$repo_url"
			action="checksum"
			// pkg_checksum "$repo_url" 2>&1 ||
			// die '$repo_url' "pkg_checksum failed"
		done

		// debug_filter -- // log '$explicit' "$(esceval $explicit)"
		// debug_filter -- // log '$makedeps_install_list' "$(esceval $makedeps_install_list)"
		// debug_filter -- // log '$deps_install_list' "$(esceval $deps_install_list)"
		# // cue 'build_all "$explicit" "$makedeps" "$deps"' \
		#   "'$(esceval $explicit)'${newline}'$(esceval $makedeps)'${newline}'$(esceval $deps)'"
		action="build"
		# ! // build_all "$explicit" "$makedeps" "$deps" 2>&1
		// build_all "$explicit" "$makedeps_install_list" "$deps_install_list" 2>&1 ||
		// die '$repo_url' "build_all failed"
		# || {
		#     // cue 'pkg_install' "$repo_url"
		#     // log '$repo_url' "$repo_url"
		#     # export KISS_FORCE=; // args "install" "$repo_url" 2>&1 || :
		#     # (export KISS_FORCE=; // args "install" "$repo_url")
		#     if ! equ "$LOGNAME" "root"; then
		#         // subshell_all "install" "$repo_url" 2>&1 || :
		#         // log 'test' "test_04"
		#     else
		#         // pkg_install "$repo_url" 2>&1 || :
		#     fi
		# }
		# done
		// cue 'install' "$explicit"
		# // subshell_all "install" "$@" 2>&1 ||
		// alter "install" $explicit 2>&1 ||
		// die '$@' "'$explicit' install failed"
	}

	# Initial parameters route
	# Input : package name select index
	# Output : repo_name, repo_urn, source_list, indexes_picked, part of install_list
	if ok "$1"; then
		# This "$1" is always a package name
		# If you want to pick up init system "66" under index syntax, you could use
		# things like "/var/db/kiss/lm/system/66" as parameter
		# if ok "$1" && ! is_integer "$1"; then
		# repo_name="${1##*/}"
		repo_urn="$1"
		# repo_urn="$( \
		#   [ -d "$1" ] &&
		#   realpath "$1" 2>/dev/null || echo -n "$1")"
		repo_name="${repo_urn##*/}"

		if is_repos "$repo_urn"; then
			// log '$repo_name' "$repo_name came from \$1 = '$1'"
			install_list="$repo_urn"
			// cue '$install_list' ">o< '$install_list' came from \$1 == '$1' [route 0-0]"
			source_list="$repo_urn"
			# Means the only option
			indexes_picked="$index"

		else
			// log '$repo_urn' "$repo_urn"
			// log '$repo_name' "'$repo_name' manual inputed"
			repo_target="$KISS_ROOT/$db/$repo_name"
			# "$repo_urn" is not a repo here
			# [ -z "${repo_urn:+x}" ] ||
			# [ -z "${repo_urn##*"${db}"*}" ] ||
			# ! is_model "$KISS_ROOT/$db/$repo_name" "$repo_urn" ||
			# target_source="$repo_urn"

			# local real_repo_main="$(readlink -fn "${KISS_REPO}")"
			# // log '$real_repo_main' "$real_repo_main"
			# source_list="$(// as_own "$REPO_ROOT_IMPL/" find -L "$REPO_ROOT_IMPL/" \
			#   \( -type d -o -type l \) \
			#   -not \( -path "$real_repo_main" -type d -prune \) \
			#   -not \( -path "*/installed/*" -type d -prune \) \
			#   -not \( -path "*/hooks/*" -type d -prune \) \
			#   -name "${repo_name}" | sort -u)"

			source_list="$(// delegate '\n' query_repos "$repo_name")"
			# // debug '$source_list' "$source_list" &
			// debug '$source_list' "$(esceval $source_list)" &
			# No interaction, you know the answer
			null "${2-}" || {
				indexes_picked="${2}"
				// cue 'repo_urn : index' "'$repo_urn' : '$indexes_picked' explicitly given [route 0-0]"
			}
		fi
	elif is_repos "${PWD}"; then
		# If is_repos "${PWD}" == false, giving an integer index doesn't make sense
		# So, "$1" is always a package name or not have any "$1"
		repo_urn="${PWD}"
		repo_name="${repo_urn##*/}"
		// log '$repo_name' "$repo_name came from \$PWD = $PWD"
		install_list="$repo_urn"
		// cue '$install_list' ">o< '$install_list' came from \$PWD == '$PWD' [route 1-0]"
		source_list="$repo_urn"
		# Means the only option
		indexes_picked="$index"
	else
		// war '$PWD' "does not have repo_urn files"
		local item
		for item in $(\ls -1); do
			! is_repos "$item" || pick_up "$item"
		done
		return 0
	fi

	explicit="$repo_urn"

	# $explicit_count != $#
	local order= redro=
	# Order the argument list based on dependence.
	! // || / `pkg_order "$explicit" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "explicit=\""$1"\"; makedeps=\""$2"\"; deps=\""$3"\"; \
	order=\""$4"\"; redro=\""$5"\"" }' ||
	printf '%s\n' "return 1"`

	local item=
	local index=0
	for item in $makedeps; do
		! key_filter "$item" "$repo_name" ||
			// die '$repo_name' "'$repo_name' is a target, not a host depenedncy"
		# // war '$makedeps : $item' "'$item'"
		// war "$(// delegate format $index $TABSTOP) : \$makedeps" "$item"
		: $((index += 1))
	done

	local item=
	local index=0
	for item in $deps; do
		! key_filter "$item" "$repo_name" ||
			// die '$repo_name' "'$repo_name' is a target, not a depenedncy"
		# // war '$deps : $item' "'$item'"
		// war "$(// delegate format $index $TABSTOP) : \$deps" "$item"
		: $((index += 1))
	done

	local index=0
	# Construct integrity
	for item in $order $explicit; do
		# Main target use the same naming convention
		local dep_name="${item##*/}"
		local dep_name_plain="$(name_plain "$dep_name")"
		/ "local pkg_${index}=\"\$dep_name\""
		/ "local pkg_${dep_name_plain}_index=\"\$index\""
		[ "$dep_name" = "$repo_name" ] && {
			/ "local pkg_${dep_name_plain}_repo=\"\$repo_urn\""
			/ "local pkg_${dep_name_plain}_sources=\"\$source_list\""
		} || {
			/ "local pkg_${dep_name_plain}_repo="
			/ "local pkg_${dep_name_plain}_sources="
		}
		/ "local pkg_${dep_name_plain}_ancestor="
		: $((index += 1))
	done

	local target_count="$index" # ||
		# // die '$repo_urn' "'$repo_urn' is the current repo"
	# readonly target_count
	// log '$target_count' "$target_count"

	has_integrity() {
		local resut=0
		local dep_name

		for index in $(seq 0 1 $((target_count - 1))); do
			/ "dep_name=\${pkg_${index}}"
			local dep_name_plain="$(name_plain "$dep_name")"
			/ "local repo=\${pkg_${dep_name_plain}_repo}"
			! is_repos "$repo" ||
			# [ -z "$(IFS="$newline" &&
			#   // delegate filter_contains key_filter $dep_name $install_list)" ] ||
			#   # // delegate / "filter_contains key_filter ${pkg_${index}} $install_list")" ] ||
				continue
			resut=1
			break
		done

		return $resut
	}

	# local color_child_origin="$color_child"
	// debug '$LENGTH_VER' "$LENGTH_VER"
	// debug '$MARGIN_ROUTE' "$MARGIN_ROUTE"

	is_repos "${target_source:+x}" || {
		// _mirror_list "target_source" "mirror_list" "$repo_urn" $source_list

		! is_repos "${target_source-}" ||
		(IFS="$newline" && list_contains "$target_source" $source_list) ||
		source_list="${source_list:+"${source_list}${newline}"}$target_source"
	}

	[ -n "${source_list:+x}" ] || {
		// war "$repo_name" "NONE"
		return 0
	}

	set -- $source_list

	[ -z "${indexes_picked:+x}" ] ||
	! // is_integer "$indexes_picked" ||
	// _install_list "$indexes_picked" "$@"

	has_integrity || {
		local dep_name
		for index in $(seq 0 1 $((target_count - 1))); do
			/ "dep_name=\${pkg_${index}}"
			local dep_name_plain="$(name_plain "$dep_name")"
			/ "local repo=\${pkg_${dep_name_plain}_repo}"
			/ "local sources=\${pkg_${dep_name_plain}_sources}"
			is_repos "$repo" ||
			# [ ! -z "$(IFS="$newline" &&
			#   // delegate filter_contains key_filter $dep_name $install_list)" ] ||
			// check_list "$dep_name" $sources || :
		done
	}

	# local indexes_numbers="$(// delegate -- extract " " "is_integer" "$indexes_picked")"
	# local indexes_count="$(// delegate list_length $indexes_numbers)"
	# // log '$indexes_count' "$indexes_count"
	# [ "${indexes_count}" -lt "$target_count" ] || {
	#   print_indexes $indexes_numbers
	#   // _install_list "$indexes_picked" "$source_list"
	# }

	set --
	# local repo
	# for repo in $install_list; do
	for index in $(seq 0 1 $((target_count - 1))); do
		/ "dep_name=\${pkg_${index}}"
		local dep_name_plain="$(name_plain "$dep_name")"
		/ "local repo=\${pkg_${dep_name_plain}_repo}"
		// debug '$repo' "$repo"
		REPO_DIR="${REPO_DIR:+"${REPO_DIR}:"}${repo%/*}"
		set -- $@ "$repo"
	done
	// log '$#' "$#"
	[ "$#" -gt "0" ] && is_repos "$@" || return 0

	# // prompt "content" "Pick up the repo_urn shows above?" ||
	# // die '$repo_urn' "'$repo_urn' was cancelled"
	local repo_tips="repo_urn"
	[ "$#" -le "1" ] || repo_tips="repo_urns"
	local content=
	content="$( \
		// delegate -- prompt \
			"Pick up the selected $repo_tips shows above?${newline}\
		Enter for Yes/Ctrl-C|n|N for cancel")" ||
		// die 'prompt' "failed"

	// log '$content' "$content"
	! expr "$content" : '[n|N]\+' > /dev/null || return 0
	export REPO_DIR
	// pick_up_perfrom "$explicit" "$makedeps" "$deps"
	// log 'test' "test_05"
}

! // || [ "$lineno" -eq "$LINENO" ] || // war '$lineno : $LINENO' "$lineno : $LINENO"

# Figure out which repository a package belongs to (repo_urn)
# or print applications in $PATH (executable applications path)
# $1 repo_name/repo_urn  : might has asterisk mark (*), and works with set +f
# $2 list option        : list_type
#                       : "" for the first one encountered (default)
#                       : "mirror" return the target_source
#                       : "pure" for neither $db nor global $REPO_DIR nor $REPO_BASE
#                       -- just from "main" repo and are promised to be unique
#                       : "all" for repositories/executables,
# $3 shell (test) flag  : target_type
#                       : -d for repo (default)
#                       : -x for executable
# $4 search_dir         :
#                       : $db for installed repo
#                       : $KISS_PATH for package manager recommended repo
#                       : $PATH for executable
# Paths don't have repo_name
# repo_trace is the semantic. -x is an extension
repo_trace() {
	_level_2
	local repo_urn="$1"
	local list_type="${2-}"
	// debug_filter -- // debug '$list_type' "$list_type"
	local target_type=
	[ ! -z "${3:+x}" ] &&
	target_type="$3" || {
		{
			[ "pure" = "$list_type" ] ||
			[ "mirror" = "$list_type" ]
		} && target_type="-d" ||
		[ -z "${4:+x}" ] ||
		case "$4" in
			*"${REPO_ROOT_IMPL#*/}"*|*"${REPO_ROOT#*/}"*)
				target_type="-d" ;;
			*"bin"*)
				target_type="-x"
		esac

		[ ! -z "${target_type:+x}" ] ||
			// log '$target_type' "'$target_type' better given explicitly"

		# [ ! -z "${target_type:+x}" ] || target_type="-d"
	}

	// debug_filter -- // debug '$target_type' "$target_type"
	ok "$list_type" ||
	equ "$target_type" "-x" ||
	repo_urn="$(standardize "$repo_urn")" # repo_name=${repo_name%%\*}
	local repo_dir_inputed="${repo_urn%/*}"
	# $repo_name might like kiss-b*/kiss-r*/kiss-i* ...
	local repo_name="${repo_urn##*/}"
	// debug_filter -- // debug '$repo_dir_inputed' "$repo_dir_inputed"
	// debug_filter -- // debug '$repo_name' "$repo_name"
	local search_dir="${4:-"$KISS_PATH"}"

	local repo_result=

	equ "$target_type" "-x" || {
		[ -n "${list_type:+x}" ] ||
		{ ok "$search_dir" &&
			! equ "$search_dir" "$KISS_ROOT/$db"; } ||
		# ! (IFS="$(printf ":")" && list_contains "$KISS_ROOT/$db" $search_dir) ||
		{ ok "$repo_dir_inputed" &&
			! equ "$repo_dir_inputed" "$KISS_ROOT/$db"; } ||
		# ! (IFS="$(printf ":")" && list_contains "$KISS_ROOT/$db" $repo_dir_inputed) ||
		! is_repos "$KISS_ROOT/$db/$repo_name" || {
			# Suppose that you said: repo_trace $repo_name "" "" "$KISS_ROOT/$db"
			repo_result="$KISS_ROOT/$db/$repo_name"
			printf "$RS%s" "$repo_result"
			return 0
		}
		# local real_path="$(realpath "$4" 2>/dev/null || echo -n "$4")"
		# [ -n "${real_path##*"/"*}" ] || search_dir="$4"
		[ "pure" = "$list_type" ] ||
		# Respect given search_dir
		# [ -n "${search_dir:+x}" ] &&
		[ -n "${search_dir##*":"*}" ] ||
		[ -z "${REPO_DIR:+x}" ] || {
			# [ -z "${search_dir##*"${db}"*}" ] ||
			# search_dir="${search_dir:+"${search_dir}:"}$KISS_ROOT/$db"
			local ifs="$IFS"
			local IFS=$':'
			local _dir
			for _dir in $REPO_DIR; do
				(IFS=$':' && list_contains "${_dir}" $search_dir) ||
				search_dir="${_dir}${search_dir:+":${search_dir}"}"
			done
			IFS="$ifs"
		}
		is_repos "$repo_urn" || repo_dir_inputed=
	}

	# Figure out which repository a package belongs to by searching for
	# directories matching the package name in $KISS_PATH/*.
	# set -- "$1" "${2:=""}" "$3" "${4:-"$KISS_PATH"}"
	set -- "$repo_name" "$list_type" "$target_type" "$search_dir"

	// debug_filter -- // debug '$@' "$(esceval "$@")"

	local ifs="$IFS"
	local IFS=$':'
	# Iterate over KISS_PATH, grabbing all directories which match the query.
	local dir repo name search_path=
	for dir in $search_dir; do
		[ -d "$dir" ] || continue
		// debug_filter -- // debug '$dir' "$dir"
		dir="$(readlink -f "$dir")" || // war '$dir' "$dir"
		(IFS=$':' && list_contains "$dir" $search_path) ||
		search_path="${search_path:+"${search_path}:"}$dir"
	done
	# Intentional.
	# shellcheck disable=2086
	// debug_filter -- // debug '$search_dir' "$search_dir"
	// debug_filter -- // debug '$search_path' "$search_path"
	for dir in $search_path; do
		null "$dir" || {
			dir="$(standardize "$dir")"
			// debug_filter -- // debug '$dir' "$dir"
		}
		# Expansion might mistake folder name for an implied package name
		set +f

		# Merged null "$list_type" and ok "$list_type" into one
		# if null "$list_type"; then
		#
		# // log '$list_type' "$list_type"
		# $repo_name might like kiss-b* / kiss-r* / kiss-i* ...
		# So do not quote them !
		local repo_list=$dir/$repo_name

		[ "pure" = "$list_type" ] ||
		[ "${dir##*/}" != "base" ] ||
			repo_list=$repo_list${newline}$dir/*/$repo_name

		# Might be a list like "/usr/bin/kiss-bup${newline}/usr/bin/kiss-chroot"
		// debug_filter -- // debug '$repo_list' "$(esceval $repo_list)"
		# It's a absolute path
		local repo
		IFS=$newline
		for repo in $repo_list; do
			// debug '$repo' "$repo"
			repo="$(standardize "$repo")"
			// debug '$repo' "$repo"
			[ ! -z "${target_type:+x}" ] || {
				[ -d "$repo" ] && target_type="-d" || target_type="-x"
			}
			(IFS="$newline" && list_contains "$repo" "$@") ||
			# ! test "${target_type:--d}" "$repo" || {
			! test "$target_type" "$repo" || {
				# Executable will be directly adapted
				equ "$target_type" "-x" ||
				# Let's say repo_urn == $PKG_ROOT/var/db/kiss/installed/$repo_name
				# And repo == $REPO_BASE/$repo_name or $KISS_REPO/*/$repo_name
				// is_model "$repo_urn" "$repo" || {
					[ "mirror" != "$list_type" ] &&
					# Input is just a repo_name, so adapt anything above a certain threshold
					null "$repo_dir_inputed"
				} ||
					continue

				set -f -- "$@" "$repo"

				# Not just the first one encountered
				ok "$list_type" &&
				[ "mirror" != "$list_type" ] || break
			}
		done
		IFS=$':'
		// debug_filter -- // debug '$#' "$#"
		# else    # ok "$list_type"
		#     // log '$list_type' "$list_type"
		#     IFS=$newline
		#     for name in $(\ls -1 "$dir" 2>/dev/null | \
		#                 grep "$(standardize "$repo_name")"); do
		#         // debug '$name' "$name"
		#         repo=$dir/$name
		#         repo="$(standardize "$repo")"
		#         // debug '$repo' "$repo"
		#         (IFS="$newline" && list_contains "$repo" "$@") ||
		#         ! test "${target_type:--x}" "$repo" ||
		#             set -f -- "$@" "$repo"
		#     done
		#     IFS=$':'
		#     // debug '$#' "$#"
		# fi
	done
	IFS="$ifs"
	IFS="$IFS_ORIGIN"

	set -f

	// debug_filter -- // debug 'search done'
	// debug_filter -- // debug '$#' "$#"
	// debug_filter -- // debug '$list_type-$#' "$list_type-$#"

	# Figure out which repository a package belongs to by searching for
	# Show all search results if called from 'kiss search', else store the
	# values in variables. If there are 4 arguments, no package has been found.
	case $list_type-$# in
		*-4)
			equ "$target_type" "-x" || {
				repo_result="$(// delegate -- pkg_base "$repo_name")"
				[ "$?" -eq "0" ] && is_repos "$repo_result" || {
					repo_result=
					printf "$RS%s" "$repo_result"
					# For delegate happy
					return 0    # // die '$repo_name' "not found"
				}
			}
			;;
		-*) # null "$list_type"
			# Just the first one encountered
			repo_result="$(standardize "$5")"
			// debug '$repo_result' "$repo_result"
			;;
		*)  # ok "$list_type"
			# Not just the first one encountered
			shift 4
			local item
			for item do
				[ -z "${repo_result:+x}" ] &&
				# delegate: Version 1 / Version 2 / Version 3
				printf "$RS%s" "$item" ||
				# delegate: Version 1 / Version 2 / Version 3
				printf "$FS%s" "$item"

				(IFS="$newline" && list_contains "$(readlink -f "$item")" $repo_result) ||
					repo_result="${repo_result:+"${repo_result}$newline"}$item"
			done
			// debug_filter -- // debug '$applications' "$(esceval $repo_result)"
			# (IFS="$RS" && { local item; for item do echo "\$item = $item" > $TTY; done; })
			# For pkg_help_ext() -- without empty line (\n) at the first line
			# Works
			# printf '%s' "$repo_result"
			return 0
	esac

	// debug_filter -- // debug '$repo_result' "$repo_result"

	printf "$RS%s" "$repo_result"
}

list_version() {
	_level_2
	// debug '$#' "$#"
	local repo_urn="${1:-"${PWD##*/}"}"
	// debug '$repo_urn' "$repo_urn [input]"

	# List installed packages. As the format is files and directories, this
	# just involves a simple for loop and file read.

	// debug '$KISS_ROOT/$db' "$KISS_ROOT/$db"

	# Optional arguments can be passed to check for specific packages. If no
	# arguments are passed, list all.
	if null "$repo_urn"; then
		set +f; set -f -- "$KISS_ROOT/$db"/*
	else
		set -- "$repo_urn"
	fi
	# Loop over each package and print its name and version.
	local index=0
	for repo_urn do
		// debug '$repo_urn' "$repo_urn [output]"
		local repo_name="${repo_urn##*/}"

		local repo_dir= repo_ver= repo_rel= repo_alias= repo_url= reference_type=

		! // || / `pkg_version "$repo_urn" "" "" "$KISS_ROOT/$db" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "repo_dir=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"; \
		repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
		printf '%s\n' "return 1"`

		# // log "${repo_urn}" "$repo_ver-$repo_rel"
		# // density_out "$repo_urn" "" "$index"
		// density_out "$repo_urn" "" "-1"
		: $((index += 1))
	done
}

# Should be subshell function
# How to use:
# local tar_file="$(// delegate -- pkg_cache "$repo_urn")"
# $1 repo_urn : package repo url/uri
pkg_cache() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	// log '$TAR_ROOT' "$TAR_ROOT"

	# Find the tarball of a package using a glob. Use the user's set compression
	# method if found or first match of the below glob.

	local repo_dir= repo_ver= repo_rel= repo_alias= repo_url= reference_type=

	! // || / `pkg_version "$repo_urn" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_dir=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"; \
	repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`

	// log '$repo_ver' "$repo_ver"
	// log '$repo_rel' "$repo_rel"

	set +f -- "${TAR_ROOT}/${repo_name}/${repo_name}@${repo_ver}-${repo_rel}.tar."
	set -f -- "${1}$KISS_COMPRESS" "${1}"*

	local tar_file=""

	// log '$1' "$1"
	// log '$2' "$2"

	# If the first match does not exist, use the second. If neither exist,
	# this function returns 1 and the caller handles the error.
	if [ -f "$1" ]; then
		tar_file="$1"
	elif [ -f "$2" ]; then
		tar_file="$2"
	else
		// log '$tar_file' "for \"$repo_urn\" is going to be built"
	fi

	// debug '$1' "$1"
	// debug '$2' "$2"
	// debug '$tar_file' "$tar_file"

	printf "$RS%s" "$tar_file"
}

is_archive() {
	# local archive_local="$ARCHIVE_ROOT/$repo_name/${dest:+"$dest/"}$src_name"
	local archive_local="$1"
	# local archive_local_res_type="file"
	local target_is_archive=1
	case "$archive_local" in
		*.tar|*.tar.??|*.tar.???|*.tar.????|*.t?z|*.zip)
			# archive_local_res_type="archive"
			target_is_archive=0
	esac
	return $target_is_archive
}

# Given a route of the input from a sources file single line with parameters (src_url)
# to a designated target folder name (dest), translate parameters and return
# an absolute directory (_local_dir) and a target name (_target_name) pointed
# to the local resource as if they're already there -- "you'd better do it that way"
# -- errors come out if not.
# Input
# $1 repo_urn  : package repo url/uri
# $2 src_url   : source link (in sources file)
# $3 dest      : destination / source folder name (in sources file)
# $4 action
# How to use
# ! // || / `local_route "$repo_urn" "$src_url" "$dest" "$action" |
#   awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs }
#   END { print "_local_dir=\""$1"\"; _res_type=\""$2"\"; _res=\""$3"\"; \
#       _target_name=\""$4"\"" }' ||
#       printf '%s\n' "return 1"`
# Can not capture <() errors
# IFS=$(printf '%b' "$FS") read -r _local_dir _res_type _res _target_name \
#     < <(// delegate -- local_route "$repo_urn" "$src_url" "$dest" \
#         "$action") > /dev/null || // die 'local_route' "failed"
# Output
# _local_dir    : target file/folder parent directory
# _res_type     : resource type
# _res          : local source or remote url
# _target_name  : target file/folder name
local_route() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
		repo_urn="$(// delegate -- repo_trace "$repo_name")"
	ok "$repo_urn" || // die '$repo_urn' "$repo_urn"
	local src_url="$2"
	local dest="$3"
	local action="${4-}"
	# real_url     : reemote source url / local relative location
	# _res is the final url ("l" stands for location)
	local _res_type= _res= _target_name= _local_dir= real_url=

	ok "${2%%\#*}" || {
		printf "$RS%s$FS%s$FS%s$FS%s" "" "" "" ""
		return 0
	}

	local repo_dir= repo_ver= repo_rel= repo_alias= repo_url= reference_type=

	! // || / `pkg_version "$repo_urn" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_dir=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"; \
	repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`

	local repo_major= repo_minor= repo_patch= repo_ident= repo_suffix=

	# ver_split repo_major repo_minor repo_patch repo_ident repo_suffix "$repo_ver"

	! // || / `ver_split "$repo_ver" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_major=\""$1"\"; \
	repo_minor=\""$2"\"; \
	repo_patch=\""$3"\"; \
	repo_ident=\""$4"\"; \
	repo_suffix=\""$5"\"" }' ||
	printf '%s\n' "return 1"`

	// debug_filter -- // debug '$repo_major' "$repo_major"
	// debug_filter -- // debug '$repo_minor' "$repo_minor"
	// debug_filter -- // debug '$repo_patch' "$repo_patch"
	// debug_filter -- // debug '$repo_ident' "$repo_ident"
	// debug_filter -- // debug '$repo_name'  "$repo_name"

	: "${ARCH:="${KISS_XHOST_ARCH}"}"
	# [ -n "${ARCH:+x}" ] || // die '$ARCH' "${ARCH:+"${ARCH} "}must be defined"
	// log '$ARCH' "$ARCH"
	local real_url="$src_url"
	case "$src_url" in
		*"KISS_REPO"*|*"ARCH"*|*"VERSION"*|*"RELEASE"*|*"MAJOR"*|*"MINOR"*|*"PATCH"*|*"IDENT"*|*"PACKAGE"*)
			real_url="$(// delegate -- bicode "code"  \
					"${src_url%"${src_url##*[!/]}"}"  \
					"KISS_REPO" "$KISS_REPO"          \
					"ARCH"      "$ARCH"               \
					"VERSION"   "$repo_ver"           \
					"RELEASE"   "$repo_rel"           \
					"MAJOR"     "$repo_major"         \
					"MINOR"     "$repo_minor"         \
					"PATCH"     "$repo_patch"         \
					"IDENT"     "$repo_ident"         \
					"PACKAGE"   "$repo_name")"
	esac
	// log '$real_url/uri' "$real_url"

	set -- "$repo_name" "$real_url" "${dest%"${dest##*[!/]}"}" "${action-}"

	repo_name="$1"
	src_url="$2"
	dest="$3"
	action="$4"

	local src_name="${src_url##*/}"
	src_name="${src_name%\?*}"

	# local src_current="${src_name%%-"$repo_ver"*}"
	# src_current="${src_current%%"$repo_ver"*}"
	# src_current="${src_current%%[@\#]*}"
	# [ -n "$src_current" ] || {
	#     src_current="$repo_name"
	# }
	# local _des_name=$src_current
	# case $src_url in
	#     git+*)
	#         ;;

	#     *.tar|*.tar.??|*.tar.???|*.tar.????|*.t?z)
	#         // log '$dest' "$dest"
	#         # // mkcd "$MAKE_ROOT/$repo_name/${_local_dir##*/}"
	#         local head=${src_name%.t??*}
	#         local tail=${src_name##$head}
	#         src_current=$src_current-$repo_ver$tail
	#         ;;

	#     *?*)
	#         ;;
	# esac
	# // log '$src_current' "$src_current"

	local src_dir="$SRC_ROOT/$repo_name"
	local make_dir="$MAKE_ROOT/$repo_name"

	local archive_local="$ARCHIVE_ROOT/$repo_name/${dest:+"$dest/"}$src_name"

	# Remote source files which have been cached to local archives.
	# AKA local archive files
	# They don't must is an archive, they just normally has $dest and
	# it means that they don't want to polute the main repo if possible
	# Find reference in llvm/sources (config.guess)
	if [ -f "$archive_local" ] && is_archive "$archive_local"; then
		_res_type="archive"
		_res="$archive_local"
		_target_name="."
		_local_dir="$src_dir${dest:+"/$dest"}"

	# Git repository. Branch/tag name might in _res
	elif null "${src_url##git+*}"; then
		_res_type="git"
		_res="${src_url##"$_res_type+"}"
		_target_name="."
		# _local_dir=$SRC_ROOT/$repo_name/${dest:-"$src_name"}
		# _local_dir=${_local_dir%[@#]*}/.
		_local_dir="$src_dir${dest:+"/$dest"}"

	# How to judge the content under src's subfolder is valid or not ?
	# # Remote source dir (cached).
	# elif [ -d "$SRC_ROOT/$repo_name/${dest:+"$dest/"}$src_current" ]; then
	#     _res=$SRC_ROOT/$repo_name/${dest:+"$dest/"}$src_current
	#     _target_name="."
	#     _local_dir=$SRC_ROOT/$repo_name/${dest:+"$dest/"}$src_current

	# Remote source archive/files.
	elif null "${src_url##*://*}"; then
		_res_type="url"
		# _res="url+$src_url"
		_res="$src_url"
		_target_name="$src_name"
		_local_dir="$ARCHIVE_ROOT/$repo_name${dest:+"/$dest"}"

		[ -f "$archive_local" ] &&
		! is_archive "$archive_local" &&
		[ ! -z "${KISS_FORCE+x}" ] && {
			_res_type="absolute_file"
			_res="$archive_local"
			_target_name="$src_name"
			# Don't polute the $src_dir
			# _local_dir="$src_dir${dest:+"/$dest"}"
			_local_dir="${_res%/*}"
		}

	# Local relative dir.
	# "$repo_urn/patches folder dest_dir"
	# "$repo_urn/files   folder dest_dir"
	elif [ -d "$repo_urn/$src_url" ]; then
		_res_type="relative_dir"
		_res="$repo_urn/$src_url"
		_target_name="."
		_local_dir="$_res"

	# Local absolute dir.
	elif [ -d "/${src_url##/}" ]; then
		_res_type="absolute_dir"
		_res="/${src_url##/}"
		_target_name="."
		_local_dir="$_res"

	# Local relative file (/repo_urn/files/filename).
	# "$repo_urn/patches/00.patch file dest_dir"
	# "$repo_urn/files/01.txt     file dest_dir"
	elif [ -f "$repo_urn/$src_url" ]; then
		_res_type="relative_file"
		_res="$repo_urn/$src_url"
		# _target_name="${_res##*/}"
		_target_name="$src_name"
		_local_dir="${_res%/*}"

	# Local absolute file (/files/filename).
	elif [ -f "/${src_url##/}" ]; then
		_res_type="absolute_file"
		_res="/${src_url##/}"
		# _target_name="${_res##*/}"
		_target_name="$src_name"
		_local_dir="${_res%/*}"

	else
		// die "$repo_name" "No local file '$src_url'"
	fi

	// log '$action' "$action"
	// log '$_res_type' "$_res_type"

	ok "$action" || // log '$_res' "$_res"

	// log '$_target_name' "$_target_name"
	// log '$_local_dir' "$_local_dir"
	// log '$action' "$action"

	printf "$RS%s$FS%s$FS%s$FS%s" \
		"$_local_dir" "$_res_type" "$_res" "$_target_name"
}

# Download any remote package sources. The existence of local files is
# also checked.
# $1 repo_urn  : package repo url/uri
# $2 action    : action name
pkg_download() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	local repo_name_plain="$(name_plain "$repo_name")"
	is_repos "$repo_urn" ||
	repo_urn="$(// delegate -- repo_trace "$repo_name")"
	local action="${2-}"

	// log '$repo_name' "$repo_name"
	// log '$action' "$action"

	// debug '$repo_urn' "$repo_urn"

	# Support packages without sources. Simply do nothing.
	[ -f "$repo_urn/sources" ] ||
	{ // war 'sources' "'$repo_urn/sources' does not exist"; return 0; }

	// log "$repo_name" "reading sources"

	local src_dir="$SRC_ROOT/$repo_name"
	// mkcd "$src_dir" ||
		// die 'mkcd' "failed"

	while read -r src_url dest || ok "${src_url%%\#*}"; do
		ok "${src_url%%\#*}" || continue
		// log '$src_url' "$src_url"
		// log '$dest' "$dest"

		local _local_dir _res_type _res _target_name

		! // || / `local_route "$repo_urn" "$src_url" "$dest" "$action" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "_local_dir=\""$1"\"; _res_type=\""$2"\"; _res=\""$3"\"; \
		_target_name=\""$4"\"" }' ||
		printf '%s\n' "return 1"`

		// log '$_res_type' "$_res_type"
		// log '$_res' "$_res"
		// log '$_local_dir' "$_local_dir"

		# arg1: pre-source
		# arg2: package name
		# arg3: verbatim source
		# arg4: resolved source
		// run_hook pre-source "$repo_name" "$src_url" "$_res"

		# '$2' is set when this function is called from 'kiss c' and it is used
		# here to skip calling the Git code.
		# local _res_type="${_res%%+*}"
		# // log '$_res_type' "$_res_type"

		local repo_ver= repo_rel=

		# If the Internet won't work temporarily, use the local sources
		[ -n "${KISS_FORCE+x}" ] &&
		! empty "$_local_dir" &&
		{
			[ "git" = "$_res_type" ] ||
			{
				[ "url" = "$_res_type" ] &&
				{
					equ "$_target_name" "." ||
					[ -s "$_local_dir/$_target_name" ]
				}
			}
		} ||
		# Did the same check in download_git(). Because the
		# git rev-parse --is-inside-work-tree
		# will be cheated by upper directory git repos
		case ${action}$_res_type in
			"${action}archive")

				# // log '$_res_type' "$_res_type"
				# // log '$_res' "$_res"
				# // log '$_local_dir' "$_local_dir"

				# case $_res in
				#   *.tar|*.tar.??|*.tar.???|*.tar.????|*.t?z|*.zip)
				#       [ -f "$_res" ] || // die "$_res" "is not locally ready"
				#       # Moved to pkg_load()
				#       // extract_tar "$repo_name" "$_local_dir" "$_res"
				# esac

				/ "export synchronized_${repo_name_plain}=0"

				;;
			"${action}url")
				# git source version might have changed by current design
				# case $_res in "url+"*|"git+"*)
				// log "download_url" "beginning"
				# For download_url and download_git
				local tar_file="$(// delegate -- download_url "$repo_name" "$_local_dir" "$_res")"

				# // log '$_res_type' "$_res_type"
				# // log '$_res' "$_res"
				# // log '$_local_dir' "$_local_dir"

				# case $_res in
				#   *.tar|*.tar.??|*.tar.???|*.tar.????|*.t?z|*.zip)
				#       # Moved to pkg_load()
				#       // extract_tar "$repo_name" "$_local_dir" "$tar_file"
				# esac

				/ "export synchronized_${repo_name_plain}=0"

				;;
			"git")

				! // || / `download_git "$repo_urn" "$_local_dir" "$_res" |
					awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
				END { print "repo_ver=\""$1"\"; repo_rel=\""$2"\"" }' ||
				printf '%s\n' "return 1"`

				/ "export synchronized_${repo_name_plain}=0"

				;;
			"${action}git")

				! // || / `sync_remote "$repo_urn" "1" "$_local_dir" "$_res" |
					awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
				END { print "repo_ver=\""$1"\"; repo_rel=\""$2"\"" }' ||
				printf '%s\n' "return 1"`

				# IFS="$(printf '%b' "$FS")" read -r repo_ver repo_rel \
				#     < <(// delegate -- sync_remote "$repo_urn" "1" "$_local_dir" \
				#         "$_res") 2>/dev/null || // die 'sync_remote' "failed"

				// log '$repo_ver' "$repo_ver"
				// log '$repo_rel' "$repo_rel"

				/ "export synchronized_${repo_name_plain}=0"
		esac

		[ -z "${KISS_FORCE+x}" ] ||
		[ -n "$(/ echo \${synchronized_${repo_name_plain}-})" ] ||
		case "${action}$_res_type" in
			"${action}git")
				# IFS=$(printf '%b' "$FS") read -r repo_ver repo_rel \
				#     < <(// delegate -- sync_remote "$repo_urn" "" "$_local_dir" \
				#         "$_res") 2>/dev/null || // die 'sync_remote' "failed"

				! // || / `sync_remote "$repo_urn" "" "$_local_dir" "$_res" |
					awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
					END { print "repo_ver=\""$1"\"; repo_rel=\""$2"\"" }' ||
						printf '%s\n' "return 1"`

				# // log '$test_res_type' "$test_res_type"
				# // log '$test_res' "$test_res"
				# // log '$test_target_name' "$test_target_name"
				# // log '$test_local_dir' "$test_local_dir"
				// log '$repo_ver' "$repo_ver"
				// log '$repo_rel' "$repo_rel"
		esac

		[ -n "${src_url##*"$repo_name"*}" ] ||
		[ "$_res_type" != "git" ] || {

			local repo_dir= ver= rel= repo_alias= repo_url= reference_type=

			! // || / `pkg_version "$repo_urn" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			END { print "repo_dir=\""$1"\"; ver=\""$2"\"; rel=\""$3"\"; \
			repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
			printf '%s\n' "return 1"`

			// log '$ver' "pkg_version $ver"
			// log '$rel' "pkg_version $rel"

			[ "$ver" = "$repo_ver" ] &&
			[ "$rel" = "$repo_rel" ] ||
			{
				[ -z "${repo_ver:+x}" ] && [ -z "${repo_rel:+x}" ]
			} ||
			# [ "$rel" = "$repo_rel" ] &&
			# [ "$dir" = "$repo_dir" ] ||
			// ver_dump "$repo_urn" "$repo_ver" "$repo_rel"
		}

		# arg1: post-source
		# arg2: package name
		# arg3: verbatim source
		# arg4: resolved source
		// run_hook post-source "$repo_name" "$src_url" "$_local_dir/$_target_name"
	done < "$repo_urn/sources"
}

download_url() {
	_level_1
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	shift 1
	local _local_dir="$1"
	local _res="$2"
	local src_name="${_res##*/}"
	src_name="${src_name%\?*}"

	// log '$_local_dir' "$_local_dir"
	// log '$_res' "$_res"
	# Let's say: libdrm-2.4.116.tar.xz
	// log '$src_name' "$src_name"

	// mkcd "$_local_dir" ||
		// die 'mkcd' "failed"

	local _local_dir_user="$(// delegate -- owner "$_local_dir")"

	// log '$repo_name' "$repo_name"
	local download_impl="${cmd_get##*/}"
	// log '$download_impl' "$download_impl"
	# Set the arguments based on found download utility.
	case $download_impl in
		aria2c|axel) set -- -o   "$_local_dir/$src_name" "$_res" ;;
			   curl) set -- -fLo "$_local_dir/$src_name" "$_res" ;;
		 wget|wget2) set -- -O   "$_local_dir/$src_name" "$_res" ;;
	esac

	# Opening output file $_local_dir/$src_name
	# Error opening local file
	# /usr/bin/kiss: line 1198: -o: not found
	local download_pid
	// log '$LOGNAME' "$LOGNAME"
	# axel on www.netfilter.org
	# ERROR 403: Forbidden.
	// as_usr "download_pid" "$_local_dir_user" "$cmd_get" "$@" || {
		rm -f "$_local_dir/$src_name"
		! equ "$download_impl" "axel" || {
			// war "$download_impl" "Failed to download $_res"
			cmd_get="$( \
				command -v /usr/bin/wget   ||
				command -v /usr/bin/wget2  ||
				command -v /usr/bin/curl   ||
				command -v /usr/bin/aria2c
			)" || // die 'download utility' "not found (curl, wget, wget2)"
			# // download_url "$repo_name" "$_local_dir" "$_res"
			download_impl="${cmd_get##*/}"
			case $download_impl in
				aria2c)     set -- -o   "$_local_dir/$src_name" "$_res" ;;
				curl)       set -- -fLo "$_local_dir/$src_name" "$_res" ;;
				wget|wget2) set -- -O   "$_local_dir/$src_name" "$_res" ;;
			esac
			// as_usr "download_pid" "$_local_dir_user" "$cmd_get" "$@" || {
				\rm -f "$_local_dir/$src_name"
				// die "$download_impl" "Failed to download $_res"
			}
		}
	}

	// progress "$download_pid" "$download_impl"

	[ -f "$_local_dir/$src_name" ] ||
		// die '$_local_dir/$src_name' "'$_local_dir/$src_name' download failed"
	printf "$RS%s" "$_local_dir/$src_name"
}

sync_remote() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
		repo_urn="$(// delegate -- repo_trace "$repo_name")"
	// log '$repo_name' "$repo_name"
	// log '$repo_urn' "$repo_urn"
	shift 1
	local force_fetch
	if [ "$#" -ge "1" ]; then
		force_fetch="$1"
		shift 1
	else
		force_fetch=
	fi
	local _local_dir
	local _res
	if [ "$#" -ge "2" ]; then
		local _local_dir="$1"
		local _res="$2"
	else
		local src_url dest
		while read -r src_url dest || ok "${src_url%%\#*}"; do
			ok "${src_url%%\#*}" || continue

			local key="${repo_name%%-*}"
			null "${src_url##*"$key"*}" || continue

			// log '$src_url' "$src_url"
			// log '$dest' "$dest"

			local _local_dir _res_type _res _target_name

			! // || / `local_route "$repo_urn" "$src_url" "$dest" "$action" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			END { print "_local_dir=\""$1"\"; _res_type=\""$2"\"; _res=\""$3"\"; \
			_target_name=\""$4"\"" }' ||
			printf '%s\n' "return 1"`

			// log '$_res' "$_res"
			// log '$_local_dir' "$_local_dir"

			break
		done < "$repo_urn/sources"
	fi

	ok "$_local_dir" ||
	// die '$_local_dir' "can not figure out \$_local_dir of \"$repo_name\""

	// log '$SRC_ROOT' "$SRC_ROOT"
	// log '$SRC_USER' "$SRC_USER"

	set --
	equ "$LOGNAME" "$SRC_USER" ||
	set -- $(// delegate -- as_user "$SRC_USER")

	# Remove "/."
	// log '$_local_dir' "$_local_dir"

	// mkcd "$_local_dir" ||
		// die 'mkcd' "failed"

	local url="${_res%[\#@]*}"
	# url="${url%.git}.git"

	// log '$url' "${url}"
	// log '$PWD' "$PWD"

	# Might be empty
	local upstream_name=
	[ -n "${_res##*[@\#]*}" ] || upstream_name="${_res##*[@\#]}"

	# "$target" is the tag or branch name
	local reference_type= target= repo_ver= repo_rel=

	// cue '$upstream_name' "$upstream_name"

	# [ "$("$@" git -C "$_local_dir" rev-parse --is-inside-work-tree 2>/dev/null)" = "true" ] &&
	# ! empty "$_local_dir" || {
	#     "$@" find "$_local_dir" -mindepth 1 -delete
	#     "$@" git clone --recursive --depth 1 "${url}" "$_local_dir" ||
	#     "$@" git clone --branch "$target" "${url}" "$_local_dir" 2>/dev/null ||
	#     // die "git clone --recursive --depth 1 \"${url}\" \"$_local_dir\"" "failed"
	# }
	# null "$force_fetch" || "$@" git fetch --tags --prune

	# target="$("$@" git describe --tags $("$@" git rev-list --tags --max-count=1))"

	! // || / `type_track \
		"$repo_urn" "$upstream_name" "$_local_dir" "$url" "$force_fetch" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "reference_type=\""$1"\"; target=\""$2"\"; repo_ver=\""$3"\"; \
	repo_rel=\""$4"\"" }' ||
	printf '%s\n' "return 1"`

	// cue '$reference_type' "$reference_type"
	// log '$target' "$target"
	// log '$repo_ver' "type_track $repo_ver"
	// log '$repo_rel' "type_track $repo_rel"

	local repo_ver_local repo_rel_local

	! // || / `sync_local "$reference_type" \
		"$target" "$repo_ver" "$repo_rel" "$_local_dir" "$url" "$force_fetch" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_ver_local=\""$1"\"; repo_rel_local=\""$2"\"" }' ||
	printf '%s\n' "return 1"`

	! is_version "$repo_ver_local" || ! is_version "$repo_rel_local" || {
		is_version "$repo_ver" && is_version "$repo_rel" && {
			local _left_is_less="$(// left_is_less \
			"$repo_name" "$repo_ver_local-$repo_rel_local" "$repo_ver-$repo_rel")"
			[ -z "$_left_is_less" ] ||
			equ "$_left_is_less" "0" ||
			repo_ver="$repo_ver_local" repo_rel="$repo_rel_local"
		} || {
			repo_ver="$repo_ver_local" repo_rel="$repo_rel_local"
		}
	}

	// log '$repo_ver' "local $repo_ver"
	// log '$repo_rel' "local $repo_rel"

	# Might be illigal values
	# is_version "$repo_ver" || // die '$repo_ver' "${repo_ver:+"${repo_ver} "}got wrong value"
	# is_version "$repo_rel" || // die '$repo_rel' "${repo_rel:+"${repo_rel} "}got wrong value"

	printf "$RS%s$FS%s" "$repo_ver" "$repo_rel"
}

# Initializing git repo
init_git() {
	_level_2
	local target="$1"
	local _local_dir="$2"
	local url="$3"

	// log '$SRC_USER' "$SRC_USER"

	set --
	equ "$LOGNAME" "$SRC_USER" ||
	# set +f -- $(// delegate -- as_user "$SRC_USER")
	set -- $(// delegate -- as_user "$SRC_USER")
	# [ "$#" -eq "0" ] ||
	// debug_filter -- // log 'set privilege' "$(esceval "$@")"

	[ "$PWD" = "$_local_dir" ] || {
		[ -d "$_local_dir" ] || "$@" \mkdir -p "$_local_dir"
		// cd "$_local_dir" || // die 'failed to cd to' "$_local_dir"
	}

	local content="$( \
		// delegate -- prompt "Delete all contents inside the folder?${newline}\
		'$_local_dir'${newline} [*|n|ctrl+c]")"

	expr "$content" : '[n|N]\+' > /dev/null && interrupt ||
		# Clear target directory
		"$@" find "$_local_dir" -mindepth 1 -delete

	# Bytes per second
	export GIT_HTTP_LOW_SPEED_LIMIT=500
	# seconds
	export GIT_HTTP_LOW_SPEED_TIME=1200

	// log '$url' "'$url' is just being cloned ..."
	local clone_pid=

	# https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/
	[ ! -z "${target:+x}" ] && {
		as_usr "clone_pid" "$SRC_USER" \
			git clone --depth 1 --single-branch --branch "$target" "$url" "$_local_dir" 2>&1 ||
		# as_usr "clone_pid" "$SRC_USER" \
		#     git clone --recursive --no-tags --depth 1 "${url}" "$_local_dir" 2>&1 ||
		as_usr "clone_pid" "$SRC_USER" \
			git clone --branch "$target" "${url}" "$_local_dir" 2>&1
	} ||
	as_usr "clone_pid" "$SRC_USER" \
		git clone --depth 1 "${url}" "$_local_dir" 2>&1 ||
	# as_usr "clone_pid" "$SRC_USER" \
	#     git clone --recursive --depth 1 --single-branch --branch "$target" "${url}" "$_local_dir" 2>/dev/null ||
	# as_usr "clone_pid" "$SRC_USER" \
	#     git clone --recursive --filter=tree:0 --branch "$target" "${url}" "$_local_dir" 2>/dev/null ||
	# as_usr "clone_pid" "$SRC_USER" \
	#     git clone --recursive --filter=blob:none --branch "$target" "${url}" "$_local_dir" 2>/dev/null ||
	as_usr "clone_pid" "$SRC_USER" \
		git clone "${url}" "$_local_dir" 2>&1 ||
		// die "git clone --branch \"$target\" \"${url}\" \"$_local_dir\"" "failed"
		# // die "git clone --recursive --depth 1 --branch \
		# \"$target\" \"${url}\" \"$_local_dir\"" "failed"

	# pid_alive "$clone_pid" || // die '$clone_pid' "'$clone_pid' died?"

	# // log '$clone_pid' "$clone_pid [before progress]"
	printf '%s %s\n' '$clone_pid' "$clone_pid [before progress]" > "$say_pipe"

	// progress "$clone_pid" "git cloning"

	# // log '$clone_pid' "$clone_pid [after  progress]"
	printf '%s %s\n' '$clone_pid' "$clone_pid [after  progress]" > "$say_pipe"

	# // war 'git clone' "may take a while, please be patient while it is running..."
	# printf "["
	# # While process is running...
	# while pid_alive "$clone_pid" 2> /dev/null; do
	#   printf "#"
	#   sleep 1
	# done
	# printf "] done!"

}

# Demonstration
# ~/.vim/pack/packager/opt/vim-clap/install.sh
# No dedicated definitions for current repo
tag_remote() {
	_level_2
	# local target_name="$1" repo_ver_name="$2" repo_rel_name="$3"
	# shift 3
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	local upstream_name="${2}"
	local url="$3"

	local tag_prefer=1
	local target=
	local repo_ver= repo_rel=

	# Traditional packages dependency deducing depends on versions,
	# but it is hard to tell version from branch type repo
	# Package manager should not make the decision but users could
	# [ -n "${UNUSE_LATEST_TAG:+x}" ] ||
	# [ -z "${repo_urn##*"$sys_db"*}" ] ||
	#   upstream_name=

	set --
	equ "$LOGNAME" "$SRC_USER" ||
	set -- $(// delegate -- as_user "$SRC_USER")
	# git -c 'versionsort.suffix=-' ls-remote --exit-code --refs --sort='version:refname' --tags "$url" 'v0.*'
	# git -c 'versionsort.suffix=-' ls-remote --exit-code --refs --sort='version:refname' --tags "$url" refs/tags/*"${upstream_name}"* | awk -F "/" '{print $NF}'
	# git -c 'versionsort.suffix=-' ls-remote --exit-code --refs --sort='version:refname' --tags "$url" | grep "${upstream_name}" | awk -F "/" '{print $NF}'

	# Fro linux kernel
	# e42df5dc5f39a088f3611d9f09619f53dd6d3a5d        refs/tags/v6.5-rc6
	local tag_list=
	local query_pid=
	# refs/tags/vx.x.x-x
	tag_list="$( \
		# as_usr "query_pid" "$SRC_USER" git -c 'versionsort.suffix=-' ls-remote --exit-code --refs \
		as_usr "$SRC_USER" git -c 'versionsort.suffix=-' ls-remote --exit-code --refs \
		--sort='version:refname' --tags "$url" 2> /dev/null |
		awk '{print $2}' || {
			# awk 'BEGIN{ FS = "/" } {print $NF}' 2> /dev/null || {
			"$@" git config --local --unset remote.origin.tagopt > /dev/null 2>&1
			"$@" git config --local --unset remote.origin.fetch > /dev/null 2>&1
			"$@" git config --local remote.origin.fetch \
				"+refs/heads/*:refs/remotes/origin/*" > /dev/null 2>&1
			# local result="$( \
			# as_usr "query_pid" "$SRC_USER" git -c 'versionsort.suffix=-' ls-remote --exit-code --refs \
			as_usr "$SRC_USER" git -c 'versionsort.suffix=-' ls-remote --exit-code --refs \
				--sort='version:refname' --tags "$url" 2> /dev/null |
				awk '{print $2}'
				# awk 'BEGIN{ FS = "/" } {print $NF}' 2> /dev/null
			# )"
			# printf '%s' "$result"
		}
	)"

	# // progress "$query_pid" "git query"

	[ -z "${upstream_name:+x}" ] ||
		tag_list="$(printf '%s\n' "$tag_list" |
				grep "$upstream_name")"


	[ -n "${tag_list:+x}" ] || {
		# No match tag or repo does not support tags
		// log '$tag_prefer' "$tag_prefer"
		printf "$RS%s$FS%s$FS%s" "$target" "$repo_ver" "$repo_rel"
		return $tag_prefer
	}

	tag_prefer=0
	set -- $tag_list

	[ "$#" -eq "1" ] && {
		target="$(printf '%s' "$tag_list" |
			awk 'BEGIN{ FS = "/" } {print $NF}' 2> /dev/null)"
		// debug '$target' "$target"

		! // || / `ver_parse "$target" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "repo_ver=\""$1"\"; repo_rel=\""$2"\"" }' ||
		printf '%s\n' ":"`

	} || {

		local ver_rel=
		# $target_ref == refs/tags/v2.0.0-beta1
		local target_ref
		local ver_rel_list=
		local target_index=0
		for target_ref do
			local target_item
			target_item="$(printf '%s' "$target_ref" |
				awk 'BEGIN{ FS = "/" } {print $NF}' 2> /dev/null)"

			// debug '$target_item' "$target_item" &

			! // || / `ver_parse "$target_item" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			END { print "repo_ver=\""$1"\"; repo_rel=\""$2"\"" }' ||
			printf '%s\n' "continue"`

			is_version "$repo_ver" || // die '$repo_ver' "'$repo_ver' does not support numerical version"
			is_version "$repo_rel" || repo_rel=0

			local ver_rel_key="$(name_plain "$repo_ver-$repo_rel")"
			// debug '$ver_rel_key' "$ver_rel_key" &
			/ "v$ver_rel_key=\"$target_item\""
			/ "// debug \"v$ver_rel_key\" \"\${v$ver_rel_key}\""
			ver_rel_list="${ver_rel_list:+"${ver_rel_list} "}$repo_ver-$repo_rel"
			: $((target_index += 1))
		done

		set -- $ver_rel_list

		// debug '$#' "'$#' elements" &
		// log 'ver-rel' "sorting ..."
		# local sort_id
		# {
			# sort_ver_rel out_list "$repo_name" "$@"
			# delegate: Version 1 / Version 2 / Version 3
			# set -- $(// delegate '\n' version_priority "left_is_less" "$repo_name" "$@")
			# delegate: Version 4
			# set -- $(// delegate '\n' version_priority "left_is_less" "$repo_name" "$@") || :
			set -- $(// delegate '\n' sort_ver_rel "left_is_less" "$repo_name" "$@") || :
		# } & sort_id=$!

		# // progress "$sort_id" "sorting"

		// debug '$#' "'$#' elements" &

		[ "$#" -le "0" ] || {
			# The first one
			# local ver_rel="${out_list%% *}"
			# The last one
			# / "local ver_rel=\"\${$#}\""
			# The first one
			# / "local ver_rel=\"\${$1}\""
			ver_rel="$1"
			local latest_ver_rel_key="v$(name_plain "$ver_rel")"
			/ "local target=\"\${$latest_ver_rel_key}\""
		}
		# ver_rel="$( \
		#   printf '%s' "$out_list" | tail -n 1
		#   # tail -n 1 |
		#   # awk -F "/" '{print $NF}'
		# )"

		repo_ver="${ver_rel%%-*}" repo_rel="${ver_rel##*-}"
	}

	# / "$target_name=\"$target\""
	# / "$repo_ver_name=\"$repo_ver\""
	# / "$repo_rel_name=\"$repo_rel\""
	// log '$tag_prefer' "$tag_prefer"

	printf "$RS%s$FS%s$FS%s" "$target" "$repo_ver" "$repo_rel"
	# Neovim tag "nightly" does not give version from tag itself
	# But, you can not say it is not a tag -- return 1 is not reasonable
	# is_version "$repo_ver" && is_version "$repo_rel" && [ -n "$target" ] && return 0 || return 1
	return $tag_prefer
}

# Repo maintainer defined the function "version"
definitions() {
	_level_2
	# local target_name="$1"
	# local repo_ver_name="$2"
	# local repo_rel_name="$3"
	# shift 3
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"

	local upstream_name="$2"
	local _local_dir="$3"
	local url="$4"

	local target= repo_ver= repo_rel=
	local query_env=
	[ -z "${KISS_FORCE+x}" ] ||
		query_env="KISS_FORCE="

	// log '$repo_urn/definitions' "'$repo_urn/definitions' performing"
	! // || / `as_own "$_local_dir" \
		env FS="$FS" RS="$RS" PATH="$PATH" "$query_env" sh -c "$repo_urn/definitions \
		\"target\" \
		\"$upstream_name\" \"$_local_dir\" \"$url\"" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "target=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"" }' ||
	printf '%s\n' "return 1"`

	[ -n "$target" ] || {
		// war '$target' "$target"
		// log '$repo_ver' "$repo_ver"
		// log '$repo_rel' "$repo_rel"

		printf "$RS%s$FS%s$FS%s" "$target" "$repo_ver" "$repo_rel"
		# If you accidentally localizes a variable, you covered it from returning it
		# Name "target" "repo_ver" "repo_rel" was localized above, so no value will return
		# / "$target_name=\"\$target\""
		# / "$repo_ver_name=\"\$repo_ver\""
		# / "$repo_rel_name=\"\$repo_rel\""
		return 0
	}

	is_version "$repo_ver" && is_version "$repo_rel" ||
		! // || / `ver_parse "$target" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_ver=\""$1"\"; repo_rel=\""$2"\"" }' ||
	printf '%s\n' "return 1"`

	is_version "$repo_ver" && is_version "$repo_rel" ||
	// die '$repo_ver-$repo_rel' "$repo_ver-$repo_rel"

	local repo_dir= ver_target= rel_target= repo_alias= repo_url= reference_type=

	! // || / `pkg_version "$repo_name" "" "" "$KISS_ROOT/$db" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_dir=\""$1"\"; ver_target=\""$2"\"; rel_target=\""$3"\"; \
	repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`

	[ "$ver_target" = "$repo_ver" ] && [ "$rel_target" = "$repo_rel" ] ||
	ver_dump "$repo_urn" "$repo_ver" "$repo_rel"

	// log '$target' "$target"
	// log '$repo_ver' "$repo_ver"
	// log '$repo_rel' "$repo_rel"

	printf "$RS%s$FS%s$FS%s" "$target" "$repo_ver" "$repo_rel"
	# Name "target" "repo_ver" "repo_rel" was localized above, so no value will return
	# / "$target_name=\"\$target\""
	# / "$repo_ver_name=\"\$repo_ver\""
	# / "$repo_rel_name=\"\$repo_rel\""
}

# Determine <latest tag name>/<branch name> at this function
# Never has tried to modify local resource
# upstream_name  : "$1"
# _local_dir     : "$2"
# url            : "$3"
# force_fetch    : "$4"
type_track() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	local upstream_name="$2"
	local _local_dir="$3"
	local url="$4"
	[ -n "${url:+x}" ] || // die '$url' "\"$url\" is invalid"
	shift 4
	local force_fetch
	if [ "$#" -ge "1" ]; then
		force_fetch="$1"
		shift 1
	else
		force_fetch=
	fi

	local reference_type=
	local target=
	local repo_ver= repo_rel=

	// log '$SRC_USER' "$SRC_USER"

	set --
	equ "$LOGNAME" "$SRC_USER" ||
	# set +f -- $(// delegate -- as_user "$SRC_USER")
	set -- $(// delegate -- as_user "$SRC_USER")
	# [ "$#" -eq "0" ] ||
	// debug_filter -- // log 'set privilege' "type_track :${newline}$(esceval "$@")"

	[ -z "${KISS_DEBUG:+x}" ] ||
	(IFS=$', |' && ! list_contains "$FUNCNAME" $KISS_DEBUG) ||
	for item in "$@"; do printf '%s %s\n' '$@::$item' "$item" > "$say_pipe"; done

	[ "$PWD" = "$_local_dir" ] || {
		[ -d "$_local_dir" ] || "$@" \mkdir -p "$_local_dir"
		// cd "$_local_dir" || // die 'failed to cd to' "$_local_dir"
	}

	inner_query_tag() {
		// log '$url' "$url"
		# This is just a recommendation
		// log '$force_fetch' "$force_fetch"
		// log '$SRC_USER' "$SRC_USER"

		local result=0

		# set +f --
		# set --
		# equ "$LOGNAME" "$SRC_USER" ||
		# # set +f -- $(// delegate -- as_user "$SRC_USER")
		# set -- $(// delegate -- as_user "$SRC_USER")
		# [ "$#" -eq "0" ] ||
		// debug_filter -- // log 'set privilege' "inner_query_tag :${newline}$(esceval "$@")"

		[ -n "${PREFER_TAG+x}" ] || { result=1; return $result; }

		reference_type="tag"

		tag_solve() {
			_level_2

			// debug_filter -- // log 'set privilege' "tag_solve :${newline}$(esceval "$@")" &
			{
				ok "$force_fetch" ||
				# [ ! -z "${KISS_FORCE+x}" ] ||
				[ ! -f "$repo_urn/definitions" ]
			} && {
				// log '$repo_urn' "'$repo_urn' remote checking"
				! // || / `tag_remote "$repo_urn" "$upstream_name" "$url" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs }
						END { print "target=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"" }' ||
							printf '%s\n' "return 1"`
				:
			} ||
				! // || / `definitions "$repo_urn" "$upstream_name" "$_local_dir" "$url" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs }
						END { print "target=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"" }' ||
							printf '%s\n' "return 1"`

			// log '$target'   "$target"
			// log '$repo_ver' "$repo_ver"
			// log '$repo_rel' "$repo_rel"
		}

		# Whatever, local codebase must exist
		[ "$("$@" git -C "$_local_dir" rev-parse \
		--is-inside-work-tree 2>/dev/null)" = "true" ] &&
		# .git only folder contains no normal files
		# ! empty "$_local_dir" &&
		[ "$("$@" \ls -1 "$_local_dir" 2> /dev/null)" != "" ] || {
			# printf '%s\n' "$(see "${lineno_scope-"0"}" "$lineno" \
			# '$_local_dir' "$_local_dir")" > "$say_pipe"
			// log '$_local_dir' "$_local_dir"

			[ "$("$@" git -C "$_local_dir" rev-parse \
			--is-inside-work-tree 2>/dev/null)" = "true" ] &&
			# printf '%s\n' "$(see "${lineno_scope-"0"}" "$lineno" '--is-inside-work-tree' 'true')" > "$say_pipe" ||
				// log '--is-inside-work-tree' 'true' ||
			# printf '%s\n' "$(see "${lineno_scope-"0"}" "$lineno" '--is-inside-work-tree' 'false')" > "$say_pipe"
				// log '--is-inside-work-tree' 'false'

			// war '$("$@" \ls -1 "$_local_dir")' "$(esceval $("$@" \ls -1 "$_local_dir" 2> /dev/null))"
			# printf '%s\n' "$(see "${lineno_scope-"0"}" "$lineno" \
			#   '$(\ls -1 "$_local_dir")' "$LINENO")" > "$say_pipe"
			// log '$(\ls -1 "$_local_dir")' "$LINENO"
			for item in $("$@" \ls -1 "$_local_dir" 2> /dev/null); do
				# printf '%s\n' "$(see "${lineno_scope-"0"}" "$lineno" \
				#   '$("$@" \ls -1 "$_local_dir" 2> /dev/null)' "$item")" > "$say_pipe"
				// log '$("$@" \ls -1 "$_local_dir" 2> /dev/null)' "$item"
			done

			// init_git "$target" "$_local_dir" "$url"

			// tag_solve "$@" || // die 'neither of the tag query' "succeeded"

			[ ! -z "${target:+x}" ] || {
				// tag_fetch "$target" "$url"
				// tag_solve "$@" ||
				// die 'neither of the tag query' "succeeded"
			}

			[ -n "${target:+x}" ] || {
				reference_type="branch"
				result=1
				return $result
			}
		}

		# Query remote tags if $upstream_name given
		# Merged into tag_remote()
		# null "$force_fetch" ||
		# [ -n "${UNUSE_LATEST_TAG:+x}" ] ||
		# [ -z "${upstream_name:+x}" ] ||
		# for item in $("$@" git ls-remote "${url}" --tags \
		#             "refs/tags/*"${upstream_name}"*" | awk '{print $2}'); do
		#     // log 'check target with $upstream_name' "$upstream_name"
		#     [ -n "${item:+x}" ] || continue
		#     [ -z "${item##*"${upstream_name}"*}" ] || continue
		#     target="${item##"refs/tags/"}"
		#     // log '$target' "$target"
		#     break
		#     return 0
		# done

		# ok "$("$@" git -P tag 2>&1)" &&
		null "$force_fetch" || {
			// log '$repo_name' "'$repo_name' remote tags checking ..."

			// tag_solve "$@" ||
			// die 'neither of the tag query' "succeeded"

			[ -n "${target:+x}" ] || {
				reference_type="branch"
				result=1
				return $result
			}

			// log 'type : target' "'$(delegate -- format "$reference_type")' : '$target'"
			return $result
		}

		// log '$repo_name' "'$repo_name' local tags checking ..."

		[ ! -f "$repo_urn/definitions" ] ||
			// tag_solve "$@" ||
			// die 'neither of the tag query' "succeeded"

		[ -z "${target:+x}" ] || {
			// log 'type : target' "'$(delegate -- format "$reference_type")' : '$target'"
			return $result
		}

		# If don't fetch all tags, the foowing operation on target_local will fail

		local tag_list="$("$@" git -P tag 2>&1)"
		ok "$tag_list" ||
		# Time consuming operation
		# "$@" git fetch --all --tags --prune
		# Not always make things easier
		# null "$force_fetch" ||
		[ ! -z "${target:+x}" ] || {
			// log 'fetch' "refs/tags/$target"
			// tag_fetch "$target" "$url" && tag_list="$("$@" git -P tag 2>&1)"
		} || {
			"$@" git fetch --all --tags --prune && tag_list="$("$@" git -P tag 2>&1)"
		} || {
			reference_type="branch"
			result=1
			return $result
		}

		local target_current="$("$@" git -P branch | grep \* | awk "{print \$2}")"
		// log '$target_current' "$target_current"
		# https://stackoverflow.com/questions/21439488/find-latest-git-tag-from-the-remote-git-repository
		# Leaving ^0 at the end of tags
		# target="$("$@" git rev-list --tags --timestamp \
		# --no-walk | sort -nr | head -n1 | cut -f 2 -d ' ' | \
		# xargs "$@" git describe --contains)"
		# https://stackoverflow.com/questions/1404796/how-can-i-get-the-latest-tag-name-in-current-branch-in-git
		# local target_local="$("$@" git tag -l | sort | tail -n 1)"
		local target_local=
		list_contains "$target_current" $tag_list &&
		target_local="$target_current" ||
		# Will get Neovim nightly
		target_local="$(
			"$@" git describe --tags \
			"$("$@" git rev-list --tags --max-count=1)"
		)" || // war 'woops' "not a tag type repo"

		local repo_ver_local= repo_rel_local=
		[ -n "${target_local:+x}" ] && {
			# For luv, the result is wrong
			# for item in $( \
			#   "$@" git tag -l | sort -V -r); do target_local="$item"
			#   break; done
			# target_local="$("$@" git tag -l | sort | tail -n 1)"

			! // || / `ver_parse "$target_local" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			END { print "repo_ver_local=\""$1"\"; repo_rel_local=\""$2"\"" }' ||
			printf '%s\n' ":"`
		} || {
			# At this moment, let's say it is a branch at least
			reference_type="branch"
			result=1
			// log '$reference_type' "$reference_type"
			// log '$target' "$target"
			return $result
		}

		[ -z "${target:+x}" ] ||
		[ ! -z "${repo_ver:+x}" ] ||
		[ ! -z "${repo_rel:+x}" ] ||
		! // || / `ver_parse "$target" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs }
			END { print "repo_ver=\""$1"\"; repo_rel=\""$2"\"" }' ||
				printf '%s\n' ":"`

		// log '$target_local' "$target_local"

		# target="$target_local"
		// log '$repo_ver' "$repo_ver"
		// log '$repo_ver_local' "$repo_ver_local"
		# ! is_version "$repo_ver" ||
		! is_version "$repo_ver_local" || {
			is_version "$repo_rel_local" || repo_rel_local=0
			# sort -V is not for this scenario
			# local repo_ver_last="$( \
			#   tail -n 1 <<- EOF
			#       $(sort -V <<- EOF
			#               $repo_ver
			#               $repo_ver_local
			#           EOF
			#       )
			#   EOF
			# )"

			# // log '$repo_ver_last' "$repo_ver_last"
			# [ "$repo_ver_last" = "$repo_ver" ] ||
			! is_version "$repo_ver_local" || ! is_version "$repo_rel_local" || {
				! is_version "$repo_ver" || is_version "$repo_rel" || repo_rel=0
				is_version "$repo_ver" && is_version "$repo_rel" && {
					local _left_is_less="$(// left_is_less \
					"$repo_name" "$repo_ver_local-$repo_rel_local" "$repo_ver-$repo_rel")"
					[ -z "$_left_is_less" ] ||
					equ "$_left_is_less" "0" ||
					repo_ver="$repo_ver_local" repo_rel="$repo_rel_local" target="$target_local"
				} || {
					repo_ver="$repo_ver_local" repo_rel="$repo_rel_local" target="$target_local"
				}
			}
		}

		[ -n "${target:+x}" ] || [ -z "${target_local:+x}" ] || target="$target_local"

		[ -n "${target:+x}" ] || {
			reference_type="branch"
			result=1
			return $result
		}

		// log 'type : target' "'$(delegate -- format "$reference_type")' : '$target'"
		return $result

	}

	inner_query_branch() {
		# "$@" is empty by now
		#
		# set --
		# equ "$LOGNAME" "$SRC_USER" ||
		# # set +f -- $(// delegate -- as_user "$SRC_USER")
		# set -- $(// delegate -- as_user "$SRC_USER")
		# [ "$#" -eq "0" ] ||
		// debug_filter -- // log 'set privilege' "inner_query_branch :${newline}$(esceval "$@")"

		local branch_list=

		branch_solve() {
			_level_2
			// debug_filter -- // log 'set privilege' "branch_solve :${newline}$(esceval "$@")"

			local branch_list=
			branch_list="$( \
			"$@" git -C "$_local_dir" -c 'versionsort.suffix=-' ls-remote --exit-code --refs \
			--sort='version:refname' --heads "$url" 2> /dev/null |
			awk '{print $2}')" || # // die 'git ls-remote' "failed"

			branch_list="$("$@" git -C "$_local_dir" ls-remote "${url}" --heads \
				"refs/heads/*" 2> /dev/null | awk '{print $2}')" || // die 'git ls-remote' "failed"

			for item in $branch_list; do
				[ -n "${item:+x}" ] || continue
				{
					[ -n "${upstream_name:+x}" ] &&
					[ -z "${item##*"${upstream_name}"*}" ]
				} || continue
				target="${item##"refs/heads/"}"
				// log '$target' "$target"
				reference_type="branch"
				// log '$reference_type' "$reference_type"
				break
				# return 0
			done
			[ -n "${target:+x}" ] ||
			for item in $branch_list; do
				[ -n "${item:+x}" ] || continue
				[ -z "${item##*"master"*}" ] || [ -z "${item##*"main"*}" ] ||
				[ -z "${item##*"stable"*}" ] || continue
				target="${item##"refs/heads/"}"
				// log '$target' "$target"
				reference_type="branch"
				// log '$reference_type' "$reference_type"
				break
				# return 0
			done

		}

		[ "$("$@" git -C "$_local_dir" rev-parse \
		--is-inside-work-tree 2>/dev/null)" = "true" ] &&
		# .git only folder contains no normal files
		# ! empty "$_local_dir" &&
		[ "$("$@" \ls -1 "$_local_dir" 2> /dev/null)" != "" ] || {
			# printf '%s\n' "$(see "${lineno_scope-"0"}" "$lineno" '$_local_dir' "$_local_dir")" > "$say_pipe"
			// log '$_local_dir' "$_local_dir"
			[ "$("$@" git -C "$_local_dir" rev-parse \
			--is-inside-work-tree 2>/dev/null)" = "true" ] &&
			# printf '%s\n' "$(see "${lineno_scope-"0"}" "$lineno" '--is-inside-work-tree' 'true')" > "$say_pipe" ||
				// log '--is-inside-work-tree' 'true' ||
			# printf '%s\n' "$(see "${lineno_scope-"0"}" "$lineno" '--is-inside-work-tree' 'false')" > "$say_pipe"
				// log '--is-inside-work-tree' 'false'

			// war '$("$@" \ls -1 "$_local_dir")' "$(esceval $("$@" \ls -1 "$_local_dir" 2> /dev/null))"
			# printf '%s\n' "$(see "${lineno_scope-"0"}" "$lineno" '$(\ls -1 "$_local_dir")' "$LINENO")" > "$say_pipe"
			// log '$(\ls -1 "$_local_dir")' "$LINENO"
			for item in $("$@" \ls -1 "$_local_dir" 2> /dev/null); do
				# printf '%s\n' "$(see "${lineno_scope-"0"}" "$lineno" '$("$@" \ls -1 "$_local_dir" 2> /dev/null)' "$item")" > "$say_pipe"
				// log '$("$@" \ls -1 "$_local_dir" 2> /dev/null)' "$item"
			done

			// init_git "$target" "$_local_dir" "$url"

			// branch_solve "$@"
		}

		[ -n "${target:+x}" ] || null "$force_fetch" ||
		// branch_solve "$@"

		# Covered the target

		[ ! -f "$repo_urn/definitions" ] ||
			! // || / `definitions "$repo_urn" "$upstream_name" "$_local_dir" "$url" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "target=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"" }' ||
		printf '%s\n' "return 1"`

		[ -n "${target:+x}" ] || {
			target="$("$@" git -P branch | grep \* | awk "{print \$2}")"
			// log '$target' "$target"
			reference_type="branch"
			// log '$reference_type' "$reference_type"
			return 0
		}

		[ -n "${target:+x}" ] ||
		// die '$repo_ver-$repo_rel' "$repo_ver-$repo_rel"

		# [ -n "${target:+x}" ] ||

		"$@" git stash --all > /dev/null || :

		// log 'type : target' "'$(delegate -- format "$reference_type")' : '$target'"
	}

	inner_query_tag "$@" || inner_query_branch "$@"

	[ -n "${target:+x}" ] || {
		// war "branch/tag '$upstream_name' doesn't exist" \
			"might because \".git\" issue in url"
		if null "${url##*".git"*}"; then
			url="${url%".git"}"
		else
			url="${url}.git"
		fi

		# force_fetch=1
		local remote_url="$("$@" git -C "$_local_dir" remote -v | \
				grep fetch | grep origin | awk '{print $2}')"
		[ "$remote_url" = "$url" ] ||
		"$@" git remote set-url origin "${url}" 2>&1 ||
		"$@" git remote add origin "${url}" 2>&1 ||
		// die "git remote set-url origin \"${url}\"" "failed"

		inner_query_tag "$@" || inner_query_branch "$@"
	}

	[ -n "${target:+x}" ] ||
	// die "branch/tag '$upstream_name' doesn\'t exist" "check the url, please"

	[ ! -z "$upstream_name" ] || upstream_name="$target"

	is_version "$repo_ver" && is_version "$repo_rel" || {
		repo_ver="0.0.0" repo_rel="0"
		# [ ! -f "$repo_urn/definitions" ] &&
		# repo_ver="0.0.0" repo_rel="0" ||
		# ! // || / `definitions "$repo_urn" "$upstream_name" "$_local_dir" "$url" |
		# awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		# END { print "target=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"" }' ||
		# printf '%s\n' "return 1"`
	}

	is_version "$repo_ver" && is_version "$repo_rel" ||
	// die '$repo_ver-$repo_rel' "$repo_ver-$repo_rel"

	printf "$RS%s$FS%s$FS%s$FS%s" "$reference_type" "$target" "$repo_ver" "$repo_rel"
}

# ! // || / `sync_local "$reference_type" \
#   "$target" "$repo_ver" "$repo_rel" "$_local_dir" "$url" "1" |
#       awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
#       END { print "repo_ver_local=\""$1"\"; repo_rel_local=\""$2"\"" }' ||
#           printf '%s\n' "return 1"`
sync_local() {
	_level_2
	local reference_type="$1"
	local target="$2"
	[ -n "${target:+x}" ] || // die '$target' "\"$target\" is invalid"
	// log '$target' "$target"
	local repo_ver="$3"
	local repo_rel="$4"
	local _local_dir="$5"
	local url="$6"
	[ -n "${url:+x}" ] || // die '$url' "\"$url\" is invalid"
	# shift 6
	local force_fetch="${7-}"
	# if [ "$#" -ge "1" ]; then
	#   force_fetch="$1"
	#   shift 1
	# else
	#   force_fetch=
	# fi

	# local repo_ver_string

	// log 'ver-rel [input]' "'$repo_ver' - '$repo_rel'"
	local repo_ver_local= repo_rel_local=

	set --
	equ "$LOGNAME" "$SRC_USER" ||
		set -- $(// delegate -- as_user "$SRC_USER")

	[ "$PWD" = "$_local_dir" ] || // cd "$_local_dir"

	if [ "$reference_type" = "branch" ]; then
		null "$force_fetch" || {
			# [ -z "$target" ] ||
			"$@" git remote set-branches origin "$target" ||
			// die "git remote set-branches origin $target" "failed"

			// log 'fetch' "${url}"
			local fetch_pid=
			as_usr "fetch_pid" "$SRC_USER" \
				git fetch --depth 1 "${url}" "$target" 2>&1 ||
			# generate branch "$terget" in .git/config
			as_usr "fetch_pid" "$SRC_USER" \
				git fetch --depth 1 origin "$target" 2>&1 ||
			as_usr "fetch_pid" "$SRC_USER" \
				git fetch "${url}" "$target" 2>&1 ||
			// die "git fetch --depth 1 \"${url}\" $target" "failed"

			// progress "$fetch_pid" "git fetch"

		}
		local target_ref="$("$@" git -P branch | grep -v remotes | \
				grep \* | awk '{print $2}')"
		# fatal: a branch named 'master' already exists when "$target" = "$target_ref"
		[ "$target" = "$target_ref" ] || {
			[ "$("$@" git -P branch | grep -v remotes | grep "$target" |
				awk '{print $1}')" = "$target" ] ||
			# fatal: a branch named 'master' already exists
			# "$@" git -P branch "$target" FETCH_HEAD 2>&1 ||
			# fatal: 'origin/master' is not a commit and a branch 'master' cannot be created from it
			"$@" git checkout -b "$target" refs/remotes/origin/"$target" 2>&1 ||
			// die "git checkout -b $target origin/$target" "failed"

			"$@" git -P branch | grep -q "$target" && {
				# "$@" git switch "$target" --no-show-forced-updates 2> /dev/null ||
				"$@" git checkout "$target" 2>&1 ||
				// die "git switch $target" "failed"
			} ||
			# "$@" git switch "$target" --no-show-forced-updates 2> /dev/null ||
			"$@" git switch -c "$target" --track "refs/remotes/origin/$target" ||    # Already on 'master'
			"$@" git checkout -b "$target" "refs/remotes/origin/$target" 2>&1 ||    # Already on 'master'
			// die "git switch $target" "failed"

			target_ref="$("$@" git -P branch | grep -v remotes | \
				grep \* | awk '{print $2}')"
			[ "$target_ref" = "$target" ] ||
			// die "[ \"$target_ref\" = \"$target\" ]" "failed"
		}

		// log '$target_ref' "$target_ref"

		"$@" git -P branch "--set-upstream-to=refs/remotes/origin/$target" "$target"
		# fatal: the requested upstream branch 'origin/master' does not exist
		"$@" git reset --hard "refs/remotes/origin/$target" 2>&1 ||
		// war "git reset --hard origin/$target" "failed"

		"$@" git stash --all 2>&1 || :

		is_version "$repo_ver" && is_version "$repo_rel" || {
			# This raddom number-string could be used as a mark, but it is not a version
			# parsing it make no sense
			# repo_ver_string="$(printf "%s\n" "$( \
			#     "$@" git rev-parse --short "${upstream_name}" 2>/dev/null)")"
			# repo_ver_string="$(printf "%s\n" "$( \
			#     "$@" git rev-parse --short 'HEAD' 2>/dev/null)")"
			#
			# repo_ver_local="9999.9999.9999"
			repo_ver_local="0.0.0"
			# repo_rel_local="9999"
			repo_rel_local="0"
		}
		// log '$repo_ver_local' "$repo_ver_local"
		// log '$repo_rel_local' "$repo_rel_local"

	else
		local target_local="$("$@" git -P branch | grep -v remote |
			grep "$target" | tr -d "*" | awk '{$1=$1}1')"
		// log '$target_local' "$target_local"
		# null "$force_fetch" &&
		ok "$target_local" || {
			local targets="$("$@" git tag)"
			(IFS="$newline" && list_contains "$target" $targets) ||
			// tag_fetch "$target" "$url"
		}

		local target_ref="$( \
			"$@" git -P branch | grep -v remotes | grep \* | awk '{print $2}')"

		[ -n "${target_ref:+x}" ] ||
			// die '$target_ref' "\"$target_ref\" is invalid"

		// log '$target_ref' "$target_ref"
		# Not on $target
		[ -z "${target_ref##*"${target}"*}" ] || {
			target_local="$("$@" git -P branch | grep -v remote |
			grep "$target" | tr -d "*" | awk '{$1=$1}1')"
			# git show-ref "$target"
			#
			// log '$target_local' "$target_local"
			null "$target_local" && {
				# # This is creating a new branch
				# # "$@" git checkout "tags/$target" -b "$target"
				"$@" git checkout -b "$target" "refs/tags/$target" 2>&1 ||
				"$@" git switch -c "$target" --track "refs/tags/$target" 2>&1 ||    # Already on 'master'
				// die "git checkout refs/tags/$target" "failed"
			} ||
			# error: pathspec 'timinatorII' did not match any file(s) known to git
				"$@" git checkout "$target" --force > "$TTY" 2>&1 ||
				"$@" git switch "$target" --force > "$TTY" 2>&1 ||
				// die "git checkout $target --force" "failed"
		}

		target_ref="$( \
			"$@" git -P branch | grep -v remotes | grep \* | awk '{print $2}')"
		// log '$target_ref' "$target_ref"

		[ -z "${target_ref##*"${target}"*}" ] ||
		# [ "$("$@" git -P branch | grep -v remotes |
		#     grep "$target" | awk '{print $2}')" == "$target" ] ||
		"$@" git checkout "$target" --force > "$TTY" 2>&1 ||
		"$@" git switch "$target" --force > "$TTY" 2>&1 ||
		// die "git switch $target" "failed"

		# fatal: cannot set up tracking information; starting point 'refs/tags/llvmorg-18-init' is not a branch
		# "$@" git -P branch "--set-upstream-to=refs/tags/$target" "$target" > "$TTY" 2>&1 ||
		#
		# warning: refname 'llvmorg-18-init' is ambiguous.
		# fatal: ambiguous object name: 'llvmorg-18-init'
		# "$@" git -P branch "--set-upstream-to=$target" "$target" > "$TTY" 2>&1 ||
		# // die "git branch \"--set-upstream-to=$target\" $target" "failed"

		target_ref="$( \
			"$@" git -P branch | grep -v remotes | grep \* | awk '{print $2}')"

		[ -z "${target_ref##*"${target}"*}" ] ||
		// die "[ -z \"${target_ref##*"${target}"*}\" ]" "failed"

		// log '$target_ref' "$target_ref"
		is_version "$repo_ver" && is_version "$repo_rel" || {
			local target_local="$target"

			! // || / `ver_parse "$target_local" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			END { print "repo_ver_local=\""$1"\"; repo_rel_local=\""$2"\"" }' ||
			printf '%s\n' "return 1"`

			// log '$repo_ver_local' "$repo_ver_local"
			// log '$repo_rel_local' "$repo_rel_local"
		}

		"$@" git reset --hard "refs/tags/$target" 2>&1 ||
		// war "git reset --hard tags/$target" "failed"

		"$@" git stash --all 2>&1 || :

		# repo_ver_string="$target"
	fi

	! is_version "$repo_ver_local" || ! is_version "$repo_rel_local" || {
		is_version "$repo_ver" && is_version "$repo_rel" && {
			local _left_is_less="$(// left_is_less \
			"$repo_name" "$repo_ver_local-$repo_rel_local" "$repo_ver-$repo_rel")"
			[ -z "$_left_is_less" ] ||
			equ "$_left_is_less" "0" ||
			repo_ver="$repo_ver_local" repo_rel="$repo_rel_local"
		} || {
			repo_ver="$repo_ver_local" repo_rel="$repo_rel_local"
		}
	}

	// log '$repo_ver' "$repo_ver"
	// log '$repo_rel' "$repo_rel"

	is_version "$repo_ver" ||
	// die '$repo_ver' "${repo_ver:+"${repo_ver} "}got wrong value"
	is_version "$repo_rel" ||
	// die '$repo_rel' "${repo_rel:+"${repo_rel} "}got wrong value"

	printf "$RS%s$FS%s" "$repo_ver" "$repo_rel"
}

tag_fetch() {
	_level_2
	local target="$1"
	local url="${2-}"
	[ ! -z "${url:+x}" ] || url="origin"

	set --
	equ "$LOGNAME" "$SRC_USER" ||
		set -- $(// delegate -- as_user "$SRC_USER")

	// log "$target" "fatching from $url"

	local fetch_pid=

	"$@" git config --local --unset remote.origin.tagopt > /dev/null 2>&1
	"$@" git config --local --unset remote.origin.fetch > /dev/null 2>&1
	"$@" git config --local remote.origin.fetch \
		"+refs/heads/*:refs/remotes/origin/*" > /dev/null 2>&1

	as_usr "fetch_pid" "$SRC_USER" \
		git remote update ||
		# fatal: no such remote or remote group: https://github.com/llvm/llvm-project.git
		# git remote update "${url}" ||
	// die "git remote update \"${url}\"" "failed"

	// progress "$fetch_pid" "git fetch"
	# git clone --depth=1, which implies --single-branch
	# Which might later get:
	# error: pathspec 'llvmorg-19-init' did not match any file(s) known to git
	#
	# "$@" git fetch --no-tags origin +refs/tags/"$target":refs/tags/"$target" 2>&1 ||
	# "$@" git fetch origin +refs/tags/"$target":refs/tags/"$target" 2>&1 ||
	# # "$@" git fetch origin "+refs/heads/*:refs/remotes/origin/*" 2>&1 ||
	# "$@" git fetch origin "+refs/heads/$target:refs/remotes/origin/$target" 2>&1 ||
	# "$@" git fetch --tags --prune origin 2>&1 ||
	# "$@" git fetch --tags --force origin 2>&1 ||
	# // die "git fetch $url \"+$target:$target\"" "failed"

	# "$@" git fetch --all --tags --prune
	# "$@" git fetch $url "+$target:$target" --no-tags ||
	# "$@" git fetch --no-tags --depth 1 "${url}" \
	# "+refs/tags/$target:refs/tags/$target" 2>&1 ||
	as_usr "fetch_pid" "$SRC_USER" \
		git fetch --depth 1 --force "${url}" "+refs/tags/$target:refs/tags/$target" 2>&1 ||
	# "$@" git fetch --no-tags --depth 1 "${url}" tag "$target" 2>&1 ||
	as_usr "fetch_pid" "$SRC_USER" \
		git fetch --depth 1 --force "${url}" tag "$target" 2>&1 ||
	# "$@" git fetch --no-tags "${url}" tag "$target" 2>&1 ||
	as_usr "fetch_pid" "$SRC_USER" \
		git fetch --force "${url}" tag "$target" 2>&1 ||
	as_usr "fetch_pid" "$SRC_USER" \
		git fetch --force $url "+refs/tags/$target:refs/tags/$target" --no-tags 2>&1 ||
	as_usr "fetch_pid" "$SRC_USER" \
		git fetch --force $url "+refs/tags/$target:refs/tags/$target" 2>&1 ||
	# "$@" git fetch $url "+refs/heads/*:refs/remotes/origin/*" 2>&1 ||
	as_usr "fetch_pid" "$SRC_USER" \
		git fetch --force $url "+refs/heads/$target:refs/remotes/origin/$target" 2>&1 ||
	# "$@" git fetch --no-tags --tags --prune "${url}" 2>&1 ||
	as_usr "fetch_pid" "$SRC_USER" \
		git fetch --all --tags --prune --force $url 2>&1 ||
	as_usr "fetch_pid" "$SRC_USER" \
		git fetch --tags --force $url 2>&1 || {

		"$@" git config --local --unset remote.origin.tagopt > /dev/null 2>&1
		"$@" git config --local --unset remote.origin.fetch > /dev/null 2>&1
		"$@" git config --local remote.origin.fetch \
			"+refs/heads/*:refs/remotes/origin/*" > /dev/null 2>&1

		// die "git fetch $url \"+refs/heads/$target:refs/remotes/origin/$target\"" "failed"
	}
	// progress "$fetch_pid" "git fetch"
}

#
# sync_remote   ->type_track ->sync_local
# download_git  ->type_track ->sync_local
#
download_git() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
		repo_urn="$(// delegate -- repo_trace "$repo_name")"
	// log '$repo_urn' "$repo_urn"
	shift 1
	local _local_dir="$1"
	local _res="$2"

	// log '$SRC_ROOT' "$SRC_ROOT"
	// log '$SRC_USER' "$SRC_USER"

	set --
	equ "$LOGNAME" "$SRC_USER" ||
		set -- $(// delegate -- as_user "$SRC_USER")

	# // log '$_local_dir' "$_local_dir"
	# "$SRC_ROOT/$repo_name/${dest:+"$dest/"}."

	# Remove "/."
	// log '$_local_dir' "$_local_dir"
	// log '$(realpath $_local_dir)' "$(realpath $_local_dir)"
	// mkcd "$_local_dir" ||
		// die 'mkcd' "failed"

	# Might be empty
	local upstream_name=
	[ -n "${_res##*[@\#]*}" ] || upstream_name="${_res##*[@\#]}"

	local url="${_res%[\#@]*}"
	[ -n "${url:+x}" ] || // die '$url' "\"$url\" is invalid"
	url="$(standardize "$url")"
	null "${url##*".git"*}" ||
	ok "${url##*"github"*}" ||
	url="${url}.git" # url="${url%.git}.git"

	// log '$upstream_name' "$upstream_name"
	// log '$url' "${url}"
	// log '$PWD' "$PWD"

	local force_fetch="1"

	local reference_type= target= repo_ver= repo_rel=

	! // || / `type_track \
		"$repo_urn" "$upstream_name" "$_local_dir" "$url" "$force_fetch" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "reference_type=\""$1"\"; target=\""$2"\"; repo_ver=\""$3"\"; \
	repo_rel=\""$4"\"" }' ||
	printf '%s\n' "return 1"`

	// log 'type : target' "'$(delegate -- format "$reference_type")' : '$target'"
	// log 'remote $repo_ver' "$repo_ver"
	// log 'remote $repo_rel' "$repo_rel"

	local repo_ver_local repo_rel_local

	if [ "$("$@" git -C "$_local_dir" rev-parse \
			--is-inside-work-tree 2>/dev/null)" = "true" ] &&
		[ "$("$@" \ls -1 "$_local_dir" 2> /dev/null)" != "" ]; then

		# Synchronizing already exists git repo

		local remote_url="$("$@" git -C "$_local_dir" remote -v | \
				grep fetch | grep origin | awk '{print $2}')"
		# [ "$remote_url" = "$url" ] ||
		#     ! "$@" git remote remove origin || "$@" git remote add origin "${url}" ||
		#     // die "git remote set-url origin \"${url}\"" "failed"

		[ "$remote_url" = "$url" ] ||
		"$@" git remote set-url origin "${url}" 2>&1 ||
		"$@" git remote add origin "${url}" 2>&1 ||
		// die "git remote set-url origin \"${url}\"" "failed"

		! // || / `sync_local "$reference_type" \
			"$target" "$repo_ver" "$repo_rel" "$_local_dir" "$url" "1" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "repo_ver_local=\""$1"\"; repo_rel_local=\""$2"\"" }' ||
		printf '%s\n' "return 1"`

		"$@" git rev-parse --short HEAD ||
		// war 'git rev-parse --short HEAD' "failed"
		"$@" git describe --always || // war 'git describe --always' "failed"

		"$@" git submodule deinit --all -f
		"$@" git submodule init
		"$@" git submodule sync
		"$@" git submodule update --init --remote --recursive --force
	else

		# Initializing git repo
		printf '%s %s\n' '$(\ls -1 "$_local_dir")' "$LINENO" > "$say_pipe"
		for item in $(\ls -1 "$_local_dir"); do
			printf '%s %s\n' '$(\ls -1 "$_local_dir")' "$item" > "$say_pipe"
		done

		// init_git "$target" "$_local_dir" "$url"

		if [ "$reference_type" = "branch" ]; then
			is_version "$repo_ver" && is_version "$repo_rel" || {
				# repo_ver_local="9999.9999.9999"
				repo_ver_local="0.0.0"
				# repo_rel_local="9999"
				repo_rel_local="0"
				# repo_ver="$(// delegate -- "$@" git rev-parse --short 'HEAD' 2>/dev/null)"
				# repo_ver="$(printf '%s\n' "$( \
				#   "$@" git rev-parse --short 'HEAD' 2>/dev/null)")"

				# [ ! -z "${repo_rel:+x}" ] || repo_rel=
			}
		else
			local target_local=
			target_local="$("$@" git describe --tags \
					"$("$@" git rev-list --tags --max-count=1)"
			)" || // war 'woops' "not a tag type repo"

			! // || / `ver_parse "$target_local" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			END { print "repo_ver_local=\""$1"\"; repo_rel_local=\""$2"\"" }' ||
			printf '%s\n' "return 1"`
		fi

	fi

	! is_version "$repo_ver_local" || ! is_version "$repo_rel_local" || {
		is_version "$repo_ver" && is_version "$repo_rel" && {
			local _left_is_less="$(// left_is_less \
			"$repo_name" "$repo_ver_local-$repo_rel_local" "$repo_ver-$repo_rel")"
			[ -z "$_left_is_less" ] ||
			equ "$_left_is_less" "0" ||
			repo_ver="$repo_ver_local" repo_rel="$repo_rel_local"
		} || {
			repo_ver="$repo_ver_local" repo_rel="$repo_rel_local"
		}
	}

	is_version "$repo_ver" && is_version "$repo_rel" ||
	// die '$repo_ver-$repo_rel' "$repo_ver-$repo_rel"

	// log '$repo_ver' "local $repo_ver"
	// log '$repo_rel' "local $repo_rel"

	# Might be illigal values
	# is_version "$repo_ver" || // die '$repo_ver' "${repo_ver:+"${repo_ver} "}got wrong value"
	# is_version "$repo_rel" || // die '$repo_rel' "${repo_rel:+"${repo_rel} "}got wrong value"

	printf "$RS%s$FS%s" "$repo_ver" "$repo_rel"

}

# Cloninng a repo as a reference
git_sync() {
	local candidates_name="$1"
	local alias="$2"
	local url="$3"
	local target="$4"

	[ -d "$REPO_ROOT_IMPL" ] || \mkdir "$REPO_ROOT_IMPL"

	set --
	local repo_owner="$(// delegate owner "$REPO_ROOT_IMPL")"
	[ "$LOGNAME" = "$repo_owner" ] ||
	set -- "$(// delegate as_user $repo_owner)"

	local candidates_value=
	local _local_dir=

	for item in $("$@" find -L "$REPO_ROOT_IMPL/" -type d -name ".git"); do
		local repo_root="${item%/*}"
		[ "$("$@" git -C "$repo_root" rev-parse \
			--is-inside-work-tree 2>/dev/null)" = "true" ] &&
			[ "$("$@" \ls -1 "$repo_root" 2> /dev/null)" != "" ] || continue
		local item_url="$("$@" git -C "$repo_root" remote -v |
			grep "fetch" | grep "origin" |
			awk '{print $2}'
		)"
		[ "$item_url" = "$url" ] || continue
		candidates_value="$("$@" find -L "$repo_root" -type d -name "$alias")"
		[ -z "${candidates_value:+x}" ] || { _local_dir="$repo_root"; break; }
	done

	[ -n "${_local_dir:+x}" ] || {
		local _des_folder="$(printf '%s' "$url" |
			sed -e 's/https\:\/\///g'  -e 's/.git//g'  -e 's/\//\./g'
		)"

		_local_dir="$REPO_ROOT_IMPL/$_des_folder"

		// init_git "$target" "$_local_dir" "$url"

		candidates_value="$("$@" find -L "$repo_root" -type d -name "$alias")"
	}

	[ "$candidates_name" = '_' ] ||
		/ "$candidates_name=\"\$candidates_value\""

	return 0
}

# Extract source tarball to source dir for further processing
# $1 repo_urn     : package repo url/uri
# $2 $_local_dir  : decompress target
# $3 $_res        : local tar_file
extract_tar() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	shift 1
	local _local_dir="$1"
	local _res="$2"

	[ -n "${_local_dir:+x}" ] || // die '$_local_dir' "$_local_dir"
	# Occupied by $EXTRACT_ROOT/$$repo_name
	# local _local_dir_tmp="/tmp/$LOGNAME/kiss/extract/$repo_name"
	local _local_dir_tmp="$TEMP_ROOT/$repo_name/extract"
	# [ -n "${_local_dir##*"$DEST_ROOT"*}" ] || {
	[ -d "$_local_dir_tmp" ] &&
		// ownership "$LOGNAME" "$_local_dir_tmp" ||
		// as_usr "$LOGNAME" \mkdir -p "$_local_dir_tmp"
	# }

	// mkcd "$_local_dir_tmp" ||
		// die 'mkcd' "failed"

	# find . -mindepth 1 -maxdepth 1 -delete
	for item in $(find "$_local_dir_tmp" -mindepth 1 -maxdepth 1); do
		# [ ! -e "$item" ] || [ ! -h "$item" ] || [ ! -d "$item" ] || {
		// log 'removing' "$item"
		\rm -rf "$item"
		# }
	done

	// log '$0' "$0"
	// log '$_res' "$_res"
	// log '$_local_dir' "$_local_dir"
	// log '$_local_dir_tmp' "$_local_dir_tmp"
	// log '$repo_name' "$repo_name"

	# "leading components"
	# This is a portable shell implementation of GNU tar's
	# '--strip-components 1'. Use of this function denotes a
	# performance penalty.
	local tarball="$(// delegate -- slot_aquire \
		"$repo_name" "$_local_dir_tmp/tarball"
	)"
	// log '$tarball' "$tarball"
	local tarball_manifest="$(// delegate -- slot_aquire \
		"$repo_name" "$_local_dir_tmp/tarball-manifest")"
	// log '$tarball_manifest' "$tarball_manifest"

	// decompress "$_res" > "$tarball" || {
		\rm -f "$tarball"
		// die "$repo_name" "Failed to decompress \
		\"$_res\" to \"$tarball\" and deleted."
	}

	tar xf "$tarball" ||
		// die "$repo_name" "Failed to extract $_res"

	# The sort command filters out all duplicate top-level
	# directories from the tarball's manifest. This is an optimization
	# as we avoid looping (4000 times for Python(!)).
	tar tf "$tarball" | sort -ut / -k1,1 > "$tarball_manifest" ||
		// die "$repo_name" "Failed to extract manifest"

	# Iterate over all directories in the first level of the
	# tarball's manifest. Each directory is moved up a level.
	while IFS=/ read -r dir _; do case "${dir#.}" in *?*)
		# Skip entries which aren't directories.
		[ -d "$dir" ] || continue
		// log '$dir' "$dir"
		# Move the parent directory to prevent naming conflicts
		# with the to-be-moved children.
		\mv -f "$dir" "$KISS_PID-$dir"

		local ifs="$IFS"
		local IFS="$newline"
		local index=0
		for item in $(find "$KISS_PID-$dir/." ! -name . -prune); do
			: $((index += 1))
			// log '$(find "$KISS_PID-$dir/." ! -name . -prune)' "$item"
			[ "$index" -le 10 ] || break
		done
		[ -z "${KISS_DEBUG:+x}" ] ||
		(IFS=$', |' && ! list_contains "$FUNCNAME" $KISS_DEBUG) || {
			local index=0
			for item in $(find "$KISS_PID-$dir/." ! -name . -prune \
				-exec sh -c 'echo "\$0 = $0" "\$@ = $@"' {} +); do
				: $((index += 1))
				// log '$(find "$KISS_PID-$dir/." ! -name . -prune)' "$item"
				[ "$index" -le 10 ] || break
			done
		}
		IFS="$ifs"

		# https://unix.stackexchange.com/questions/696537/how-does-find-type-f-print-o-name-o-prune-actually-work
		# Move all children up a directory level. If the mv command
		# fails, fallback to copying the remainder of the files.
		#
		# We can't use '-exec {} +' with any arguments between
		# the '{}' and '+' as this is not POSIX. We must also
		# use '$0' and '$@' to reference all arguments.
		find "$KISS_PID-$dir/." ! -name . -prune \
			-exec sh -c 'mv -f "$0" "$@" .' {} + 2>/dev/null ||
		find "$KISS_PID-$dir/." ! -name . -prune \
			-exec sh -c 'cp -fRp "$0" "$@" .' {} +

		# Remove the directory now that all files have been
		# transferred out of it. This can't be a simple 'rmdir'
		# as we may leave files in here if any were copied.
		\rm -rf "$KISS_PID-$dir"
	esac done < "$tarball_manifest"

	# Remove the tarball now that we are done with it.
	\rm -f "$tarball"

	[ "$_local_dir_tmp" = "$_local_dir" ] || {
		mkcd "$_local_dir" ||
		// die 'mkcd' "failed"
		// ownership "$_local_dir" "$_local_dir_tmp"
		// as_own "$_local_dir_tmp" rsync -aqz \
			--remove-source-files "$_local_dir_tmp/." "$_local_dir/"
	}
}

# Load all source files to the "make" dir
# $1 repo_urn : package repo url/uri
# Suppose the source is a git repo, then your diff list is:
# git -C "$make_dir" status | grep "modified" | awk "{print \$2}"
# By putting the built binaries under $OBJ_ROOT/$repo_name to
# keep the repo's "files" "patches" folders orgnized,
# the "$make_dir" is maintained as a patching plant / breadboard
# Putting the repo's "files" "patches" folders under the $make_dir
# is a historical convention
pkg_load() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
		repo_urn="$(// delegate -- repo_trace "$repo_name")"
	local repo_dir="${repo_urn%/*}"
	# Extract all source archives to the build directory and copy over any
	# local repository files.

	# NOTE: repo_urn comes from caller.
	// log "$repo_name" "extracting sources"

	# arg1: pre-extract
	# arg2: package name
	# arg3: path to DESTDIR
	// run_hook pre-extract "$repo_name" "$PKG_ROOT/$repo_name"

	local src_dir="$SRC_ROOT/$repo_name"
	local temp_loading="$TEMP_ROOT/$repo_name/loading"
	local make_dir="$MAKE_ROOT/$repo_name"

	// mkcd "$src_dir" "$temp_loading" "$make_dir" ||
		// die 'mkcd' "failed"

	# When debuging in the build directory, rebuild often get the following messages
	# ash: getcwd: No such file or directory
	# Keep the empty folders for debugging convenience might get complains ?
	# find "$make_dir" \( -type f -o -type l \) -exec \rm -f {} +
	# For out-of-source build
	# You could use an additional build path ($OUTPUT_DIR == $OBJ_ROOT/$repo_name)
	# to keep a pure patched source in $MAKE_DIR == $MAKE_ROOT/$repo_name
	# Since rsync could use --delete option, we don't need to clear the $make_dir on each build
	# find "$make_dir" -maxdepth 1 -mindepth 1 -exec \rm -rf {} +
	# find "$make_dir" -mindepth 1 -delete

	while read -r src_url dest || ok "${src_url%%\#*}"; do
		ok "${src_url%%\#*}" || continue
		# Local files relative to $repo_urn
		// log '$src_url' "$src_url"

		local _local_dir _res_type _res _target_name

		! // || / `local_route "$repo_urn" "$src_url" "$dest" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "_local_dir=\""$1"\"; _res_type=\""$2"\"; _res=\""$3"\"; \
		_target_name=\""$4"\"" }' ||
		printf '%s\n' "return 1"`

		// log '$_res_type' "$_res_type"
		// log '$_res' "$_res"
		// log '$_local_dir' "$_local_dir"

		# Create the source's directories if not null.
		ok "$_res" || continue
		# Local files relative to $repo_urn
		// log '$_res' "$_res"
		// log '$_res_type' "$_res_type"
		# Local files absolute path
		// log '$_res [extract]' "$_res"

		# Should be ready
		[ -d "$_local_dir" ] ||
			// as_own "${_local_dir%/*}" \mkdir -p "$_local_dir"
		# // die '$_local_dir' "not a directory: \"$_local_dir\""

		# local dest_dir="$MAKE_ROOT/$repo_name${dest:+"/$dest"}"
		local dest_dir="$src_dir${dest:+"/$dest"}"

		[ "$dest_dir" != "$_local_dir" ] ||
		[ "$_res_type" = "url" ] ||
		[ "$_res_type" = "archive" ] || continue

		dest_dir="$(standardize "$dest_dir")"
		// log '$dest_dir' "$dest_dir"

		# Extra preparations for updating
		case "$_res_type" in
			# Do it in the download stage
			# $_res_type == git, _res is a remote git repository link but it has been sychronized locally
			# $_res_type == url, _res is a remote archive link but it has been sychronized locally
			# "git"|"url"|"archive") ;;
			# "git"|"url")
			"url")
				local src_name="${src_url##*/}"
				src_name="${src_name%\?*}"
				local archive_local="$ARCHIVE_ROOT/$repo_name/${dest:+"$dest/"}$src_name"

				[ -f "$archive_local" ] ||
					local tar_file="$(// delegate -- download_url "$repo_name" "$_local_dir" "$_res")"

				# Might outdated
				is_archive "$archive_local" ||
				[ ! -z "${KISS_FORCE+x}" ] ||
				# ok "(ls -l --time-style=+'%d-%m-%Y' "$archive_local" | awk -v d=$(date +%d-%m-%Y) '$6==d')" ||
				[ "$(date -d @$(stat -c %Y "$archive_local") +%d-%m-%Y)" = "$(date +%d-%m-%Y)" ] ||
				// delegate -- download_url "$repo_name" "$_local_dir" "$_res"

				! is_archive "$archive_local" ||
					// extract_tar "$repo_name" "$dest_dir" "$_res"
				;;
			"archive")
					// extract_tar "$repo_name" "$dest_dir" "$_res"
				;;
			# Direct repository files
			*)
				// log '$_res' "$_res got updated in extra preparations"
				# equ "$_target_name" "." ||
				# For example:
				# Source: $ARCHIVE_ROOT/$repo_name/file.c
				# Target: $SRC_ROOT/$repo_name${dest:+"/$dest"}
				#
				# local _target_dir="$SRC_ROOT/$repo_name${dest:+"/$dest"}"
				# local _target_dir="$MAKE_ROOT/$repo_name${dest:+"/$dest"}"
				local _target_dir="$temp_loading${dest:+"/$dest"}"
				// log '$_target_dir' "$_target_dir"
				# [ -n "${_res##*"${repo_dir}"*}" ] ||
				# [ "$_local_dir/$_target_name" = "$_res" ] ||
				# ! rsync -aqz "$_res" "$_local_dir/" || ! sync ||
				! rsync -aqz "$_res" "$_target_dir/" ||
					! // sync ||
					! // empty "$_target_dir" ||
					// die '$_target_dir' "empty directory $_target_dir"
		esac

		# Should cold be ready
		# [ -d "$_des_dir" ] ||
		# // die '$_des_dir' "not a directory: \"$_des_dir\""

		# local dest_dir="$make_dir/$repo_name${dest:+"/$dest"}"
		# dest_dir="$(standardize "$dest_dir")"
		# // log '$dest_dir' "$dest_dir"

		# Change to target build directory
		# // mkcd "$dest_dir"

		# ! empty "$_local_dir" ||
		#   // die '$_local_dir' "empty directory: $_local_dir"
		#
		# equ "$_target_name" "." ||
		# [ -f "$_local_dir/$_target_name" ] ||
		#   // die '$_local_dir/$_target_name' \
		#       "'$_local_dir/$_target_name' does not exist"
		# // log '$_local_dir/$_target_name' \
		#   "\"$_local_dir/$_target_name\" as the copy source"

		# # Do the copy job
		# # Source: $SRC_ROOT/$repo_name${dest:+"/$dest"}
		# # Target: $MAKE_ROOT/$repo_name${dest:+"/$dest"}
		# ! rsync -aqz "$_local_dir/$_target_name" ./ || ! sync ||
		# ! empty "$dest_dir" ||
		#   // die '$dest_dir' "empty directory $dest_dir"

		# equ "$_target_name" "." ||
		# ! empty "$dest_dir/$_target_name" ||
		# [ -f "$dest_dir/$_target_name" ] ||
		#   // die '$dest_dir/$_target_name' \
		#       "'$dest_dir/$_target_name' empty directory\
		#       ${newline}or file does not exist"

		# // log 'copied' "from \"$_local_dir/$_target_name\"\
		#   ${newline}to\"$PWD/$_target_name\""

		# cd "$src_dir"

	done < "$repo_urn/sources" ||
	// die "$repo_name" "Failed to extract $_res"
	# Use this rsync method to void deleting entire make folder
	#
	! rsync -aqz --delete "$src_dir/." "$make_dir/" ||
		! sync ||
		! empty "$make_dir" ||
		// die '$make_dir' "empty directory $make_dir"

	! rsync -aqz "$temp_loading/." "$make_dir/" ||
		! // sync ||
		! // empty "$make_dir" ||
		// die '$make_dir' "empty directory $make_dir"

	// ownership "$VOLATILE" "$make_dir"

}

# alias quit_depends=' { printf "$RS%s$FS%s$FS%s" "$explicit" "$makedeps" "$deps"; return $result; } '
# Without "interrupt" in this recursive function ?
# $1 explicit   : explicit build targets list
# $1 makedeps   : local host "make" depends list
# $2 deps       : depends list
# shift 3
# $1 repo_urn   : package repo url/uri
# $2 policies   : raw  -- eat explicit
#               : expl -- keep explicit (do not merge $1 to deps if it is in explicit)
# $3 filter     : filter switch
# $4 appended   : dependencies appended
# $5 dep_stage  : dependent type/stage [build time / runtime]
# return 1, delegate not happy
# interrupt, does not work
# Fail is not an fatal error, just tell no such dependency could depend
pkg_depends() {
	_level_1
	local explicit="$1"
	local makedeps="$2"
	local deps="$3"
	shift 3

	# Is going to be built or installed
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	# is_repos "$repo_urn" ||
	#     repo_urn="$(// delegate -- repo_trace "$repo_name")"
	# TODO: Exclude the installed target, pick_up alternatives it here ?
	local repo_target="$KISS_ROOT/$db/$repo_name"
	// log '$repo_target' "$repo_target"

	local policy="${2-}"
	local filter="${3-}"
	local appended="${4-}"
	local dep_stage="${5-}"

	# local: explicit: is read only
	# Recursively calling pkg_depends needs assign explicit each time ?
	# [ "$policy" != "expl" ] || readonly explicit

	local result=0
	// debug_filter -- // log "$I \$explicit" "$(esceval $explicit)"
	// debug_filter -- // log "$I \$makedeps" "$(esceval $makedeps)"
	// debug_filter -- // log "$I \$deps"     "$(esceval $deps)"

	// log "$I \$repo_urn"  "$repo_urn"
	// log "$I \$policy"    "$policy"
	// log "$I \$filter"    "$filter"
	// debug_filter -- // log "$I \$appended"  "$(esceval $appended)"
	// log "$I \$dep_stage" "$dep_stage"
	# Does not work when defiened inside pkg_depends()
	# alias quit_depends=' { printf "$RS%s$FS%s$FS%s" "$explicit" "$makedeps" "$deps"; return $result; } '
	quit_dep() { printf "$RS%s$FS%s$FS%s" "$explicit" "$makedeps" "$deps"; return 0; }

	# Resolve all dependencies and generate an ordered list. The deepest
	# dependencies are listed first and then the parents in reverse order.
	[ -z "$(// delegate filter_contains "key_filter" "$repo_urn" $deps)" ] || ! quit_dep || return $result

	# Do not filter
	null "$filter" ||
	# raw/expl
	ok "$policy" ||
	# Explicit
	[ ! -z "$(// delegate filter_contains "key_filter" "$repo_urn" $explicit)" ] ||
	# Has not been installed
	! is_repos "$repo_target" || ! quit_dep || return $result # Filter out non-explicit, already installed packages.

	# Detect circular dependencies and bail out.
	# Looks for multiple repeating patterns of (dep dep_parent) (5 is max).
	local tail=${appended##* }
	case " ${appended} " in
		*" ${tail} "*" ${repo_urn} "*" ${tail} "*" ${repo_urn} "*" ${tail} "*" ${repo_urn} "*" ${tail} "*" ${repo_urn} "*" ${tail} "*" ${repo_urn} "*)
		// war "$repo_name <> ${tail}" "circular dependency detected"
		! quit_dep || return $result
	esac

	# Normally input repo_urn is a name, upgrade/instantiate it to a real repo
	repo_urn="$repo_target"

	is_repos "$repo_target" || {
		[ -d "$repo_target" ] ||
		// war '$repo_name' "'$repo_name' does not exist or is not yet installed"
		repo_urn="$(// delegate -- repo_trace "$repo_name")" || {
			// war '$repo_name' "repo not found"
			! quit_dep || return $result
		}
		is_repos "$repo_urn" || {
			// war '$repo_urn' "'$repo_urn' is not a valid repo"
			! quit_dep || return $result
		}
	}

	// log '$repo_urn' "'$repo_urn'${newline}was instantiated from '$repo_name'"
	# // log '$KISS_ROOT' "$KISS_ROOT"

	# // log '$policy' "$policy"
	# // log '$filter' "$filter"
	# // log '$appended' "$(esceval $appended)"

	make_depends() {
		_level_2
		local repo_urn="$1"
		local repo_name="${repo_urn##*/}"
		repo_name="${repo_name%%@*}"
		local result=0
		local repo=
		for repo do
			# Only add to list once
			[ -z "$(// delegate filter_contains "key_filter" "$repo_name" "$@")" ] &&
			# Filter already installed packages on build machine.
			! is_repos "$sys_db/$repo_name" ||
				continue
			# Add to the list
			# makedeps="${makedeps:+"${makedeps} "}$repo_name"
			set -- "$repo_name" "$@"
		done
		printf "$RS%s" "$@"
	}

	# Packages which exist and have depends.
	# ! // null "$(// delegate -- repo_trace "$repo_name")" ||
	# // die '$repo_name' "'$repo_name' does not exist"
	is_repos "$repo_urn" || {
		// war '$repo_name' "'$repo_urn' is not a valid repo"
		tree "$repo_urn"

		# type_include "archive" "function" ||
		#   . /usr/bin/kiss-alter

		alter "archive" "$repo_urn" ||
			// die "$repo_urn archiving" "failed"
		# / "// as_own \"$REPO_ROOT_IMPL/\" \
		#   $ENV_VARIABLES \
		#   /usr/bin/kiss archive \"$repo_urn\""

		local content="$( \
			// delegate -- prompt "Delete the invalid packages and restart the process?${newline}\
			'$repo_urn'${newline}\
			It has been archived in '$KISS_REPO/base' [*|n|ctrl+c]")"

		expr "$content" : '[n|N]\+' > /dev/null ||
			\rm -rf "$repo_urn"

		! quit_dep || return $result
	}

	local dep= dep_type=
	[ ! -e "$repo_urn/depends" ] ||
	# Recurse through the dependencies of the child packages.
	while read -r dep dep_type || ok "$dep"; do
		{
			ok "${dep##\#*}" && ok "${dep##*/*}" &&
			[ -z "$(// delegate filter_contains "key_filter" "$repo_urn" $appended)" ]
		} || continue

		// war '$dep : $dep_type' \
		"'$(delegate -- format "$dep" 8)' : '$(delegate -- format "$dep_type" 8)' <- $repo_name"

		# KISS_ROOT    true            false
		# dep_type
		# true         make_depends    pkg_depends
		# false        pkg_depends     pkg_depends

		ok "$dep_type" &&
		[ ! -z "${KISS_ROOT:+x}" ] &&
		# Host only dependencies
		makedeps="$(// delegate -- make_depends "$dep" $makedeps)" || {
			# local: explicit: is read only
			# $([ "$policy" = "expl" ] && printf '%s' "_" || printf '%s' "explicit") \

			! // || / `pkg_depends \
				"$explicit" "$makedeps" "$deps" \
				"$dep"      ""      "$filter" \
				"${appended:+"${appended} "}$repo_urn" "$dep_type" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			END { print "explicit=\""$1"\"; makedeps=\""$2"\"; deps=\""$3"\"" }' ||
			printf '%s\n' "return 1"`
		}
	done < "$repo_urn/depends" || :

	# Add parent to the dependencies list right (tail).
	# Already in $explicit list
	// equ "$policy" "expl" && {
		! equ "$dep_stage" make ||
		ok "$(// delegate -- pkg_cache "$repo_urn")"
	} ||
	# { [ -n "${deps:+x}" ] && [ -z "${deps##*"${repo_urn##*/}"*}" ]; } ||
	[ ! -z "$(// delegate filter_contains "key_filter" "$repo_urn" $explicit)" ] ||
	[ ! -z "$(// delegate filter_contains "key_filter" "$repo_urn" $deps)" ] || {
		deps="${deps:+"${deps} "}$repo_urn"
		// equ "$policy" "expl" || {
			[ -z "$(// delegate filter_contains "key_filter" "$repo_urn" $explicit)" ] || {
				local temp_list=
				for item in $explicit; do
					[ "$item" != "$$repo_urn" ] || continue
					temp_list="${temp_list:+"${temp_list} "}$item"
				done
				explicit="$temp_list"
			}
		}
	}

	// debug_filter -- // log "$O \$explicit" "$(esceval $explicit)"
	// debug_filter -- // log "$O \$makedeps" "$(esceval $makedeps)"
	// debug_filter -- // log "$O \$deps"     "$(esceval $deps)"

	# Return multi values without "process substitution".
	# But needs "eval" at the caller side
	# When return earlier, pay attention to print result, please
	! quit_dep || return $result
}

# "$@" : all packages
pkg_order() {
	_level_2
	local explicit="$1"
	shift 1

	// log '$explicit' "$explicit"
	# readonly explicit

	local makedeps=
	local deps=
	local order=
	local redro=
	# local policy_of_explicit="expl"
	local policy_of_explicit="$EXPLICIT_POLICY"
	local repo_urn=

	for repo_urn in $explicit; do
		[ ! -z "$(// delegate filter_contains "key_filter" "$repo_urn" "$@")" ] ||
			set -- "$@" "$repo_urn"
	done

	# Order a list of packages based on dependence and take into account
	# pre-built tarballs if this is to be called from 'kiss i'.
	# order -- from deps to explicit target
	# redro -- from explicit target to deps
	local order= redro=
	for repo_urn do
		case $repo_urn in
			/*@*.tar.*)
				deps="${deps:+"${deps} "}$repo_urn" ;;
			*@*.tar.*)
				deps="${deps:+"${deps} "}$ppwd/$repo_urn" ;;
			# */*)
				# // die 'Not a package' "$repo_urn" ;;
			*)
				# // pkg_depends "makedeps" "deps" "$repo_urn" raw

				! // || / `pkg_depends \
					"$explicit" "$makedeps" "$deps" \
					"$repo_urn" "$policy_of_explicit" |
					awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
				END { print "explicit=\""$1"\"; makedeps=\""$2"\"; deps=\""$3"\"" }' ||
				printf '%s\n' "return 1"`

				# for item in $makedeps; do
				#   [ -d "$KISS_ROOT/$db/$item" ] || (args i "$item")
				# done
		esac
	done

	# // log '$*' "$*"
	// debug_filter -- // log '$@' "$(esceval "$@")"

	# Filter the list, only keeping explicit packages. The purpose of these
	# two loops is to order the argument list based on dependence.
	for repo_urn in $deps; do
		! equ "$policy_of_explicit" "expl" ||
		[ -z "$(// delegate filter_contains "key_filter" "$repo_urn" $explicit)" ] || continue
		case " $* " in
			*" ${repo_urn} "*|*" ${repo_urn##*/} "*|*" ${repo_urn##"$ppwd/"} "*)
				[ ! -z "$(// delegate filter_contains "key_filter" "$repo_urn" $order)" ] ||
					order="${order:+"${order} "}$repo_urn"
				[ ! -z "$(// delegate filter_contains "key_filter" "$repo_urn" $redro)" ] ||
					redro="$repo_urn${redro:+" ${redro}"}"
		esac
	done

	// debug_filter -- // log '$explicit' "$(esceval $explicit)"
	// debug_filter -- // log '$makedeps' "$(esceval $makedeps)"
	// debug_filter -- // log '$deps' "$(esceval $deps)"
	// debug_filter -- // log '$order' "$(esceval $order)"
	// debug_filter -- // log '$redro' "$(esceval $redro)"

	# unset deps

	printf "$RS%s$FS%s$FS%s$FS%s$FS%s" "$explicit" "$makedeps" "$deps" "$order" "$redro"
}

pkg_strip() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"

	# Strip package binaries and libraries. This saves space on the system as
	# well as on the tarballs we ship for installation.
	[ ! -f "$MAKE_ROOT/$repo_name/nostrip" ] || [ -z "${KISS_STRIP:+x}" ] ||
	! equ "${KISS_STRIP}" "0" || return 0

	// log "$1" "Stripping binaries and libraries"

	# Strip only files matching the below ELF types. This uses 'od' to print
	# the first 18 bytes of the file. This is the location of the ELF header
	# (up to the ELF type) and contains the type information we need.
	#
	# Static libraries (.a) are in reality AR archives which contain ELF
	# objects. We simply read from the same 18 bytes and assume that the AR
	# header equates to an archive containing objects (.o).
	#
	# Example ELF output ('003' is ELF type):
	# 0000000 177   E   L   F 002 001 001  \0  \0  \0  \0  \0  \0  \0  \0  \0
	# 0000020 003  \0
	# 0000022
	#
	# Example AR output (.a):
	# 0000000   !   <   a   r   c   h   >  \n   /
	# 0000020
	# 0000022
	while read -r file; do [ -h "$PKG_ROOT/$repo_name$file" ] || case "$file" in
		# Look only in these locations for files of interest (libraries,
		# programs, etc). This includes all subdirectories. Old behavior
		# would run od on all files (upwards of 4000 for Python).
		*/sbin/?*[!/]|*/bin/?*[!/]|*/lib/?*[!/]|\
			*/lib??/?*[!/]|*/lib???/?*[!/]|*/lib????/?*[!/])

			case "$(od -A o -t c -N 18 "$PKG_ROOT/$repo_name$file")" in
				# REL object files -- .o, static libraries -- .a.
				*"177"*"E"*"L"*"F"*"0000020\ 001\ "*|*"\!"*"\<"*"a"*"r"*"c"*"h"*"\>"*)
					// run strip -g -R .comment -R .note "$PKG_ROOT/$repo_name$file" ;;

				# EXEC -- binaries, DYN -- shared libraries
				# Shared libraries keep global symbols in a separate ELF section
				# called '.dynsym'. '--strip-all/-s' does not touch the dynamic
				# symbol entries which makes this safe to do.
				*"177"*"E"*"L"*"F"*"0000020\ 00[23]\ "*)
					// run strip -s -R .comment -R .note "$PKG_ROOT/$repo_name$file"
			esac
	esac done < "$PKG_ROOT/$repo_name/$db/$repo_name/manifest" || :
}

# could be subshell function before local version
# $1 repo_urn : package repo url/uri
pkg_fix_deps() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"

	# Dynamically look for missing runtime dependencies by checking each
	# binary and library with 'ldd'. This catches any extra libraries and or
	# dependencies pulled in by the package's build suite.
	// log "$repo_name" "looking for dependencies (using ${cmd_elf##*/})"

	# "$PWD" == "$PKG_ROOT/$repo_name/$db/$repo_name"
	// log '$PWD' "$PWD"
	// log '$KISS_ROOT/$db' "$KISS_ROOT/$db"
	// log '$repo_name' "$repo_name"

	local depends_clone="$(// delegate -- slot_push "$repo_name" "depends")"
	// log 'depends' "was pushed to \$depends_clone == \"$depends_clone\""

	local depends_fixed="$(// delegate -- slot_aquire "$repo_name" "depends-fixed")"
	// log 'depends_fixed' "was aquired \$depends_fixed == \"$depends_fixed\""

	set +f
	set -f -- "$KISS_ROOT/$db/"*/manifest

	local _fdep_seen= _file

	# False positive (not a write).
	# shellcheck disable=2094
	while read -r _file; do [ -h "$_file" ] || case "$_file" in
		# Look only in these locations for files of interest (libraries,
		# programs, etc). This includes all subdirectories. Old behavior
		# would run ldd on all files (upwards of 4000 for Python).
		*/sbin/?*[!/]|*/bin/?*[!/]|*/lib/?*[!/]|\
			*/lib??/?*[!/]|*/lib???/?*[!/]|*/lib????/?*[!/])

		// debug '$_file' "$_file"
		# [ "${_file:0:1}" = '/' ] || _file="${_file:1}"

		# The readelf mode requires ldd's output to resolve the library
		# path for a given file. If ldd fails, silently skip the file.
		local ldd=
		ldd="$(ldd -- "$PKG_ROOT/$repo_name$_file" 2>/dev/null)" || continue

		# Attempt to get information from readelf. If this fails (or we
		# are in ldd mode), do full ldd mode (which has the downside of
		# listing dependencies of dependencies (and so on)).
		local elf=
		elf="$("$cmd_elf" -d "$PKG_ROOT/$repo_name$_file" 2>/dev/null)" || elf=$ldd

		# Iterate over the output of readelf or ldd, extract file names,
		# resolve their paths and finally, figure out their owner.
		while read -r lib; do
			case "$lib" in *"NEEDED"*"["*"]"|*"=>"*)
				# readelf: 0x0000 (NEEDED) Shared library: [libjson-c.so.5]
				lib="${lib##*"["}"
				lib="${lib%%"]"*}"

				# Resolve library path.
				# ldd: libjson-c.so.5 => /lib/libjson-c.so.5 ...
				case "$cmd_elf" in
					*"readelf")
						lib="${ldd#*"  $lib => "}" ;;
					*)
						lib="${lib##*"=> "}"
				esac
				lib="${lib%% *}"

				# Skip files owned by libc, libc++ and POSIX.
				case "${lib##*/}" in
					"ld-"*           |\
					"lib[cm].so"*    |\
					"libc++.so"*     |\
					"libc++abi.so"*  |\
					"libcrypt.so"*   |\
					"libdl.so"*      |\
					"libgcc_s.so"*   |\
					"libmvec.so"*    |\
					"libpthread.so"* |\
					"libresolv.so"*  |\
					"librt.so"*      |\
					"libstdc++.so"*  |\
					"libtrace.so"*   |\
					"libunwind.so"*  |\
					"libutil.so"*    |\
					"libxnet.so"*    |\
					"ldd")
						continue
				esac

				# Skip files we have seen before.
				case " $_fdep_seen " in
					*" $lib "*) continue ;;
					*) _fdep_seen="$_fdep_seen $lib"
				esac

				local rpath="$(// delegate -- resolve_path "$lib")"

				# Skip file if owned by current package
				[ "$(// delegate -- manifest_repo -e "$rpath" manifest)" != "$repo_name" ] || continue
				local repo_owns="$(// delegate -- manifest_repo -e "$rpath" "$@")"
				[ -z "$repo_owns" ] || printf '%s\n' "$repo_owns"

			esac
		done << EOF || :
$elf
EOF
		# esac done < <([ "$?" -eq 0 ] || :; printf "%s\n" "$elf") > /dev/null ||
		# // die 'printf "%s\n" "$elf"' "failed"
	esac done < manifest |
	# Sort the depends file (including the existing depends file) and
	# remove any duplicate entries. This can't take into account comments
	# so they remain rather than being replaced.
	sort -u -k 1,1 "$depends_clone" /dev/stdout > "$depends_fixed"

	[ ! -s "depends" ] || {
		local depends_list="$(cat depends)"
		for item in $depends_list; do
			// log "to fix" "$item"
		done
	}

	# If the depends file was modified, show a diff and replace it.
	[ ! -s "$depends_fixed" ] || {
		diff -U 3 "$depends_clone" "$depends_fixed" 2>/dev/null || :

		// log 'to be $depends_fixed' "$depends_fixed"
		# Replace the existing depends file if one exists, otherwise this
		# just moves the file to its final resting place.
		\mv -f "$depends_fixed" depends
		local depends_list="$(cat depends)"
		for item in $depends_list; do
			// log 'Fixed $item' "$item"
		done
		# Generate a new manifest as we may be the creator of the depends
		# file. This could otherwise be implemented by inserting a line
		# at the correct place in the existing manifest.
		# "$PWD" == "$PKG_ROOT/$repo_name/$db/$repo_name"
		// pkg_manifest "$PWD" "$PKG_ROOT" & // progress "$!" "manifest checking"
	}
}

# Could be subshell function before local version
# $1 repo_urn                   : package repo url/uri
# $2 $PKG_ROOT / $EXTRACT_ROOT  : package directory / extracting directory
pkg_manifest() {
	_level_2
	# "$PKG_ROOT/$repo_name/$db/$repo_name"
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	# "$PKG_ROOT" or "$EXTRACT_ROOT"
	local repo_dir="$2"
	# "$PKG_ROOT/$repo_name" or "$EXTRACT_ROOT/$repo_name"
	local pkg_dir="$repo_dir/$repo_name"
	# Generate the package's manifest file. This is a list of each file
	# and directory inside the package. The file is used when uninstalling
	# packages, checking for package conflicts and for general debugging.
	// log "$repo_name" "generating manifest"
	// log '$pkg_dir' "$pkg_dir"
	// log '$db' "$db"

	local manifest="$(// delegate -- slot_aquire "$repo_name" "manifest")"
	local manifest_buffer="$(// delegate -- slot_aquire "$repo_name" "manifest_buffer")"

	local version_list=
	local file
	for file in $(// as_own "$pkg_dir" \
		find "$pkg_dir/$db/$repo_name" -mindepth 1 -maxdepth 1 -type d); do
		local folder="${file##*/}"
		// log '$folder' "$folder"
		[ ! -z "${folder##*"-"*}" ] || {
			// log '$folder' "$folder [selected]"
			local head="${folder%%-*}"
			local tail="${folder##*-}"
			echo "head: $head, tail $tail"
			! is_version "$head" || ! is_version "$tail" ||
			version_list="${version_list:+"$version_list$newline"}$folder"
		}
	done

	// log '$version_list' "$version_list"
	local folder_clause="find \"$pkg_dir\" -type d -not \( -path \"$pkg_dir\" -type d \)"
	local file_clause="! -type d -a ! -name \\*.la -a ! -name charset.alias"
	local ifs="$IFS"
	local IFS="$newline"
	local item
	for item in $version_list; do
		folder_clause="$folder_clause -not \( -path \"*/$item\" -type d -prune \)"
		file_clause="$file_clause -a ! -path \"*/$item/*\""
	done
	IFS="$ifs"
	local find_clause="$folder_clause -exec printf '%s/\n' {} + -o \( $file_clause \) -print"

	// log '$find_clause' "$find_clause"

	# Create a list of all files and directories. Append '/' to the end of
	# directories so they can be easily filtered out later. Also filter out
	# all libtool .la files and charset.alias.
	{
		printf '%s\n' "/$db/$repo_name/manifest"

		[ ! -d "$pkg_dir/etc" ] ||
		printf '%s\n' "/$db/$repo_name/etcsums"

		# No folder printed
		# // as_own "$pkg_dir" find "$pkg_dir" \
		#   -type f \
		#   -not \( -path "$pkg_dir" -o -path "*/*-*/*" \) -type d -prune \
		#   -exec printf '%s/\n' {} + \
		#   -o \( ! -type d -a ! -name \*.la -a ! -name charset.alias -a ! -path "*/*-*/*" \) \
		#   -print | sed "s#${pkg_dir}##g"
		#
		# Don't quote $find_clause [ "command not found" error ]

		# / "// as_own \"$pkg_dir\" $find_clause | sed \"s#${pkg_dir}##g\""
		/ "// as_own \"$pkg_dir\" $find_clause | sed 's#${pkg_dir}##g'"

		# Sort the output in reverse. Directories appear after their contents.
	} | sort -ur > "$manifest_buffer"

	local index=0
	while read -r line || ok "$line"; do
		: $((index += 1))
		[ ! -z "${line##*"${pkg_dir}"*}" ] || {
			// log '$manifest_buffer' "$(delegate -- format "$index") $line"
			# break
			// die '$manifest_buffer' \
				"'${pkg_dir}' should not appear${newline}\
				Maybe the build script has PREFIX=\"\$1/usr\" which should be PREFIX=\"/usr\""
		}

		[ "$(// delegate -- occurrences "$line" "/")" -gt "1" ] || {
			// war '$line' "'$line' seems like wants to put file to the system root${newline}\
			Normally it should use usr/, var/, or some sub folders else under $KISS_ROOT/"
			// die '$repo_name' "check '$repo_name' build script, please"
		}
	done < "$manifest_buffer"

	[ -s "$manifest_buffer" ] || // die '$manifest_buffer' "'$manifest_buffer' is empty"

	[ ! -s "$manifest" ] ||
	echo "$(cat "$manifest")" >> "$manifest_buffer"

	sort -ur < "$manifest_buffer" > "$manifest"

	# // log '$manifest' "$manifest"
	[ -s "$manifest" ] || // die '$manifest' "'$manifest' is empty"

	local index=0
	while read -r line; do
		: $((index += 1))
		// debug "\$manifest $(delegate -- format "$index")" "$line" &
	done < "$manifest"

	// as_usr "$SRC_USER" /usr/bin/touch "$pkg_dir/$db/$repo_name/manifest"
	# Remove the prefix from each line.
	while read -r file; do
		// as_usr "$SRC_USER" printf '%s\n' "${file#"$pkg_dir"}"
	done < "$manifest" > "$pkg_dir/$db/$repo_name/manifest"
}

# "$@" :
pkg_etcsums() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"

	# Generate checksums for each configuration file in the package's /etc/
	# directory for use in "smart" handling of these files.
	// log "$repo_name" "generating etcsums"
	shift "$(($# >= 1? 1 : $#))"

	# Minor optimization - skip packages without /etc/.
	[ -d "$PKG_ROOT/$repo_name/etc" ] || return 0

	# Create a list of all files in etc but do it in reverse.
	while read -r etc; do case "$etc" in "/etc/"*[!/])
		set -- "$PKG_ROOT/$repo_name/$etc" "$@"
	esac done < "$PKG_ROOT/$repo_name/$db/$repo_name/manifest"

	local hash="$(// delegate -- "sh256" "$@")"
	// as_usr "$SRC_USER" sh -c "printf '%s\\n' \"$hash\" \
		> \"$PKG_ROOT/$repo_name/$db/$repo_name/etcsums\""
}

# Package files to a tar_file
# $1 repo_urn : package repo url/uri
pkg_tar() {
	_level_2
	// log '$repo_name' "$repo_name [global]"
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
		repo_urn="$(// delegate -- repo_trace "$repo_name")"
	// log '$repo_name' "$repo_name [local]"

	# Create a tarball from the built package's files. This tarball also
	# contains the package's database entry.
	#
	# NOTE: repo_ comes from caller.
	// log "$repo_name" "tarball creating"
	# tree "$PKG_ROOT"

	local repo_dir= repo_ver= repo_rel= repo_alias= repo_url= reference_type=

	! // || / `pkg_version "$repo_urn" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_dir=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"; \
	repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`

	ok "$repo_ver" || // die '$repo_ver' "$repo_ver"
	local file_name="$repo_name@$repo_ver-$repo_rel.tar.$KISS_COMPRESS"
	local tar_file="$TAR_ROOT/$repo_name/$file_name"

	set --
	local tar_dir_user="$(// delegate owner "$TAR_ROOT")"
	[ "$LOGNAME" = "$tar_dir_user" ] || {
		// ownership "$TAR_ROOT" "$PWD"
		set -- $(// delegate as_user "$tar_dir_user")
	}

	[ -d "$TAR_ROOT/$repo_name" ] ||
		"$@" \mkdir -p "$TAR_ROOT/$repo_name"
	local repofile="repo.index"

	# Use 'cd' to avoid needing tar's '-C' flag which may not be portable
	# across implementations.
	cd "$PKG_ROOT/$repo_name" || // war '$repo_urn' "can not change directory to \"$repo_urn\""
	// log '$PWD' "$PWD"
	# Create a tarball from the contents of the built package.
	# /etc/... files miight need root privilege
	// as_usr "root" /usr/bin/tar cf - . | case $KISS_COMPRESS in
		bz2)  "$@" bzip2  -z     ;;
		gz)   "$@" gzip   -6     ;;
		lzma) "$@" lzma   -zf    ;;
		lz)   "$@" lzip   -z     ;;
		xz)   "$@" xz     -zT0f  ;;
		zst)  "$@" zstd   -z     ;;
	esac > "$tar_file"

	# Remove any instances of this package in the index
	# This will leave only the latest version
	"$@" touch "$TAR_ROOT/$repo_name/$repofile"
	"$@" sed -i "/$repo_name@/d" "$TAR_ROOT/$repo_name/$repofile"

	# Write the checksum to the repo file
	local cs="$(// delegate -- "_sh256" "$tar_file")"
	"$@" echo "$cs  $file_name" >> "$TAR_ROOT/$repo_name/$repofile"
	// log "$repo_name" "repo index updated"

	cd "$OLDPWD"

	// log "$repo_name" "tarball created successfully"
	// log '$tar_file' "$tar_file"

	# arg1: post-package
	# arg2: package name
	# arg3: path to tarball
	// run_hook post-package "$repo_name" "$tar_file"
}

# Make sure "$explicit" -- the return packages all was built
# "$@" packages repo url/name
build_all() {
	_level_2

	local action="build"
	local explicit="$1"
	# Implicit build packages
	local makedeps="$2"
	local deps="$3"
	shift 3
	# A minimal set of input packages
	local expected_to_be_built_and_only_being_built="$*"
	local mandatory_explicit_build=

	set -- $makedeps $deps

	# Build packages and turn them into packaged tarballs.
	# Order the argument list and filter out duplicates.

	# Mark packages passed on the command-line explicit.
	# Also resolve dependencies for all explicit packages.
	for repo_urn do
		local repo_name="${repo_urn##*/}"
		repo_name="${repo_name%%@*}"
		// pkg_dirs "$action" "$repo_name"
		// pkg_clear "$action" "$repo_urn"

		! // || / `pkg_depends \
			"$explicit" "$makedeps" "$deps" \
			"$repo_urn" "expl"      "filter" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "explicit=\""$1"\"; makedeps=\""$2"\"; deps=\""$3"\"" }' ||
		printf '%s\n' "return 1"`

		[ ! -z "$(// delegate filter_contains "key_filter" "$repo_urn" $makedeps)" ] ||
		[ ! -z "$(// delegate filter_contains "key_filter" "$repo_urn" $deps)" ] ||
		explicit="${explicit:+"${explicit} "}$repo_urn"
	done

	// log '$explicit' "$explicit"
	// log '$makedeps' "$makedeps"
	// log '$deps' "$deps"

	# If this is an update, don't always build explicitly passsed packages
	# and instead install pre-built binaries if they exist.
	# [ -n "${prefer_cache:+x}" ] || mandatory_explicit_build=$explicit

	# Host dependencies
	# If cross building, make sure the build machine has the correct deps
	set -- $makedeps
	// log '$#' "$# after \"set -- \$makedeps\""
	[ "$#" -le 0 ] || {
		local repo
		for repo do
			is_repos "$KISS_ROOT/$db/${repo##*/}" &&
			[ -z "${TREE_FORCE+x}" ] || {
				// war "You need the following package on your building machine (host)" "$repo"
				(export KISS_ROOT=; // pick_up "$repo")
			}
		done
	}

	set --

	# If an explicit package is a dependency of another explicit package,
	# remove it from the explicit list.
	for repo_urn in $explicit; do
		# local repo_name="${repo_urn##*/}"
		# repo_name="${repo_name%%@*}"
		[ ! -z "$(// delegate filter_contains "key_filter" "$repo_urn" $deps)" ] ||
		set -- "$@" "$repo_urn"
	done
	explicit_count=$#
	explicit=$*

	// log '$explicit_count' "$explicit_count"

	// log 'explicit' "$(echo "$explicit" | tr ' ' "$newline")"
	// log 'implicit' "$(echo "$deps"     | tr ' ' "$newline")"

	# Intentional, globbing disabled.
	# shellcheck disable=2046,2086
	# pseudo code: set --  implicits explicits
	set -- $deps "$@"
	// debug_filter -- // log '$@' "$(esceval "$@")"
	# Ask for confirmation if extra packages need to be built.
	# equ "$#" "$explicit_count" ||
	# { // war 'targets' "$(echo "$*" | tr ' ' "$newline")"; // prompt; }
	equ "$#" "$explicit_count" ||
	[ -z "${TREE_FORCE+x}" ] || {
		local content="$(// delegate -- prompt \
				"\$explicit_count = $explicit_count <= \$# = $#${newline}\
				looks good, right?")"
		# // prompt "content" "(\$explicit_count == $explicit_count) != (\$# == $#)"

		! expr "$content" : '[n|N]\+' > /dev/null || return 0
	}

	// log "checking for pre-built dependencies"

	# Percent of packages in "$@"
	# explicit             deps
	# \\\\\\\\\\\\\\\\\\\\ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	# expected_to_be_built_and_only_being_built
	# \\\\\\\\\\\\\\\\\\\\ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	# Install any pre-built dependencies if they exist in the binary
	# directory and are up to date.
	# Intended behavior.
	# shellcheck disable=2030,2031
	for repo_urn do
		local repo_name="${repo_urn##*/}"
		repo_name="${repo_name%%@*}"

		local format="$(// delegate -- pkg_format "$repo_urn")"

		[ ! -z "${TREE_FORCE+x}" ] ||
		[ ! -z "$(// delegate filter_contains "key_filter" "$repo_urn" $explicit)" ] || {

			! is_repos "$KISS_ROOT/$db/$repo_name" || { shift; continue; }

			# local tar_file="$(// delegate -- pkg_cache "$repo_urn")"
			# // war  '$mandatory_explicit_build' "$mandatory_explicit_build"
			# if ! contains "$expected_to_be_built_and_only_being_built" "$repo_urn" &&

			# [ -n "${PREFER_CACHE+x}" ] &&
			# { ! equ "git" "$format" || equ "tag" "$reference_type"; } &&
			# [ -z "$(// delegate filter_contains "key_filter" "$repo_urn" $explicit)" ] &&
			# ok "$tar_file" &&[ -z "${KISS_FORCE+x}" ]; then
			null "$(// delegate -- pkg_cache "$repo_urn")" || {

				// log "$repo_name" "found pre-built binary"

				# Refer to "expl_alter" -- that is to say,
				# remember to remove the current repo_urn from explicit list, please

				# Eg., for repos outside KISS_REPO
				(export KISS_FORCE=; // args i "$repo_urn")
				# If use "$expected_to_be_built_and_only_being_built" as container
				# It might be empty (less than "$explicit")
				# local expl_alter=
				# for item in $explicit; do
				#     equ "$repo_urn" "$item" ||
				#     expl_alter="${expl_alter:+"${expl_alter} "}$item"
				# done
				# explicit="$expl_alter"
				{ shift; continue; }
			}
		}

		local repo_name_plain="$(name_plain "$repo_name")"
		[ -n "$(/ echo \${synchronized_${repo_name_plain}-})" ] ||
		// pkg_download "$repo_urn" || // die '$repo_urn' "'$repo_urn' download failed"

		[ ! -f "$repo_urn/sources" ] ||
		[ "$format" = "git" ] ||
		// checksums_verify "$repo_urn"

		set -- "$@" "$repo_urn"
		shift
	done

	# Merged to upward
	# for repo_urn do
	#   local repo_name="${repo_urn##*/}"

	#   local repo_name_plain="$(echo "$repo_name" | sed 's/-/_/g')"
	#   [ -n "$(/ echo \${synchronized_${repo_name_plain}-})" ] ||
	#   // pkg_download "$repo_urn"

	#   repo_name="${repo_name%%@*}"

	#   is_repos "$repo_urn" ||
	#       repo_urn="$(// delegate -- repo_trace "$repo_name")"

	#   # local format="$(// delegate -- pkg_format "$repo_urn")"

	#   [ ! -f "$repo_urn/sources" ] ||
	#   [ "$format" = "git" ] ||
	#   // checksums_verify "$repo_urn"
	# done

	[ -z ${KISS_ROOT:+x} ] || // log '$KISS_ROOT' "$KISS_ROOT"
	# Building on host (cross build)
	[ -z ${KISS_XBUILD_TRIPLE:+x} ] ||
	// log '$KISS_XBUILD_TRIPLE' "$KISS_XBUILD_TRIPLE"
	# Building for target (cross host)
	[ -z ${KISS_XHOST_TRIPLE:+x} ]  ||
	// log '$KISS_XHOST_TRIPLE' "$KISS_XHOST_TRIPLE"
	// log '$TAR_ROOT' "$TAR_ROOT"
	// log '$BIN_ROOT' "$BIN_ROOT"
	[ -z ${CC:+x} ]      || // log '$CC'       "$CC"
	[ -z ${CXX:+x} ]     || // log '$CXX'      "$CXX"
	[ -z ${CFLAGS+x} ]   || // log '$CFLAGS'   "$CFLAGS"
	[ -z ${CXXFLAGS+x} ] || // log '$CXXFLAGS' "$CXXFLAGS"
	[ -z ${LDFLAGS+x} ]  || // log '$LDFLAGS'  "$LDFLAGS"

	# Finally build and create tarballs for all passed packages and
	# dependencies.
	local _build_cur
	for repo_urn do
		// log '$repo_urn' \
			"building package \"$repo_urn\" ($((_build_cur+=1))/$#)"

		local repo_name="${repo_urn##*/}"
		repo_name="${repo_name%%@*}"
		is_repos "$repo_urn" ||
			repo_urn="$(// delegate -- repo_trace "$repo_name")"
		ok "$repo_urn" || // die '$repo_urn' "$repo_urn"

		# arg1: queue-status
		# arg2: package name
		# arg3: number in queue
		# arg4: total in queue
		// run_hook queue "$repo_name" "$_build_cur" "$#"

		// log '$repo_urn' "$repo_urn [local]"
		[ -d "$repo_urn" ] ||
			// die '$repo_urn' "not found ${repo_urn:+"${repo_urn} "}[local]"
		[ ! -f "$repo_urn/sources" ] || // pkg_load "$repo_urn"

		// log '$db' "$db"
		// log '$PWD' "$PWD"
		// pkg_build "$repo_urn" || ! break
		// pkg_manifest "$repo_urn" "$PKG_ROOT" & // progress "$!" "manifest checking"
		// pkg_strip "$repo_urn"

		cd "$PKG_ROOT/$repo_name/$db/$repo_name"
		// pkg_fix_deps "$repo_urn"
		// pkg_etcsums  "$repo_urn"
		// pkg_tar      "$repo_urn"

		# [ -z "${PREFER_CACHE:+x}" ] &&
		[ ! -z "$(// delegate filter_contains "key_filter" "$repo_urn" $explicit)" ] || {
			// log "$repo_urn" "Needed as a dependency or has an update, installing"

			# Intended behavior.
			# shellcheck disable=2030,2031
			(export KISS_FORCE=""; // args i "$repo_urn")
		}
	done

	[ "$?" -eq "0" ] ||
		# // die 'pkg_build' "failed"
		interrupt

	for item in $explicit; do
		// log 'explicit' "$item"
	done

	# Intentional, globbing disabled.
	# shellcheck disable=2046,2086
	[ -z "${install_on_build:+x}" ] ||
	is_pick "$CROSS_ACTION" || {
		# KISS_PROMPT statement moved to prompt()
		# if [ -n "${KISS_PROMPT+x}" ] && equ "$KISS_PROMPT" 0; then
		#     (export KISS_FORCE=; // args i $explicit)
		# else
		# ! // prompt "content" "Install built packages? [$explicit]" ||
		# // prompt "content" "Install built packages? [$explicit]"
		local content="$(// delegate -- prompt "Install built packages? [$explicit]")"
		expr "$content" : '[n|N]\+' > /dev/null ||
		(export KISS_FORCE=""; // args i $explicit)
		# fi
	}
}

# header_correct
header_cure() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	shift 1
	set --
	local build_file_user="$(// delegate owner "$repo_urn/build")"
	// log '$LOGNAME' "$LOGNAME"
	// log '$build_file_user' "$build_file_user"
	[ "$LOGNAME" = "$build_file_user" ] ||
	set -- $(// delegate as_user "$build_file_user")
	// debug_filter -- // log '$@' "$(esceval "$@")"
	#
	# The "ENV" version needs build script header to be "#! /bin/sh -i"
	# Modify headers to "fail on error" and interactive mode

	// is_writable "$repo_urn" || return 0

	local expect_option_shebang="-e"
	[ -z "${USE_ENV+x}" ] || expect_option_shebang="-i"

	local found_plus_e=0
	local found_minus_e=0
	local found_expect_option_shebang=0

	local first_line
	first_line="$(sed "1q" "$repo_urn/build")"

	local cmd option_shebang
	cmd="$(printf %s "$first_line" |
	tr -d "#!" |
	awk "{print \$1}" | tr -d " ")"
	// log '$cmd' "$cmd"
	option_shebang="${first_line##* }" || // die '$first_line' "$first_line"
	// log '$option_shebang' "$option_shebang"
	[ -n "${first_line:+x}" ] &&
	[ -z "${first_line##*sh*}" ] &&
	command -v "$cmd" > /dev/null 2>&1 &&
	[ "$option_shebang" = "$expect_option_shebang" ] || {
		// war '$first_line' "'$first_line' looks not correct"
		case "$first_line" in
			*"/bin/sh"*|*"ash"*|*"sh"*|*"/env"*|*"/usr"*|*"/bin"*|*"/proc"*|*"/exe"*)
				# Redirection will not repect the current user's ownership
				"$@" sed -i -e "s|$first_line|#! /bin/sh $expect_option_shebang|g" "$repo_urn/build"
				# "$@" sed -e "s|$first_line|#! /bin/sh $expect_option_shebang|g" < "$repo_urn/build" > _
				# "$@" mv -f _ "$repo_urn/build"
				: $((found_expect_option_shebang += 1))
				;;
			*)
				# https://unix.stackexchange.com/questions/99350/how-to-insert-text-before-the-first-line-of-a-file
				"$@" sed -i "1 {i\\n#! /bin/sh -$expect_option_shebang}" "$repo_urn/build"
				# "$@" sed "1 {i\\n#! /bin/sh -$expect_option_shebang}" < "$repo_urn/build" > _
				# "$@" mv -f _ "$repo_urn/build"
				: $((found_expect_option_shebang += 1))
				;;
		esac
	}

	first_line="$(sed "1q" "$repo_urn/build")"
	// log '$first_line' "$first_line"
	option_shebang="${first_line##* }" || // die '$first_line' "$first_line"
	// log '$option_shebang' "$option_shebang"

	[ "$option_shebang" = "-e" ] && found_minus_e=1
	#
	local ifs="$IFS"
	local IFS="$newline"
	# Remove duplicated shebangs
	local index=0
	local option_line_number
	for option_line_number in $( \
		grep -En "#! /bin/sh $expect_option_shebang" "$repo_urn/build" |
		awk -F ":" "{print \$1}"
	); do
		: $((index += 1))
		[ "$index" -le "1" ] ||
		"$@" sed -i -e "${option_line_number}d" "$repo_urn/build"
	done

	local option_line
	local index=0
	# while read -r option_line || [ -n "${option_line:+x}" ]; do
	for option_line in $(grep -E "set\ \+*" "$repo_urn/build" | grep -v "#"); do
		: $((index += 1))
		// log '$index : $option_line' "$index : $option_line"
		case "$option_line" in
			*"--"*) ;;
			*"+e")
				: $((found_plus_e += 1))
				[ "$expect_option_shebang" = "-e" ] &&
				"$@" sed -i -e "/$option_line/d" "$repo_urn/build"
				# Rplace it
				[ "$expect_option_shebang" = "-i" ] && {
					"$@" sed -i -e "s|$option_line|set -e|g" "$repo_urn/build"
					: $((found_minus_e += 1))
				}
				# "$@" sed -e "s|$option_line|set -e|g" < "$repo_urn/build" > _
				# [ "$(wc -l _ | awk "{print \$1}")" -le "1" ] &&
				# // die 'file' "'$repo_urn/build' cleared by wrong operation" ||
				# "$@" mv -f _ "$repo_urn/build"
				;;
			*"+"*"e"*)
				: $((found_plus_e += 1))
				# Append new set -e
#                         sed -e "/$option_line/s/.*/&\\
# set -e/" < "$repo_urn/build" > _
				# sed -e "/$option_line/s/.*/&\\nset -e/" < "$repo_urn/build" > _
				# : $((found_minus_e += 1))
				# Pick it out
				local option
				option="${option_line##* }" || // die '$option_line' "$option_line"
				option="$(echo "$option" | tr -d "e")"
				"$@" sed -i -e "s|$option_line|set $option|g" "$repo_urn/build"
				# "$@" sed -e "s|$option_line|set $option|g" < "$repo_urn/build" > _
				# [ "$(wc -l _ | awk "{print \$1}")" -le "1" ] &&
				# // die 'file' "'$repo_urn/build' cleared by wrong operation" ||
				# "$@" mv -f _ "$repo_urn/build"
				;;
			*"-e")
				: $((found_minus_e += 1))
				[ "$found_minus_e" -le "1" ] || {
					# Remove it
					"$@" sed -i -e "/$option_line/d" "$repo_urn/build"
					# "$@" sed "/$option_line/d" < "$repo_urn/build" > _
					# [ "$(wc -l _ | awk "{print \$1}")" -le "1" ] &&
					# // die 'file' "'$repo_urn/build' cleared by wrong operation" ||
					# "$@" mv -f _ "$repo_urn/build"
					: $((found_minus_e -= 1))
				}
				;;
			*"-"*"e"*)
				: $((found_minus_e += 1))
				[ "$found_minus_e" -le "1" ] || {
					# Pick it out
					local option
					option="${option_line##* }" || // die '$option_line' "$option_line"
					option="$(echo "$option" | tr -d "e")"
					"$@" sed -i -e "s|$option_line|set $option|g" "$repo_urn/build"
					# "$@" sed -e "s|$option_line|set $option|g" < "$repo_urn/build" > _
					# [ "$(wc -l _ | awk "{print \$1}")" -le "1" ] &&
					# // die 'file' "'$repo_urn/build' cleared by wrong operation" ||
					# "$@" mv -f _ "$repo_urn/build"
					: $((found_minus_e -= 1))
				}
		esac
	done
	# done < <(printf '%s\n' "$(grep -E "set\ \+*" "$repo_urn/build" | grep -v "#")")
#   done << EOF
# $(grep -E "set\ \+*" "$repo_urn/build" | grep -v "#")
# EOF
# https://stackoverflow.com/questions/58619925/grep-words-with-spaces
# $(grep -E 'set +*' "$repo_urn/build" | grep -v "#")
# $(sed "2q" "$repo_urn/build")
#
	local IFS="$ifs"
	# Too simplistic
	# grep "set *" "$repo_urn/build" | awk "{print \$2}" | grep -v "#" | grep "-" | grep -q "e" || {
	#     sed -e "s|set -.*|set -e|g" < "$repo_urn/build" > _
	#     [ "$(wc -l _ | awk "{print \$1}")" -le "1" ] &&
	#     // die 'file' "'$repo_urn/build' cleared by wrong operation" ||
	#     mv -f _ "$repo_urn/build"
	# }
	#
	# If USE_ENV, then mkae sure "set -e" must exist
	// log '$found_minus_e' "$found_minus_e"
	[ -z "${USE_ENV+x}" ] ||
	[ "$found_minus_e" -gt "0" ] || {
		# https://stackoverflow.com/questions/15559359/insert-line-after-match-using-sed
		# https://stackoverflow.com/questions/16202900/using-sed-between-specific-lines-only#
		"$@" sed -i -e '1,1 {/#! \/bin\/sh -i/s/.*/&\nset -e/}' "$repo_urn/build"
		# "$@" sed '1,1 {/#! \/bin\/sh -i/s/.*/&\nset -e/}' < "$repo_urn/build" > _
		# [ "$(wc -l _ | awk "{print \$1}")" -le "1" ] &&
		# // die 'file' "'$repo_urn/build' cleared by wrong operation" ||
		# "$@" mv -f _ "$repo_urn/build"
	}
}

# could be subshell function before local version
# $1 repo_urn : package repo url/uri
pkg_build() {
	_level_2
	local action="build"
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
		repo_urn="$(// delegate -- repo_trace "$repo_name")"
	ok "$repo_urn" || // die '$repo_urn' "$repo_urn"
	# Install built packages to a directory under the package name to
	# avoid collisions with other packages.

	local repo_dir= repo_ver= repo_rel= repo_alias= repo_url= reference_type=

	! // || / `pkg_version "$repo_urn" |
		awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
	END { print "repo_dir=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"; \
	repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
	printf '%s\n' "return 1"`

	local pkg_dir="$PKG_ROOT/$repo_name"
	local pkg_db_dir="$pkg_dir/$db"
	local make_dir="$MAKE_ROOT/$repo_name"
	local output_dir="$OBJ_ROOT/$repo_name"

	// log '$PKG_ROOT'   "$PKG_ROOT"
	// log '$TAR_ROOT'   "$TAR_ROOT"
	// log '$OBJ_ROOT'   "$OBJ_ROOT"
	// log '$BIN_ROOT'   "$BIN_ROOT"
	// log '$log_dir'    "$log_dir"
	// log '$pkg_dir'    "$pkg_dir"
	// log '$make_dir'   "$make_dir"
	// log '$output_dir' "$output_dir"
	// log '$repo_urn'   "$repo_urn [local]"
	// log '$repo_name'  "$repo_name"
	// log '$repo_ver'   "$repo_ver"
	// log '$db'         "$db"
	// log '$LOGNAME'    "$LOGNAME"
	// log '$pkg_db_dir/$repo_name' "$pkg_db_dir/$repo_name"

	ownership "$PKG_ROOT" "$pkg_dir"

	empty "$pkg_dir" ||
	for item in $(// as_own "$PKG_ROOT" find "$pkg_dir" -mindepth 1 -maxdepth 1); do
		// as_own "$pkg_dir" \rm -rf "$item"; done

	// mkcd "$make_dir" "$pkg_db_dir/$repo_name" "$output_dir" ||
		// die 'mkcd' "failed"

	// cue "$repo_name" "starting build"

	[ -n "${REPO_DIR:+x}" ] || ! is_repos "$repo_urn" ||
	REPO_DIR="${repo_urn%/*}"
	export REPO_DIR
	// log '$REPO_DIR' "$REPO_DIR"
	# For huge packages, you do not want to initialize it on each modification
	ln -sf "$repo_urn/build" "$make_dir/"

	# arg1: pre-build
	# arg2: package name
	# arg3: path to build directory
	// run_hook     pre-build "$repo_name" "$make_dir"
	// run_hook_pkg pre-build "$repo_name" "$repo_ver" "$repo_rel" "$repo_dir"

	# Attempt to create the log file early so any permissions errors are caught
	# before the build starts. 'tee' is run in a pipe and POSIX shell has no
	# pipe-fail causing confusing behavior when tee fails.
	# Log has been created when script booted
	# : > "$user_output"

	[ -z "${USE_GMAKE+x}" ] || {
		// log "GNU make used"
		[ "$(readlink -f "$BIN_ROOT/$repo_name/gunzip")" = "/usr/bin/pigz"  ] ||
			// as_usr "$SRC_USER" \
				/usr/bin/ln -sf "/usr/bin/pigz" "$BIN_ROOT/$repo_name/gunzip"
		[ "$(readlink -f "$BIN_ROOT/$repo_name/make")"   = "/usr/bin/gmake" ] ||
			// as_usr "$SRC_USER" \
				/usr/bin/ln -sf "/usr/bin/gmake" "$BIN_ROOT/$repo_name/make"
		export PATH="$BIN_ROOT/$repo_name:$PATH"
	}

	local build_state=0
	printf '%s\n' "0" > "$KISS_TMPDIR/logs/build_state"

	# Call the build script, log the output to the terminal and to a file.
	# There's no PIPEFAIL in POSIX shell so we must resort to tricks like kill.
	# Will shield "set -e"
	# {

	// header_cure "$repo_urn"
	# // trap_on "$action" "$repo_name"
	// log '$LOGNAME' "$LOGNAME"
	# // log '$LOGNAME' "$LOGNAME"
	// log '$_KISS_LVL' "$_KISS_LVL [before into \"$action\" subshell]"
	// log '$PWD' "$PWD"
	# Give the script a modified environment. Define toolchain program
	# environment variables assuming a generic environment by default.

	# COLOR_PARENT="$COLOR_PARENT" \
	# COLOR_CHILD="$COLOR_CHILD" \
	# COLOR_END="$COLOR_END" \
	# COLOR_LINE="$COLOR_LINE" \
	# KISS_COMPRESS="$KISS_COMPRESS" \
	# cmd_su="$cmd_su" \
	# cmd_elf="$cmd_elf" \
	# cmd_sha="$cmd_sha" \
	# cmd_get="$cmd_get" \
	# KISS_TMPDIR="$KISS_TMPDIR" \
	# PID_LOG="$PID_LOG" \
	# PID_SAY="$PID_SAY" \

	# [ -z "${KISS_INNER_PIPE:+x}" ] || {
	# PID_SAY="$PID_SAY" \
	# PID_LOG="$PID_LOG" \
	# }
	# Define DESTDIR and GOPATH to sane defaults as their use is mandatory
	# in anything using autotools, meson, cmake, etc. Define KISS_ROOT as
	# the sanitized value used internally by the package manager. This is
	# safe to join with other paths.
	#
	# KISS_PATH=\"$KISS_PATH\" \
	# _KISS_LVL=\"$((_KISS_LVL + 1))\" \
	# SESSION_PPID=\"$SESSION_PPID\" \
	# USER_OUTPUT=\"$USER_OUTPUT\" \
	# SHELL_OPTIONS=\"e$(printf '%s' "$-")\" \
	#
	# Most of this is useless for source mode running of build script
	local env_variables=
	# local env_variables=" AR=\"${AR:-ar}\" "
	# env_variables="$env_variables CC=\"${CC:-cc}\" "
	# env_variables="$env_variables CXX=\"${CXX:-c++}\" "
	# env_variables="$env_variables CFLAGS=\"${CFLAGS:-" -O3 -pipe -fPIC "}\" "
	# env_variables="$env_variables CXXFLAGS=\"${CXXFLAGS:-" -O3 -pipe -fPIC "}\" "
	# env_variables="$env_variables LDFLAGS=\"${LDFLAGS-}\" "
	# env_variables="$env_variables NM=\"${NM:-nm}\" "
	# env_variables="$env_variables RANLIB=\"${RANLIB:-ranlib}\" "
	# env_variables="$env_variables DEST_ROOT=\"$DEST_ROOT\" "
	# env_variables="$env_variables RUSTFLAGS=\"--remap-path-prefix=$PWD=. -Clinker=rust-lld ${RUSTFLAGS-}\" "
	# env_variables="$env_variables GOFLAGS=\"-trimpath -modcacherw ${GOFLAGS-}\" "
	# env_variables="$env_variables GOPATH=\"${GOPATH:-"$PWD/go"}\" "
	# env_variables="$env_variables PATH=\"${GOPATH:-"$PWD/go"}/bin:$PATH\" "
	# env_variables="$env_variables KISS_ROOT=\"$KISS_ROOT\" "
	# env_variables="$env_variables KISS_REPO=\"$KISS_REPO\" "
	# env_variables="$env_variables KISS_XHOST_ARCH=\"$KISS_XHOST_ARCH\" "
	# env_variables="$env_variables KISS_XBUILD_ARCH=\"$KISS_XHOST_ARCH\" "
	# env_variables="$env_variables CHOST=\"$KISS_XHOST_TRIPLE\" "
	# env_variables="$env_variables CBUILD=\"$KISS_XBUILD_TRIPLE\" "
	# env_variables="$env_variables KISS_XHOST_ABI=\"$KISS_XHOST_ABI\" "
	# env_variables="$env_variables KISS_XBUILD_ABI=\"$KISS_XBUILD_ABI\" "
	# env_variables="$env_variables KISS_XHOST_TRIPLE=\"$KISS_XHOST_ARCH-linux-$KISS_XHOST_ABI\" "
	# env_variables="$env_variables KISS_XBUILD_TRIPLE=\"$KISS_XBUILD_ARCH-linux-$KISS_XBUILD_ABI\" "
	# env_variables="$env_variables SESSION_PID=\"$SESSION_PID\" "
	# env_variables="$env_variables KISS_PID=\"$KISS_PID\" "
	env_variables="$env_variables CROSS_ACTION=\"${CROSS_ACTION:-"$action"}\" "
	environment "CROSS_ACTION" "${CROSS_ACTION:-"$action"}"
	# env_variables="$env_variables SHELL_OPTIONS=\"$SHELL_OPTIONS\" "
	# env_variables="$env_variables REPO_BASE=\"$REPO_BASE\" "
	env_variables="$env_variables REPO_DIR=\"$REPO_DIR\" "
	environment "REPO_DIR" "$REPO_DIR"
	# env_variables="$env_variables SRC_ROOT=\"$SRC_ROOT\" "
	# env_variables="$env_variables MAKE_ROOT=\"$MAKE_ROOT\" "
	# env_variables="$env_variables OBJ_ROOT=\"$OBJ_ROOT\" "
	env_variables="$env_variables DESTDIR=\"$PKG_ROOT/$repo_name\" "
	environment "DESTDIR" "$PKG_ROOT/$repo_name"
	# env_variables="$env_variables XBPS_CROSS_BASE=\"$KISS_ROOT\" "

	env_variables="$env_variables MAKE_DIR=\"$make_dir\" "
	environment "MAKE_DIR" "$make_dir"

	env_variables="$env_variables OUTPUT_DIR=\"$output_dir\" "
	environment "OUTPUT_DIR" "$output_dir"

	env_variables="$env_variables CCACHE_DIR=\"$CCACHE_ROOT/$repo_name\" "
	environment "CCACHE_DIR" "$CCACHE_ROOT/$repo_name"

	env_variables="$env_variables CCACHE_CONFIGPATH=\"$CCACHE_ROOT/$repo_name\" "
	environment "CCACHE_CONFIGPATH" "$CCACHE_ROOT/$repo_name"

	local go_depends=1
	[ ! -f "$repo_urn/depends" ] ||
	for item in $(cat "$repo_urn/depends" | awk '$2 != "" {print $2}'); do
		[ "$item" != "go" ] || { go_depends=0; break; }
	done
	[ "$repo_name" != "go" ] &&
	[ "$go_depends" -eq "1" ] || {
		local ifs="$IFS"
		local IFS="$newline"
		for item in $(go env); do
			env_variables="$env_variables $(printf '%s' "$item") "
				# $(printf '%s' "$item" | awk 'gsub(/"/, "\\\"") {print $0}') \
		done
		IFS="$ifs"
	}
	[ -z "${DEBUG_AT_BACKGROUND+x}" ] ||
		env_variables="$env_variables DEBUG_AT_BACKGROUND=\"$DEBUG_AT_BACKGROUND\" "
	local result
	# run_series \
	set +f
	# [ -z "${USE_ENV+x}" ] && {
		# The non "ENV" version does not need build script header to be "#! /bin/sh -i"
		# Pay attention to name conflictions with the current environment
		// log 'sourcing' "/usr/include/kiss/abuild"
		# shellcheck source=/usr/include/kiss/abuild

		. "/usr/include/kiss/abuild" "$PKG_ROOT/$repo_name" "$repo_ver" 2>&1
		# // log 'sourcing' "/usr/include/kiss/vbuild"
		#
		# vbuild is not POSIX
		# shellcheck source=/usr/include/kiss/vbuild
		# . "/usr/include/kiss/vbuild" "$PKG_ROOT/$repo_name" "$repo_ver" 2>&1
		#
		// log 'sourcing' "$repo_urn/build"

		# This step is useless for source mode running of build script
		# // log '$env_variables' "$env_variables"

		// log '$ENV_VARIABLES' "$ENV_VARIABLES"

		# // log '$env_variables' "$(/ "printf '%s\n' \"$env_variables\"")"
		# // log '$env_variables' "$( \
		#   local ifs="$IFS"
		#   local IFS=$newline
		#   / "IFS=$newline printf '%s\n' \"$env_variables\""
		#   IFS="$ifs"
		# )"
		#
		# Won't interpret $newline
		# // log '$env_variables' "$(/ 'printf "%s\n" "$env_variables"')"
		#
		# export $env_variables || // die '$env_variables' "$env_variables"
		#
		# export    AR="${AR:-ar}"
		# export    CC="${CC:-cc}"
		# export    CXX="${CXX:-c++}"
		# export    CFLAGS="${CFLAGS:-" -O3 -pipe -fPIC "}"
		# export    CXXFLAGS="${CXXFLAGS:-" -O3 -pipe -fPIC "}"
		# export    NM="${NM:-nm}"
		# export    RANLIB="${RANLIB:-ranlib}"
		# export    DEST_ROOT="$DEST_ROOT"
		# export    RUSTFLAGS="--remap-path-prefix=$PWD=. -Clinker=rust-lld ${RUSTFLAGS-}"
		# export    GOFLAGS="-trimpath -modcacherw ${GOFLAGS-}"
		# export    GOPATH="${GOPATH:-"$PWD/go"}"
		# export    PATH="${GOPATH:-"$PWD/go"}/bin:$PATH"
		# export    KISS_ROOT="$KISS_ROOT"
		# export    KISS_REPO="$KISS_REPO"
		# export    KISS_XHOST_ARCH="$KISS_XHOST_ARCH"
		# export    KISS_XBUILD_ARCH="$KISS_XHOST_ARCH"
		# export    CHOST="$KISS_XHOST_TRIPLE"
		# export    CBUILD="$KISS_XBUILD_TRIPLE"
		# export    KISS_XHOST_ABI="$KISS_XHOST_ABI"
		# export    KISS_XBUILD_ABI="$KISS_XBUILD_ABI"
		# export    KISS_XHOST_TRIPLE="$KISS_XHOST_ARCH-linux-$KISS_XHOST_ABI"
		# export    KISS_XBUILD_TRIPLE="$KISS_XBUILD_ARCH-linux-$KISS_XBUILD_ABI"
		# export    SESSION_PID="$SESSION_PID"
		# export    KISS_PID="$KISS_PID"
		# export    CROSS_ACTION="${CROSS_ACTION:-"$action"}"
		# export    SHELL_OPTIONS="$SHELL_OPTIONS"
		# export    REPO_BASE="$REPO_BASE"
		# export    REPO_DIR="$REPO_DIR"
		# export    SRC_ROOT="$SRC_ROOT"
		# export    MAKE_ROOT="$MAKE_ROOT"
		# export    DESTDIR="$PKG_ROOT/$repo_name"
		# . "$repo_urn/build" "$PKG_ROOT/$repo_name" "$repo_ver" 2>&1 ||

		# Double quotes won't stop on build failure when $env_variables
		# has or has not $newline
		# / "$env_variables \

		! // || / "$ENV_VARIABLES $env_variables . \"$repo_urn/build\" \"$pkg_dir\" \"$repo_ver\" 2>&1" ||

		# Same as above
		# / "$( \
		#   printf '%s' "$env_variables"
		# ) \
		# . \"$repo_urn/build\" \"$PKG_ROOT/$repo_name\" \"$repo_ver\" 2>&1" ||

		#
		# This version works
		# AR="${AR:-ar}" \
		#   CC="${CC:-cc}" \
		#   CXX="${CXX:-c++}" \
		#   CFLAGS="${CFLAGS:-" -O3 -pipe -fPIC "}" \
		#   CXXFLAGS="${CXXFLAGS:-" -O3 -pipe -fPIC "}" \
		#   NM="${NM:-nm}" \
		#   RANLIB="${RANLIB:-ranlib}" \
		#   DEST_ROOT="$DEST_ROOT" \
		#   RUSTFLAGS="--remap-path-prefix=$PWD=. -Clinker=rust-lld ${RUSTFLAGS-}" \
		#   GOFLAGS="-trimpath -modcacherw ${GOFLAGS-}" \
		#   GOPATH="${GOPATH:-"$PWD/go"}" \
		#   PATH="${GOPATH:-"$PWD/go"}/bin:$PATH" \
		#   KISS_ROOT="$KISS_ROOT" \
		#   KISS_REPO="$KISS_REPO" \
		#   KISS_XHOST_ARCH="$KISS_XHOST_ARCH" \
		#   KISS_XBUILD_ARCH="$KISS_XHOST_ARCH" \
		#   CHOST="$KISS_XHOST_TRIPLE" \
		#   CBUILD="$KISS_XBUILD_TRIPLE" \
		#   KISS_XHOST_ABI="$KISS_XHOST_ABI" \
		#   KISS_XBUILD_ABI="$KISS_XBUILD_ABI" \
		#   KISS_XHOST_TRIPLE="$KISS_XHOST_ARCH-linux-$KISS_XHOST_ABI" \
		#   KISS_XBUILD_TRIPLE="$KISS_XBUILD_ARCH-linux-$KISS_XBUILD_ABI" \
		#   SESSION_PID="$SESSION_PID" \
		#   KISS_PID="$KISS_PID" \
		#   CROSS_ACTION="${CROSS_ACTION:-"$action"}" \
		#   SHELL_OPTIONS="$SHELL_OPTIONS" \
		#   REPO_BASE="$REPO_BASE" \
		#   REPO_DIR="$REPO_DIR" \
		#   SRC_ROOT="$SRC_ROOT" \
		#   MAKE_ROOT="$MAKE_ROOT" \
		#   DESTDIR="$PKG_ROOT/$repo_name" \
		#   . "$repo_urn/build" "$PKG_ROOT/$repo_name" "$repo_ver" 2>&1 ||
	#   result=$?
	# } || {
	#   # Experimental design. Incomplete
	#   # The "ENV" version works but can not make use of current environment
	#   # Positional parameters processed in kiss/abuild should be moved into $env_variables
	#   / "env $env_variables \
	#       PKG_DIR=\"$PKG_ROOT/$repo_name\" PKG_VER=\"$repo_ver\" \
	#       sh -i -c 'ENV=/usr/include/kiss/abuild \
	#       \"$repo_urn/build\"' "$PKG_ROOT/$repo_name" "$repo_ver" 2>&1"
	#   result=$?
	# }

	# [ "$result" -eq "0" ] ||
	{

		# tee will mask build errrors, and run_series needs tweaks
		#     "$repo_urn/build" "$PKG_ROOT/$repo_name" "$repo_ver" 2>&1 \| \
		#     tee -a "$USER_OUTPUT"
		# { "$pipestatus_1" && "$pipestatus_2"; } || {

		printf '%s\n' "1" > "$KISS_TMPDIR/logs/build_state"

		// war "$repo_name" "build failed"
		# At this stage the package manager just writes to the "$PKG_ROOT/$repo_name"
		# directory, and does not need to write anythind to the system directory,
		# so the system is clean (do not directly escalate to system administrator
		# privileges in the build script).
		// log "$repo_name" "Don't worry, the system itself is clean so far."
		# ${newline}Unless you are using sysadmin privileges inappropriately at this stage"
		// log "$find_tip" "$user_output"

		[ -z "${KISS_INNER_PIPE:+x}" ] || {
			# [ -z "${USE_SAY_PIPE+x}" ] ||
			clear_outer "PID_SAY"
			clear_outer "PID_LOG"
		}

		# // kill_pipe 'PID_SAY' "$PID_SAY"
		# // kill_pipe 'PID_LOG' "$PID_LOG"

		# # kill 0 ||
		# // kill_subtree "$KISS_PID"
		# Won't kill upper processes
		# // die "$repo_name" "quit current build process"
		[ -z "${KISS_INNER_PIPE:+x}" ] || {
			# [ -z "${USE_SAY_PIPE+x}" ] ||
			pipe_cancel "PID_SAY"
			pipe_cancel "PID_LOG"
		}

		# arg1: build-fail
		# arg2: package name
		# arg3: path to build directory
		(// run_hook build-fail "$repo_name" "$make_dir")

		# ! pid_alive "$SESSION_PID" || kill -USR1 "$SESSION_PID"
		#
		# ! pid_alive "$SESSION_PID" || // as_usr "root" kill -KILL -"$SESSION_PID"
		#
		# kill_tree "$$"
		# kill_tree "$SESSION_PPID"
		interrupt
		# kill 0
		# export KISS_DEBUG=
		# exit
	}   # | tee -a "$USER_OUTPUT"

	# // trap_off

	# build_state="$(cat "$KISS_TMPDIR/logs/build_state")"
	# equ "$build_state" 0 || {
	#     // war '$build_state' "$build_state"
	#     // war '$SESSION_PID' "$SESSION_PID"
	#     # kill_tree "$SESSION_PPID"
	#     interrupt
	#     # return "$build_state"
	#     # kill_name "$CROSS_ACTION" "$repo_urn"
	# }

	# } | tee -a "$USER_OUTPUT"

	build_state="$(cat "$KISS_TMPDIR/logs/build_state")"
	equ "$build_state" 0 || {
		// war '$build_state' "$build_state"
		// war '$SESSION_PID' "$SESSION_PID"
		# kill_tree "$SESSION_PPID"
		interrupt
		# kill_name "$CROSS_ACTION" "$repo_name"
		# Will kill the main process
		# kill_tree "$SESSION_PPID"
		# return "$build_state"
	}

	# # Delete the log file if the build succeeded to prevent the directory
	# # from filling very quickly with useless logs.
	# Deprecated. Clear it at the next build
	# equ "$KISS_KEEPLOG" 1 || rm -f "$log_dir/$repo_name/build.log"

	ownership "$PKG_ROOT" "$pkg_dir"

	# Copy the repository files to the package directory.
	# // as_usr "$SRC_USER" /usr/bin/cp -LRf "$repo_urn" "$PKG_ROOT/$repo_name/$db/"
	// as_usr "$SRC_USER" rsync -aqzL "$repo_urn" "$pkg_db_dir/"
	// as_usr "$SRC_USER" sync
	[ -d "$pkg_db_dir/$repo_name" ] ||
	// die '$repo_urn' "$repo_urn copying failed"

	// log "$repo_name" "successfully built"

	# arg1: post-build
	# arg2: package name
	# arg3: path to DESTDIR
	// run_hook_pkg post-build "$repo_name" "$repo_ver" "$repo_rel" "$repo_dir"
	// run_hook     post-build "$repo_name" "$pkg_dir"
}

pkg_checksum() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	local repo_name_plain="$(name_plain "$repo_name")"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
	repo_urn="$(// delegate -- repo_trace "$repo_name")"

	// pkg_dirs "$action" "$repo_name"

	# $SRC_ROOT/$repo_name branch/tag switch should be done also, not only version update
	# [ -n "$(/ echo \${synchronized_${repo_name_plain}-})" ] ||
	// pkg_download "$repo_urn" c

	// log '$repo_urn' "$repo_urn"
	[ -f "$repo_urn/sources" ] || return 0

	local hash="$(// delegate -- "checksum_gen" "$repo_urn")"

	if ok "$hash"; then
		set --
		[ "$LOGNAME" = "$(// delegate -- owner "$repo_urn")" ] ||
			set -- $(delegate -- as_owner "$repo_urn")
		// debug_filter -- // log '$@' "$(esceval "$@")"
		[ -f "$repo_urn/checksums" ] || "$@" touch "$repo_urn/checksums"
		/usr/bin/printf '%s\n' "$hash" |
			// as_own "$repo_urn/checksums" tee -a "$repo_urn/checksums" > /dev/null
		// log "$repo_name" "checksums generated"

	else
		// log "$repo_name" "no sources needing checksums"
	fi
}

# $1 repo_urn : package repo url/uri
checksum_gen() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
		repo_urn="$(// delegate -- repo_trace "$repo_name")"
	// log '$repo_urn' "$repo_urn"
	# Generate checksums for packages.
	#
	# NOTE: repo_ comes from caller.
	while read -r src_url dest || ok "${src_url%%\#*}"; do

		local _local_dir _res_type _res _target_name

		! // || / `local_route "$repo_urn" "$src_url" "$dest" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "_local_dir=\""$1"\"; _res_type=\""$2"\"; _res=\""$3"\"; \
		_target_name=\""$4"\"" }' ||
		printf '%s\n' "return 1"`

		# case ${_res##git+*} in */*[!.])
		case "$_res_type" in
			"git");;
			*) set -- "$@" "$_res"
		esac
	done < "$repo_urn/sources"

	# sh256 "$hash_name" "$@"
	local hash="$(// delegate -- sh256 "$@")"
	printf "$RS%s" "$hash"
}

# $1 repo_urn : package repo url/uri
checksums_verify() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
		repo_urn="$(// delegate -- repo_trace "$repo_name")"

	# Verify all package checksums. This is achieved by generating a new set
	# of checksums and then comparing those with the old set.
	#
	// log "$repo_name" "verifying sources"

	# Generate a new set of checksums to compare against.
	local hash="$(// delegate -- "checksum_gen" "$repo_urn")"
	// log '$hash' "$hash"

	# Intentional, globbing disabled.
	# shellcheck disable=2038,2086
	set -- $hash
	local checksums="$repo_urn/checksums"
	{
		[ -z "${KISS_FORCE+x}" ] && [ ! -z "${BINARY_REPO+x}" ]
	} ||    # [ -s "$checksums" ] &&
	! is_writable "$repo_urn" || {
		// log '$hash' "${hash:+"${hash}"}"
		// as_own "${checksums%/*}" touch "$checksums"
		for hash_item in $@; do
			printf '%s\n' "$hash_item" | // as_own "${checksums%/*}" tee -a "$checksums" > /dev/null ||
			// die 'permission denied' "on writting version to file $checksums"
		done
	}

	# Check that the first column (separated by whitespace) match in both
	# checksum files. If any part of either file differs, mismatch. Abort.
	[ -z "${1:+x}" ] || while read -r check _ || [ -n "${1:+x}" ]; do
		# printf '%s\n%s\n' "- ${check:-missing}" "+ ${1:-no source}"
		// log '$check' "${check:-missing}"
		// log '$hash' "${1:-no source}"
		local hash_item="${1:-"no source"}"
		equ "$hash_item-${check:-null}" "$check-$hash_item" ||
		equ "$hash_item-${check:-null}" "$hash_item-SKIP" ||
		{
			[ -n "${KISS_FORCE+x}" ] || [ -z "${BINARY_REPO+x}" ]
		} || // die "$repo_name" "checksum mismatch"
		shift "$(($# != 0))"
	done < "$checksums"
}

# Both are repos of the same package and not the same folder
# Readonly and heavy operation
# $1 diff source
# $2 diff target
is_model() (
	_level_2
	local a="$1"
	local b="$2"
	local is_mirror="${3-}"
	local result=1

	local start=`date +%s.%N`

	[ -d "$a" ] && is_repos "$a" || {
		// debug '$a' "'$a' is not a repo"
		return $result
	}
	[ -d "$b" ] && is_repos "$b" || {
		// debug '$b' "'$b' is not a repo"
		return $result
	}

	# ! equ "$a" "$b" || // die '$a == $b' \
	#     "Physical '$a' == '$b' is not one of the designed semantics"
	! equ "$a" "$b" || {
		// debug '$a == $b' "'$a' == '$b'"
		return $result
	}

	# local repo_name="${a##*/}"
	# equ "$repo_name" "${b##*/}" || return $result

	# set -- $(// delegate '\n' version_dirs "${a}" 1)
	# set -- "$@" $(// delegate '\n' version_dirs "${b}" 1)
	local exclude_clause=

	exclude_clause="-x \"keys\" -x \"manifest\" -x \"etcsums\" -x \"checksums\""

	[ ! -z "${is_mirror:+x}" ] && {
		diff -bwurB "$a/version" "$b/version" > /dev/null 2>&1 || {
			// debug 'version' "files are different"
			# (
			# local end=`date +%s.%N`
			# local model_time=$(echo "$end - $start" | bc -l)
			# // log '$model_time' "$model_time"
			# ) &
			return $result
		}
	}
	exclude_clause="$exclude_clause -x \"version\""

	# Heavy operation
	# Heterogeneous mixture file structure. Leads to heavy operations, deprecated
	# local item
	# for item in $(// delegate '\n' version_dirs "${a}" 1) $(// delegate '\n' version_dirs "${b}" 1); do
	#   [ ! -z "${item:+x}" ] || continue
	#   ! (list_contains "$item" "$@") || continue
	#   set -- "$item" "$@"
	#   exclude_clause="$exclude_clause -x \"$item*\""
	# done

	diff -bwrB "$a/build" "$b/build" > /dev/null 2>&1 || {
		// debug 'build' "files are different"
		# (
		# local end=`date +%s.%N`
		# local model_time=$(echo "$end - $start" | bc -l)
		# // log '$model_time' "$model_time"
		# ) &
		return $result
	}
	exclude_clause="$exclude_clause -x \"build\""
	[ ! -f "$a/sources" ] || {
		diff -bwrB "$a/sources" "$b/sources" > /dev/null 2>&1 || {
			// debug 'sources' "files are different"
			# (
			# local end=`date +%s.%N`
			# local model_time=$(echo "$end - $start" | bc -l)
			# // log '$model_time' "$model_time"
			# ) &
			return $result
		}
	}
	exclude_clause="$exclude_clause -x \"sources\""
	[ ! -f "$a/depends" ] || {
		diff -bwurB "$a/depends" "$b/depends" > /dev/null 2>&1 || {
			// debug 'depends' "files are different"
			# (
			# local end=`date +%s.%N`
			# local model_time=$(echo "$end - $start" | bc -l)
			# // log '$model_time' "$model_time"
			# ) &
			return $result
		}
		exclude_clause="$exclude_clause -x \"depends\""
	}

	set -- $(as_own "$a" find -L "$a" -mindepth 1 \( -type f -o -type l \) \
		-exec sh -c 'for path do echo \"${path##"$1/"}\"; done' sh "$a" {} + |
		grep -v keys |
		grep -v manifest |
		grep -v checksums
	)
	local file_list_b="$(as_own "$b" find -L "$b" -mindepth 1 \( -type f -o -type l \) \
		-exec sh -c 'for path do echo \"${path##"$1/"}\"; done' sh "$b" {} + |
		grep -v keys |
		grep -v manifest |
		grep -v checksums
	)"

	for item in $file_list_b; do
		(IFS="$newline" && list_contains "$item" "$@") ||
		set -- "$item" "$@"
	done

	local pair_list=
	local pair l r
	for item do
		# [ -f "$a/$item" ] && l="$a/$item" || l="/dev/null"
		# [ -f "$b/$item" ] && r="$a/$item" || r="/dev/null"
		# pair="$l $r"
		# pair_list="${pair_list:+${}${newline}}$pair"
		diff -bwurBqrN "$a/$item" "$b/$item" > /dev/null 2>&1 || {
			// debug '$item' "files are different"
			# (
			# local end=`date +%s.%N`
			# local model_time=$(echo "$end - $start" | bc -l)
			# // log '$model_time' "$model_time"
			# ) &
			return $result
		}
	done
	result=0
	# (
	# local end=`date +%s.%N`
	# local model_time=$(echo "$end - $start" | bc -l)
	# // log '$model_time' "$model_time"
	# ) &
	return $result

	# diff -x might not be supported
	local diff_clause="diff -qrN $exclude_clause \"$a\" \"$b\" 2>&1"
	// debug '$diff_clause' "$diff_clause"

	local differences=

	# Since we just care about the result by using the -x options of diff,
	# we can just ignore what they are? No, performance becaomes very bad !
	# differences="$(/ "diff -qrN $exclude_clause \"$a\" \"$b\" 2>&1")"
	# while IFS=$' ' read -r _ file_a _ file_b _ || [ -e "$file_a" ] || [ -e "$file_b" ]; do
	while IFS= read -r line; do
		[ -n "${line:+x}" ] || continue
		differences="$line"
		break
		local file_name_a="$(printf '%s\n' "$line" | awk "{print \$2}" | tr -d ':')"
		local file_name_b="$(printf '%s\n' "$line" | awk "{print \$4}" | tr -d ':')"
		[ -n "${file_name_a:+x}" ] && [ -z "${file_name_a##*"$repo_name"*}" ] || continue

		# local item
		# for item do
		#   case "$file_name_a" in *"$item"*)
		#       continue
		#   esac
		# done

		# diff errors like this:
		# diff: /var/db/kiss/lm/extra/cmake/patches: No such file or directory
		# [ -n "${line##*"No such file or directory"*}" ] || :

		local base_name="${file_name_a##*/}"
		case "$base_name" in
			# "version"|"keys"|"manifest"|"etcsums"|"checksums"|"depends") ;;
			"version"|"keys"|"manifest"|"etcsums"|"checksums")
			[ -z "${is_mirror:+x}" ] || {
				! equ "$base_name" "version" ||
					# differences="$file_name_a${differences:+"${newline}${differences}"}"
					differences="$base_name${differences:+"${newline}${differences}"}"
					// debug "diff [$base_name]" "'$file_name_a' and${newline}'$file_name_b'"
				}
				;;
			*)
				# differences="$file_name_a${differences:+"${newline}${differences}"}"
				differences="$base_name${differences:+"${newline}${differences}"}"
				// debug "diff [$base_name]" "'$file_name_a' and${newline}'$file_name_b'"
		esac

	done < <(eval "$diff_clause") 2>/dev/null || {
		// war 'whaaat?' "diff failed"
		// die 'diff' "failed"
	}
	# EOF indentation must be "tab"
	# done <<- EOF || { // war 'whaaat?' "diff failed"; // die 'diff' "failed"; }
	#   $(/ "diff -qrN $exclude_clause \"$a\" \"$b\" 2>&1")
	# EOF

	ok "$differences" && {
		// debug_filter -- // debug '$differences' "$(esceval $differences)"
	} || result=0
	# // war '$differences' "$(esceval $differences)"
	# // war '$result' "$result"

	return $result
)

# Repo is in writable location
# -- won't overwrite upstream repos
# -- won't overwrite system readonly info
# It's safe to overwrite the repos if it is maintained by yourself
is_writable() {
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"

	local result=1

	[ -n "${repo_urn:+x}" ] || return "$result"

	[ -z "${repo_urn##*"$db"*}" ] ||
		[ -n "${repo_urn##*"${KISS_REPO}"*}" ] ||
		[ -z "${repo_urn##*"modules"*}" ] ||
		result=0

	// log '$result' "$result"

	return "$result"
}

# Readonly functiion
# Neither in install target $KISS_ROOT/$db nor in $REPO_DIR
# Repo is in $KISS_REPO
# -- just because $KISS_PATH is defined only contains $KISS_REPO
is_in_main() (
	_level_2
	local repo_urn="$1"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	local result=1
	# Without this local definition,
	# repo_in_main in caller/parent functions might be modified.
	# So I made the fuction readonly
	local repo_in_main
	# // war '$kiss_path_repo_list_origin' "$kiss_path_repo_list_origin"
	for repo_in_main in $( \
			// delegate '\n' repo_trace "$repo_name" "pure" "-d" "$KISS_PATH"); do
		// debug '$repo_in_main' \
			"${repo_in_main:+"${repo_in_main} "}inside pure repo_trace"
		[ "$(readlink -fn "$repo_urn")" = "$(readlink -fn "$repo_in_main")" ] || continue
		result=0
		break
	done
	return $result
)

filter_less() {
	local _left_is_less_name="$1"
	shift 1
	local number_l="$1" number_r="$2"
	# local concluded_left_is_less=
	# Reset the value is very important since this ia an un-isolated process
	_left_is_less=

	[ -z "${number_l:+x}" ] || [ -z "${number_r:+x}" ] ||
	! is_integer "$number_l" || ! is_integer "$number_r" || {
		# 3.x.x.x              4.x.x.x
		# [ "$major_l" -lt "$major_r" ] && { _left_is_less=0; return $_left_is_less; }
		#
		# 5.x.x.x              4.x.x.x
		# 4.x.x.x              4.x.x.x
		#                                          3.x.x.x              4.x.x.x
		# 0                    9
		[ "$number_l" -ge "$number_r" ] || {
			# Will cover series conclusion if filter_less calling is not isolated
			# Yes, finally it must be done
			# _left_is_less=0
			[ "$number_l" -lt "$number_r" ] || // die '$number_l < $number_r' "'$number_l < $number_r' what!!!"
			# concluded_left_is_less=0
			# For performance, bypass delegate
			_left_is_less=0
			# printf "$RS%s" "$concluded_left_is_less"
			return 0
			# return $_left_is_less
		}
		# 5.x.x.x              4.x.x.x
		# [ "$major_l" -gt "$major_r" ] && return $_left_is_less
		#
		# 4.x.x.x              4.x.x.x             5.x.x.x              4.x.x.x
		# If you don't retrun from above statement, then you will infront of the following 0 > 9
		# 0                    9
		[ "$number_l" -eq "$number_r" ] || {
			[ "$number_l" -gt "$number_r" ] || // die '$number_l > $number_r' "'$number_l > $number_r' what!!!"
			# concluded_left_is_less=1
			# For performance, bypass delegate
			_left_is_less=1
			# printf "$RS%s" "$concluded_left_is_less"
			return 0
			# return $_left_is_less
		}
	}
	# // debug '$concluded_left_is_less' "$number_l < $number_r <=> '$concluded_left_is_less'"
	# You can not return 2 as a signal of "not sure" -- it will quit left_is_less()
	# and non-zero return value means left is not less
	#
	# printf "$RS%s" "$concluded_left_is_less"
	/ "$_left_is_less_name=\"$_left_is_less\""
}

# A three-stte problem that can not be simplified
# For performance, no 'printf "$RS%s"' used
left_is_less() {
	_level_2
	local repo_name="$1"
	shift 1

	# local _left_is_less_name="$1"
	# shift 1

	local ver_rel_l="$1" ver_rel_r="$2"

	// debug_filter -- // debug '$ver_rel_l' "$ver_rel_l"
	// debug_filter -- // debug '$ver_rel_r' "$ver_rel_r"
	shift 2

	local repo_dir_left= repo_dir_right= repo_left= repo_right=
	[ "$#" -eq "0" ] || {
		local repo_dir_left="$1"
		# local repo_dir_left="$(standardize "$1")"
		local repo_dir_right="$2"
		# local repo_dir_right="$(standardize "$2")"
		[ ${repo_dir_left##*/} = "$repo_name" ] &&
		local repo_left="$repo_dir_left" ||
		local repo_left="$repo_dir_left/$repo_name"
		# [ ! -z "${repo_left:+x}" ] && is_repos "$repo_left" ||
		#   // die '$repo_left' "'$repo_left' does not exist"
		[ ${repo_dir_right##*/} = "$repo_name" ] &&
		local repo_right="$repo_dir_right" ||
		local repo_right="$repo_dir_right/$repo_name"
		# [ ! -z "${repo_right:+x}" ] && is_repos "$repo_right" ||
		#   // die '$repo_right' "'$repo_right' does not exist"
	}

	local _left_is_less=

	# local start=`date +%s.%N`

	local ver_l= rel_l=

	# IFS=.+-_ read -r major_l minor_l patch_l ident_l \
	#     < <(printf '%s\n' "$ver_l") > /dev/null || // die "printf '%s\\n' \"$ver_l\"" "failed"

	# local end=`date +%s.%N`
	# local is_version_time=$(echo "$end - $start" | bc -l)
	# // log '$is_version_time' "$is_version_time"

	# local start=`date +%s.%N`

	local major_l= minor_l= patch_l= ident_l= suffix_l=
	# ver_split major_l minor_l patch_l ident_l suffix_l "$ver_l"
	local ver_rel_left=
	local repo_urn_plain_l=
	[ -z "${repo_left:+x}" ] || {
		repo_urn_plain_l="$(name_plain "$repo_left")"
		/ "ver_rel_left=\"\${pkg_${repo_urn_plain_l}_version}\""
	}
	[ ! -z "${ver_rel_left:+x}" ] &&
	[ "$ver_rel_left" = "$ver_rel_l" ] &&
	/ "[ ! -z \"\${pkg_${repo_urn_plain_l}_major:+x}\" ]" &&
	{
		/ "major_l=\"\${pkg_${repo_urn_plain_l}_major}\" \
			minor_l=\"\${pkg_${repo_urn_plain_l}_minor}\" \
			patch_l=\"\${pkg_${repo_urn_plain_l}_patch}\" \
			ident_l=\"\${pkg_${repo_urn_plain_l}_ident}\" \
			suffix_l=\"\${pkg_${repo_urn_plain_l}_suffix}\" \
			rel_l=\"\${pkg_${repo_urn_plain_l}_rel}\""
	} || {
		ver_l="${ver_rel_l%%-*}" rel_l="${ver_rel_l##*-}"
		is_version "$ver_l" && is_version "$rel_l" ||
			// die '$ver_rel_l' "'$ver_rel_l' is invalid"

		! // || / `ver_split "$ver_l" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "major_l=\""$1"\"; \
		minor_l=\""$2"\"; \
		patch_l=\""$3"\"; \
		ident_l=\""$4"\"; \
		suffix_l=\""$5"\"" }' ||
		# Unknown version is large
		printf '%s\n' "{ _left_is_less=1; printf \"%s\" \""$_left_is_less"\"; return 0; }"`


		[ -z "${rel_l:+x}" ] && rel_l=0 ||
		# is_integer "$rel_l" || die '$rel_l' "'$rel_l' is not an integer"
		is_integer "$rel_l" || rel_l=0
			# rel_l=9999
	}

	# local end=`date +%s.%N`
	# local ver_split_time=$(echo "$end - $start" | bc -l)
	# // log '$ver_split_time' "$ver_split_time"

	# local start=`date +%s.%N`

	local ver_r= rel_r=

	# IFS=.+-_ read -r major_r minor_r patch_r ident_r \
	#     < <(printf '%s\n' "$ver_r") > /dev/null || // die "printf '%s\\n' \"$ver_r\"" "failed"

	local major_r= minor_r= patch_r= ident_r= suffix_r=
	# ver_split major_r minor_r patch_r ident_r suffix_r "$ver_r"

	local ver_rel_right=
	local repo_urn_plain_r=
	[ -z "${repo_left:+x}" ] || {
		repo_urn_plain_r="$(name_plain "$repo_right")"
		/ "ver_rel_right=\"\${pkg_${repo_urn_plain_r}_version}\""
	}
	[ ! -z "${ver_rel_right:+x}" ] &&
	[ "$ver_rel_right" = "$ver_rel_r" ] &&
	/ "[ ! -z \"\${pkg_${repo_urn_plain_r}_major:+x}\" ]" &&
	{
		/ "major_r=\"\${pkg_${repo_urn_plain_r}_major}\" \
			minor_r=\"\${pkg_${repo_urn_plain_r}_minor}\" \
			patch_r=\"\${pkg_${repo_urn_plain_r}_patch}\" \
			ident_r=\"\${pkg_${repo_urn_plain_r}_ident}\" \
			suffix_r=\"\${pkg_${repo_urn_plain_r}_suffix}\" \
			rel_r=\"\${pkg_${repo_urn_plain_r}_rel}\""
	} || {

		ver_r="${ver_rel_r%%-*}" rel_r="${ver_rel_r##*-}"
		is_version "$ver_r" && is_version "$rel_r" ||
			// die '$ver_rel_r' "'$ver_rel_r' is invalid"

		! // || / `ver_split "$ver_r" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "major_r=\""$1"\"; \
		minor_r=\""$2"\"; \
		patch_r=\""$3"\"; \
		ident_r=\""$4"\"; \
		suffix_r=\""$5"\"" }' ||
		# Unknown version is large
		printf '%s\n' "{ _left_is_less=0; printf \"%s\" \""$_left_is_less"\"; return 0; }"`


		[ -z "${rel_r:+x}" ] && rel_r=0 ||
		# is_integer "$rel_r" || die '$rel_r' "'$rel_r' is not an integer"
		is_integer "$rel_r" || rel_r=0
		# rel_r=9999
	}

	# (
	# local end=`date +%s.%N`
	# local prepare_time=$(echo "$end - $start" | bc -l)
	# // log '$prepare_time' "$prepare_time"
	# ) &

	# local start=`date +%s.%N`

	# For version number, larger is better, and sorted at left
	#
	# ! is_integer "$major_l" || ! is_integer "$major_r" || {
	#   # 3.x.x.x              4.x.x.x
	#   # [ "$major_l" -lt "$major_r" ] && { _left_is_less=0; return $_left_is_less; }
	#   #
	#   # 5.x.x.x              4.x.x.x
	#   # 4.x.x.x              4.x.x.x
	#   #                                          3.x.x.x              4.x.x.x
	#   [ "$major_l" -ge "$major_r" ] || { _left_is_less=0; return $_left_is_less; }
	#   # 5.x.x.x              4.x.x.x
	#   # [ "$major_l" -gt "$major_r" ] && return $_left_is_less
	#   #
	#   # 4.x.x.x              4.x.x.x             5.x.x.x              4.x.x.x
	#   [ "$major_l" -eq "$major_r" ] || return $_left_is_less
	# }

	# ! is_integer "$minor_l" || ! is_integer "$minor_r" || {
	#   # 4.3.x.x              4.4.x.x
	#   # [ "$minor_l" -lt "$minor_r" ] && { _left_is_less=0; return $_left_is_less; }
	#   #
	#   # 4.5.x.x              4.4.x.x
	#   # 4.4.x.x              4.4.x.x
	#   #                                          4.3.x.x              4.4.x.x
	#   [ "$minor_l" -ge "$minor_r" ] || { _left_is_less=0; return $_left_is_less; }
	#   # 4.5.x.x              4.4.x.x
	#   # [ "$minor_l" -gt "$minor_r" ] && return $_left_is_less
	#   #
	#   # 4.4.x.x              4.4.x.x             4.5.x.x              4.4.x.x
	#   [ "$minor_l" -eq "$minor_r" ] || return $_left_is_less
	# }

	# ! is_integer "$patch_l" || ! is_integer "$patch_r" || {
	#   # 4.4.3.x              4.4.4.x
	#   # [ "$patch_l" -lt "$patch_r" ] && { _left_is_less=0; return $_left_is_less; }
	#   #
	#   # 4.4.5.x              4.4.4.x
	#   # 4.4.4.x              4.4.4.x
	#   #                                          4.4.3.x              4.4.4.x
	#   [ "$patch_l" -ge "$patch_r" ] || { _left_is_less=0; return $_left_is_less; }
	#   # 4.4.4.x              4.4.4.x             4.4.5.x              4.4.4.x
	#   [ "$patch_l" -eq "$patch_r" ] || return $_left_is_less
	# }

	# ! is_integer "$ident_l" || ! is_integer "$ident_r" || {
	#   # 5.5.5.3              4.4.4.4
	#   # [ "$ident_l" -lt "$ident_r" ] && { _left_is_less=0; return $_left_is_less; }
	#   #
	#   # 4.4.4.5              4.4.4.4
	#   # 4.4.4.4              4.4.4.4
	#   #                                          4.4.4.3              4.4.4.4
	#   [ "$ident_l" -ge "$ident_r" ] || { _left_is_less=0; return $_left_is_less; }
	#   # 4.4.4.4              4.4.4.4             4.4.4.5              4.4.4.4
	#   [ "$ident_l" -eq "$ident_r" ] || return $_left_is_less
	# }

	# ! is_integer "$rel_l" || ! is_integer "$rel_r" || {
	#   [ "$rel_l" -ge "$rel_r" ] || { _left_is_less=0; return $_left_is_less; }
	#   [ "$rel_l" -eq "$rel_r" ] || return $_left_is_less
	# }
	#

	# Using subprocesses to isolate/avoid variables overwritten
	# local conclusion="$(// delegate filter_less "$major_l" "$major_r")"
	# [ -z "$conclusion" ] || return $conclusion
	# [ -z "$conclusion" ] || { _left_is_less="$conclusion"; printf "$RS%s" "$_left_is_less"; return 0; }

	# _left_is_less="$(// delegate filter_less "$major_l" "$major_r")"
	# For performance, bypass delegate
	filter_less _left_is_less "$major_l" "$major_r"
	[ -z "$_left_is_less" ] || { printf "%s" "$_left_is_less"; return 0; }
	# _left_is_less="$(// delegate filter_less "$minor_l" "$minor_r")"
	filter_less _left_is_less "$minor_l" "$minor_r"
	[ -z "$_left_is_less" ] || { printf "%s" "$_left_is_less"; return 0; }
	# _left_is_less="$(// delegate filter_less "$patch_l" "$patch_r")"
	filter_less _left_is_less "$patch_l" "$patch_r"
	[ -z "$_left_is_less" ] || { printf "%s" "$_left_is_less"; return 0; }
	# _left_is_less="$(// delegate filter_less "$ident_l" "$ident_r")"
	filter_less _left_is_less "$ident_l" "$ident_r"
	[ -z "$_left_is_less" ] || { printf "%s" "$_left_is_less"; return 0; }
	# _left_is_less="$(// delegate filter_less "$rel_l"   "$rel_r")"
	filter_less _left_is_less "$rel_l"   "$rel_r"
	[ -z "$_left_is_less" ] || { printf "%s" "$_left_is_less"; return 0; }

	// debug_filter -- // debug '$ver_rel_l : $ver_rel_r' "'$ver_rel_l' : '$ver_rel_r' left is not less"

	# (
	# local end=`date +%s.%N`
	# local is_less_time=$(echo "$end - $start" | bc -l)
	# // log '$is_less_time' "$is_less_time"
	# ) &
	#
	# printf "$RS%s" "$_left_is_less"
	printf "%s" "$_left_is_less"
	# return $_left_is_less
}

folder_priority() {
	case "$1" in
		"core")               priority_num=128  ;;
		"system")             priority_num=64   ;;
		"desktop")            priority_num=32   ;;
		"wayland")            priority_num=16   ;;
		"extra")              priority_num=8    ;;
		"base")               priority_num=4    ;;
		"underconstruction")  priority_num=2    ;;
		"static")             priority_num=1    ;;
		*)                    priority_num=0
	esac
	printf "%s" "$priority_num"
}

left_is_lower() {
	_level_2
	local repo_name="$1"
	shift 1

	# local _left_is_less_name="$1"
	# shift 1

	local ver_rel_l="$1" ver_rel_r="$2"
	shift 2

	# local start=`date +%s.%N`

	# local repo_dir_left="$(standardize "$1")"
	local repo_dir_left="$1" repo_dir_right="$2"

	[ "${1##*/}" != "" ] || repo_dir_left="${1%/}"

	[ ! -z "${1##*"$repo_name"*}" ] ||
		repo_dir_left="${1%"/${repo_name}"*}"
		# repo_dir_left="$(standardize "${1%"/${repo_name}"*}")"

	# local repo_dir_right="$(standardize "$2")"
	# local repo_dir_right="$2"
	[ "${2##*/}" != "" ] || repo_dir_right="${2%/}"
	[ ! -z "${2##*"$repo_name"*}" ] ||
		repo_dir_right="${2%"/${repo_name}"*}"
		# repo_dir_right="$(standardize "${2%"/${repo_name}"*}")"

	[ ! -z "${USE_FOLDER_PRIORITY+x}" ] || {
		local reference_folder_left="${repo_dir_left##*/}"
		[ ! -z "${reference_folder_left##*"${REPO_BASE}"*}" ] ||
			reference_folder_left="base"
		# [ ! -z "${reference_folder_left##*"${KISS_REPO}"*}" ] || {
		#   reference_folder_left="${repo_dir_left##*"${KISS_REPO}"/}"
		#   reference_folder_left="${reference_folder_left%%/*}"
		# }

		local reference_folder_right="${repo_dir_right##*/}"
		[ ! -z "${reference_folder_right##*"${REPO_BASE}"*}" ] ||
			reference_folder_right="base"
		# [ ! -z "${reference_folder_right##*"${KISS_REPO}"*}" ] || {
		#   reference_folder_right="${repo_dir_right##*"${KISS_REPO}"/}"
		#   reference_folder_right="${reference_folder_left%%/*}"
		# }
	}

	local repo_left="$repo_dir_left/$repo_name"
	# is_repos "$repo_left" || // log '$repo_left' "$repo_left"
	local repo_right="$repo_dir_right/$repo_name"
	# is_repos "$repo_left" "$repo_right" || {
	#   is_repos "$repo_left" || // log '$repo_left' "$repo_left"
	#   is_repos "$repo_right" || // log '$repo_right' "$repo_right"
	# }

	local _left_is_less=

	# (
	# local end=`date +%s.%N`
	# local prepare_time=$(echo "$end - $start" | bc -l)
	# // log '$prepare_time' "$prepare_time"
	# ) &

	# local start=`date +%s.%N`

	# _left_is_less_prepare="$(// left_is_less "$repo_name" "$ver_rel_l" "$ver_rel_r")"
	# _left_is_less="${_left_is_less_prepare##*${newline}}"
	_left_is_less="$(// left_is_less "$repo_name" "$ver_rel_l" "$ver_rel_r")"

	(
	local end=`date +%s.%N`
	local less_wrapper=$(echo "$end - $start" | bc -l)
	// log '$less_wrapper' "$less_wrapper"
	) &

	# ! is_version "$ver_l" || ! is_version "$rel_l" ||
	# ! is_version "$ver_r" || ! is_version "$rel_r" ||
	[ -z "$_left_is_less" ] || {
		printf "%s" "$_left_is_less"
		# / "$_left_is_less_name=\"$_left_is_less\""
		return 0
	}

	# For performance
	[ ! -z "${USE_FOLDER_PRIORITY+x}" ] || {
		printf "%s" "$_left_is_less"
		# / "$_left_is_less_name=\"$_left_is_less\""
		return 0
	}

	local start=`date +%s.%N`

	# For version number, larger is better, and sorted at left

	# local dir_priority_left="$(// delegate folder_priority "$reference_folder_left")"
	local dir_priority_left="$(// folder_priority "$reference_folder_left")" &&
	# local dir_priority_right="$(// delegate folder_priority "$reference_folder_right")"
	local dir_priority_right="$(// folder_priority "$reference_folder_right")" &&

	[ "$dir_priority_left" -ge "$dir_priority_right" ] || { _left_is_less=0; printf "%s" "$_left_is_less"; return 0; }
	[ "$dir_priority_left" -eq "$dir_priority_right" ] || { _left_is_less=1; printf "%s" "$_left_is_less"; return 0; }

	// debug_filter -- // debug '$ver_l-$rel_l' "$ver_l-$rel_l : $repo_left is not lower"
	// debug_filter -- // debug '$ver_r-$rel_r' "$ver_r-$rel_r : $repo_right"

	# (
	# local end=`date +%s.%N`
	# local is_lower_time=$(echo "$end - $start" | bc -l)
	# // log '$is_lower_time' "$is_lower_time"
	# ) &

	printf "%s" "$_left_is_less"
	# / "$_left_is_less_name=\"$_left_is_less\""
}

# The resullt  : larger one is on the left
# $1           : less_filter
# $2           : repo_name
# $@           : ver-rel(s)
# [ -z "${KEEP_DEPRECATED+x}" ] ||
sort_ver_rel() {
	# local out_list_name="$1"
	# shift 1
	local less_filter="$1"
	shift 1
	local repo_name="$1"
	shift 1

	local less_filter_with_repo_name="$less_filter \"$repo_name\""
	# local less_filter_with_repo_name="left_is_less \"$repo_name\""

	# The first element
	local sorted_list="$1"
	shift 1

	locate() {
		_level_2
		# local out_list_name="$1"
		# shift 1
		#
		# local less_filter_with_repo_name="$1"
		# shift 1

		local reference_object="$1"
		readonly reference_object
		shift 1
		local left_list= right_list=
		local sorted_element
		local located=1
		local index=0

		// debug_filter -- // debug '$#' "$#" &
		# // debug '$@' "$(esceval $@)"

		# local start=`date +%s.%N`

		for sorted_element do
			# // log 'step : $index' "begin : $index" &
			# local start_step=`date +%s.%N`

			// debug_filter -- // debug '$reference_object' "$reference_object" &
			// debug_filter -- // debug '$sorted_element' "$sorted_element" &

			shift 1

			// debug_filter -- // debug '$@' "$(esceval $@)" &
			_left_is_less=

			# local ver_start=`date +%s.%N`

			ver_rel_l="$reference_object"
			// debug_filter -- // debug '$ver_rel_l' "$ver_rel_l" &


			ver_rel_r="$sorted_element"
			// debug_filter -- // debug '$ver_rel_r' "$ver_rel_r" &

			# (
			# local ver_end=`date +%s.%N`
			# local pkg_ver_wrapper=$(echo "$ver_end - $ver_start" | bc -l)
			# // log '$pkg_ver_wrapper' "$pkg_ver_wrapper"
			# ) &

			# ! // || / `$less_filter_with_repo_name "$reference_object" "$sorted_element" |
			#   awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			#           END { print "_left_is_less=\""$1"\"" }' ||
			#               printf '%s\n' "return 1"`
			# _left_is_less="$(// delegate $less_filter_with_repo_name "$reference_object" "$sorted_element")"
			#
			# _left_is_less="$(// $less_filter_with_repo_name "$reference_object" "$sorted_element")"
			# For using \n as a characterized $RS
			# _left_is_less="${_left_is_less##*$newline}"
			#
			# local repo_urn_plain_left="$(name_plain "$reference_object")"
			# local repo_urn_plain_riht="$(name_plain "$sorted_element")"
			# / "// $less_filter_with_repo_name \
			#   _left_is_less \
			#   pkg_${repo_urn_plain_left}_version \
			#   pkg_${repo_urn_plain_riht}_version \
			#   \"$reference_object\" \"$sorted_element\""

			_left_is_less="$(// $less_filter_with_repo_name \
				"$ver_rel_l" "$ver_rel_r")"

			# (
			# local end_step=`date +%s.%N`
			# local lower_wrapper=$(echo "$end_step - $start_step" | bc -l)
			# // war '$lower_wrapper' "$lower_wrapper"
			# ) &

			# local start_step=`date +%s.%N`

			equ "$_left_is_less" "0" && {
				// debug_filter -- // debug '$reference_object' "'$reference_object' is less" &
				# Large at left
				left_list="${left_list:+"${left_list} "}$sorted_element"
			} || {
				# [ -z "$_left_is_less" ] || equ "$_left_is_less" "1"
				// debug_filter -- // debug '$reference_object' "'$reference_object' is great" &
				right_list="$reference_object $sorted_element $@"
				located=0
				# (
				# local end_step=`date +%s.%N`
				# local time_step=$(echo "$end_step - $start_step" | bc -l)
				# // war '$time_step' "$time_step"
				# ) &
				break
			}

			# (
			# local end_step=`date +%s.%N`
			# local time_step=$(echo "$end_step - $start_step" | bc -l)
			# // war '$time_step' "$time_step"
			# ) &

			: $((index += 1))
		done
		# Without this, the extremely less value will be leaked out for ever
		equ "$located" "0" ||
			right_list="${right_list:+"${right_list} "}$reference_object"

		# / "$out_list_name=\"${left_list:+"${left_list} "}${right_list}\""
		sorted_list="${left_list:+"${left_list} "}$right_list"
		// debug_filter -- // debug '$sorted_list' "$(esceval $sorted_list)" &

		# (
		# local end=`date +%s.%N`
		# local locate_time=$(echo "$end - $start" | bc -l)
		# // war '$locate_time' "$locate_time"
		# ) &
	}

	local sort_id
	local repo_ver_rel
	# {
		for repo_ver_rel do
			# locate sorted_list "left_is_less \"$repo_name\"" "$repo_ver_rel" $sorted_list
			locate "$repo_ver_rel" $sorted_list
			shift 1
		done
	# } & sort_id=$!

	# // progress "$sort_id" "sorting"

	# / "$out_list_name=\"$sorted_list\""

	local index=0
	for sort_object in $sorted_list; do
	  equ "$index" "0" && printf "$RS%s" "$sort_object" ||
	  printf "$FS%s" "$sort_object"
	  : $((index += 1))
	done
	return 0
}

# The resullt  : larger one is on the left
# $1           : less_filter
# $2           : repo_name
# $@           : repo_dirs
version_priority() {
	_level_2
	local less_filter="$1"
	shift 1
	local repo_name="$1"
	shift 1
	[ "$#" -ge "2" ] || // die 'sort' "needs at least 2 parameters (except repo_name), but got $#"

	local less_filter_with_repo_name="$less_filter $repo_name"
	local dir_l= ver_l= rel_l= alias_l= url_l= reference_type_l=
	local ver_rel_l=
	local repo_urn_plain_left= repo_urn_plain_right=
	local dir_r= ver_r= rel_r= alias_r= url_r= reference_type_r=
	local ver_rel_r=
	local _left_is_less=

	locate() {
		_level_2
		# local out_list_name="$1"
		# shift 1
		#
		# local less_filter_with_repo_name="$1"
		# shift 1

		local reference_object="$1"
		readonly reference_object
		shift 1
		local left_list= right_list=
		local sorted_element
		local located=1
		local index=0

		// debug_filter -- // debug '$#' "$#" &
		# // debug '$@' "$(esceval $@)"

		# local start=`date +%s.%N`

		for sorted_element do
			# // log 'step : $index' "begin : $index" &
			# local start_step=`date +%s.%N`

			// debug_filter -- // debug '$reference_object' "$reference_object" &
			// debug_filter -- // debug '$sorted_element' "$sorted_element" &

			shift 1

			// debug_filter -- // debug '$@' "$(esceval $@)" &
			_left_is_less=

			# local ver_start=`date +%s.%N`

			repo_urn_plain_left="$(name_plain "$reference_object")"
			// debug_filter -- // debug '$repo_urn_plain_left' "$repo_urn_plain_left" &
			// debug_filter -- / "// debug '\${pkg_${repo_urn_plain_left}_version}' \"\${pkg_${repo_urn_plain_left}_version-}\"" &
			/ "ver_rel_l=\"\${pkg_${repo_urn_plain_left}_version-}\""
			// debug_filter -- // debug '$ver_rel_l' "$ver_rel_l" &
			# [ ! -z "${ver_rel_l:+x}" ] && {
			#   # (
			#   # local ver_end=`date +%s.%N`
			#   # local pkg_ver_buffer=$(echo "$ver_end - $ver_start" | bc -l)
			#   # // log '$pkg_ver_buffer' "$pkg_ver_buffer"
			#   # ) &
			# } || {
			[ ! -z "${ver_rel_l:+x}" ] || {

				[ ! -z "${reference_object##*"${REPO_BASE}"*}" ] || {
					# /opt/var/db/kiss/lm/base/llvm/15.0.7-0/llvm
					ver_rel_l="${reference_object%/"$repo_name"}"
					ver_rel_l="${ver_rel_l##*/}"
					ver_l="${ver_rel_l%%-*}" rel_l="${ver_rel_l##*-}"
					is_version "$ver_l" && is_version "$rel_l" &&
						/ "pkg_${repo_urn_plain_left}_version=\"$ver_rel_l\"" ||
						ver_rel_l=
				}

				[ ! -z "$ver_rel_l" ] || {

					dir_l= ver_l= rel_l= alias_l= url_l= reference_type_l=

					! // || / `pkg_version "$reference_object" |
						awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
					END { print "dir_l=\""$1"\"; ver_l=\""$2"\"; rel_l=\""$3"\"; \
					alias_l=\""$4"\"; url_l=\""$5"\"; reference_type_l=\""$6"\"" }' ||
					printf '%s\n' "_left_is_less=1"`
					# printf '%s\n' "{ printf \"$RS%s\" \""$_left_is_less"\"; return 0; }"`
					# printf '%s\n' "return 1"`
					# // war '$dir_l' "$(realpath "$dir_l")"
					/ "pkg_${repo_urn_plain_left}_version=\"$ver_l-$rel_l\""
					/ "// log '\${pkg_${repo_urn_plain_left}_version}' \"\${pkg_${repo_urn_plain_left}_version-}\"" &
					# / "$ver_rel_l_name=\"$ver_l-$rel_l\""
					ver_rel_l="$ver_l-$rel_l"
				}
			}


			repo_urn_plain_right="$(name_plain "$sorted_element")"
			// debug_filter -- // debug '$repo_urn_plain_right' "$repo_urn_plain_right" &
			// debug_filter -- / "// debug '\${pkg_${repo_urn_plain_right}_version}' \"\${pkg_${repo_urn_plain_right}_version-}\"" &
			/ "local ver_rel_r=\"\${pkg_${repo_urn_plain_right}_version-}\""
			// debug_filter -- // debug '$ver_rel_r' "$ver_rel_r" &
			[ ! -z "${ver_rel_r:+x}" ] || {

				[ ! -z "${sorted_element##*"${REPO_BASE}"*}" ] || {
					# /opt/var/db/kiss/lm/base/llvm/15.0.7-0/llvm
					ver_rel_r="${sorted_element%/"$repo_name"}"
					ver_rel_r="${ver_rel_r##*/}"
					local ver_r="${ver_rel_r%%-*}" rel_r="${ver_rel_r##*-}"
					is_version "$ver_r" && is_version "$rel_r" &&
						/ "pkg_${repo_urn_plain_right}_version=\"$ver_rel_r\"" ||
						ver_rel_r=
				}

				[ ! -z "$ver_rel_r" ] || {

					dir_r= ver_r= rel_r= alias_r= url_r= reference_type_r=

					! // || / `pkg_version "$sorted_element" |
						awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
					END { print "dir_r=\""$1"\"; ver_r=\""$2"\"; rel_r=\""$3"\"; \
					alias_r=\""$4"\"; url_r=\""$5"\"; reference_type_r=\""$6"\"" }' ||
					printf '%s\n' "_left_is_less=0"`
					# printf '%s\n' "{ printf \"$RS%s\" \""$_left_is_less"\"; return 0; }"`
					# Unknown version is large -- return _left_is_less=0
					# printf '%s\n' "return 0"`
					# // war '$dir_r' "$(realpath "$dir_r")"
					/ "pkg_${repo_urn_plain_right}_version=\"$ver_r-$rel_r\""
					/ "// log '\${pkg_${repo_urn_plain_right}_version}' \"\${pkg_${repo_urn_plain_right}_version-}\"" &
					# / "$ver_rel_r_name=\"$ver_r-$rel_r\""
					ver_rel_r="$ver_r-$rel_r"
				}
			}

			# (
			# local ver_end=`date +%s.%N`
			# local pkg_ver_wrapper=$(echo "$ver_end - $ver_start" | bc -l)
			# // log '$pkg_ver_wrapper' "$pkg_ver_wrapper"
			# ) &

			# ! // || / `$less_filter_with_repo_name "$reference_object" "$sorted_element" |
			#   awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			#           END { print "_left_is_less=\""$1"\"" }' ||
			#               printf '%s\n' "return 1"`
			# _left_is_less="$(// delegate $less_filter_with_repo_name "$reference_object" "$sorted_element")"
			#
			# _left_is_less="$(// $less_filter_with_repo_name "$reference_object" "$sorted_element")"
			# For using \n as a characterized $RS
			# _left_is_less="${_left_is_less##*$newline}"
			#
			# local repo_urn_plain_left="$(name_plain "$reference_object")"
			# local repo_urn_plain_riht="$(name_plain "$sorted_element")"
			# / "// $less_filter_with_repo_name \
			#   _left_is_less \
			#   pkg_${repo_urn_plain_left}_version \
			#   pkg_${repo_urn_plain_riht}_version \
			#   \"$reference_object\" \"$sorted_element\""

			_left_is_less="$(// $less_filter_with_repo_name \
				"$ver_rel_l" "$ver_rel_r" \
				"${reference_object%/"$repo_name"*}" "${sorted_element%/"$repo_name"*}")"

			# (
			# local end_step=`date +%s.%N`
			# local lower_wrapper=$(echo "$end_step - $start_step" | bc -l)
			# // war '$lower_wrapper' "$lower_wrapper"
			# ) &

			# local start_step=`date +%s.%N`

			equ "$_left_is_less" "0" && {
				// debug_filter -- // debug '$reference_object' "'$reference_object' is less" &
				# Large at left
				left_list="${left_list:+"${left_list} "}$sorted_element"
			} || {
				# [ -z "$_left_is_less" ] || equ "$_left_is_less" "1"
				// debug_filter -- // debug '$reference_object' "'$reference_object' is great" &
				right_list="$reference_object $sorted_element $@"
				located=0
				# (
				# local end_step=`date +%s.%N`
				# local time_step=$(echo "$end_step - $start_step" | bc -l)
				# // war '$time_step' "$time_step"
				# ) &
				break
			}

			# (
			# local end_step=`date +%s.%N`
			# local time_step=$(echo "$end_step - $start_step" | bc -l)
			# // war '$time_step' "$time_step"
			# ) &

			: $((index += 1))
		done
		# Without this, the extremely less value will be leaked out for ever
		equ "$located" "0" ||
			right_list="${right_list:+"${right_list} "}$reference_object"

		# / "$out_list_name=\"${left_list:+"${left_list} "}${right_list}\""
		sorted_list="${left_list:+"${left_list} "}$right_list"
		// debug_filter -- // debug '$sorted_list' "$(esceval $sorted_list)" &

		# (
		# local end=`date +%s.%N`
		# local locate_time=$(echo "$end - $start" | bc -l)
		# // war '$locate_time' "$locate_time"
		# ) &
	}

	local start=`date +%s`
	local sort_id
	# DEEP_FIRST=

	[ -z "${DEEP_FIRST+x}" ] || {
		# The first element
		local sorted_list="$1"
		shift 1

		local sort_object
		local reference_object
		// war 'locate' "sorting repos ..."
		# {
			for reference_object do
				# locate sorted_list "$less_filter \"$repo_name\"" "$reference_object" $sorted_list
				// locate "$reference_object" $sorted_list
				shift 1
			done
		# } & sort_id=$!
		# // progress "$sort_id" "sorting ..."

		// debug_filter -- // log '$sorted_list' "$(esceval $sorted_list)" &

		(
		local end=`date +%s`
		local sort_time=$(expr $end - $start)
		// log '$sort_time' "$sort_time"
		) &

		local index=0
		for sort_object in $sorted_list; do
		  equ "$index" "0" && printf "$RS%s" "$sort_object" ||
		  printf "$FS%s" "$sort_object"
		  : $((index += 1))
		done
		return 0
	}

	mock_number() {
		local repo_urn_plain_name="$1"
		local item_name="$2" item_value="$3"
		[ "x$(printf '%s' "$item_value" | tr -d "$IFS")" = "x" ] &&
		# [ -z "${item_value:+x}" ] &&
		item_value=0 || is_integer "$item_value" || item_value=0

		/ "$item_name=\"$item_value\""
		# / "${item_name}_length=\"${#item_value}\""
		/ "${item_name}_width=\"\$((${#item_value} > ${item_name}_width ? ${#item_value} : ${item_name}_width))\""

		/ "pkg_${repo_urn_plain_name}_$item_name=\"$item_value\""
	}

	local abnormal_list=
	local item
	local repo_urn_plain
	local ver_rel ver rel _alias url reference_type
	local major= minor= patch= ident= suffix=
	local sort_list=

	for item do
		is_repos "$item" && {
			# local ver_start=`date +%s.%N`
			repo_urn_plain="$(name_plain "$item")"
			// debug_filter -- // debug '$repo_urn_plain' "$repo_urn_plain" &
			// debug_filter -- / "// debug '\${pkg_${repo_urn_plain}_version}' \"\${pkg_${repo_urn_plain}_version-}\"" &
			/ "ver_rel=\"\${pkg_${repo_urn_plain}_version-}\""
			ver="${ver_rel%%-*}" rel="${ver_rel##*-}"
			// debug_filter -- // debug '$ver_rel' "$ver_rel" &
			# [ ! -z "${ver_rel_l:+x}" ] && {
			#   # (
			#   # local ver_end=`date +%s.%N`
			#   # local pkg_ver_buffer=$(echo "$ver_end - $ver_start" | bc -l)
			#   # // log '$pkg_ver_buffer' "$pkg_ver_buffer"
			#   # ) &
			# } || {
			[ ! -z "${ver_rel:+x}" ] || {

				[ ! -z "${item##*"${REPO_BASE}"*}" ] || {
					# /opt/var/db/kiss/lm/base/llvm/15.0.7-0/llvm
					ver_rel="${item%/"$repo_name"}"
					ver_rel="${ver_rel##*/}"
					ver="${ver_rel%%-*}" rel="${ver_rel##*-}"
					is_version "$ver" && is_version "$rel" &&
						/ "pkg_${repo_urn_plain}_version=\"$ver_rel\"" ||
						ver_rel=
				}

				[ ! -z "$ver_rel" ] || {

					dir_r= ver= rel= _alias= url= reference_type=

					! // || / `pkg_version "$item" |
						awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
					END { print "dir_r=\""$1"\"; ver=\""$2"\"; rel=\""$3"\"; \
					_alias=\""$4"\"; url=\""$5"\"; reference_type=\""$6"\"" }' ||
					printf '%s\n' "{ abnormal_list=\"${abnormal_list:+${abnormal_list} }$item\"; continue; }"`
					# printf '%s\n' "_left_is_less=0"`
					# printf '%s\n' "{ printf \"$RS%s\" \""$_left_is_less"\"; return 0; }"`
					# Unknown version is large -- return _left_is_less=0
					# printf '%s\n' "return 0"`
					# // war '$dir_r' "$(realpath "$dir_r")"
					/ "pkg_${repo_urn_plain}_version=\"$ver-$rel\""

					# / "// log '\${pkg_${repo_urn_plain}_version}' \"\${pkg_${repo_urn_plain}_version-}\""

					# / "$ver_rel_r_name=\"$ver-$rel\""
					ver_rel="$ver-$rel"
				}
			}
		} || {
			ver_rel="$item"
			ver="${ver_rel%%-*}" rel="${ver_rel##*-}"
			is_version "$ver" && is_version "$rel" ||
				// die '$ver-$rel' "'$ver-$rel' is illigal (neither a repo nor a ver-rel)"
			// debug_filter -- // debug '$ver_rel' "$ver_rel" &
			[ ! -z "${ver_rel:+x}" ] || // die '$ver_rel' "'$ver_rel' is illigal (neither a repo nor a ver-rel)"
		}
		# ver_split major_l minor_l patch_l ident_l suffix_l "$ver_l"

		! // || / `ver_split "$ver" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "major=\""$1"\"; \
		minor=\""$2"\"; \
		patch=\""$3"\"; \
		ident=\""$4"\"; \
		suffix=\""$5"\"" }' ||
		printf '%s\n' "{ abnormal_list=\"${abnormal_list:+${abnormal_list} }$item\"; continue; }"`
		# Unknown version is large -- not default value _left_is_less=1
		# printf '%s\n' "{ _left_is_less=1; printf \"%s\" \""$_left_is_less"\"; return 0; }"`

		# [ -z "${major:+x}" ] && major=0 || is_integer "$major" || major=0
		# / "pkg_${repo_urn_plain}_major=\"$major\""
		mock_number "$repo_urn_plain" "major" "$major"
		# / "pkg_${repo_urn_plain}_minor=\"$minor\""
		mock_number "$repo_urn_plain" "minor" "$minor"
		# / "pkg_${repo_urn_plain}_patch=\"$patch\""
		mock_number "$repo_urn_plain" "patch" "$patch"
		# / "pkg_${repo_urn_plain}_ident=\"$ident\""
		mock_number "$repo_urn_plain" "ident" "$ident"
		# / "pkg_${repo_urn_plain}_suffix=\"$suffix\""
		mock_number "$repo_urn_plain" "suffix" "$suffix"

		# [ -z "${rel:+x}" ] && rel=0 || is_integer "$rel" || rel=0
		# / "pkg_${repo_urn_plain}_rel=\"$rel\""
		mock_number "$repo_urn_plain" "rel" "$rel"

		# (
		# local ver_end=`date +%s.%N`
		# local pkg_ver_wrapper=$(echo "$ver_end - $ver_start" | bc -l)
		# // log '$pkg_ver_wrapper' "$pkg_ver_wrapper"
		# ) &

		/ "// log \"'\
\$(// delegate -- format "$major"  "$major_width").\
\$(// delegate -- format "$minor"  "$minor_width").\
\$(// delegate -- format "$patch"  "$patch_width").\
\$(// delegate -- format "$ident"  "$ident_width").\
\$(// delegate -- format "$suffix" "$suffix_width")\
-\
\$(// delegate -- format "$rel"    "$rel_width")'\" '\${pkg_${repo_urn_plain}_version}'" &

		sort_list="${sort_list:+"${sort_list} "}$item"

	done

	set -- $sort_list

	local major_list=
	repo_urn_plain_l="$(name_plain "$1")"
	# 13
	/ "major_l=\"\${pkg_${repo_urn_plain_l}_major}\""
	# major_13
	/ "major_$major_l=\"$1\""
	/ "major_list=\"major_$major_l\""
	// debug_filter -- / "// log '\$major_list' \"$major_list\"" &
	shift 1

	triple_locate() {
		local level="$1"
		local level_name="${level##*_}"
		# local dangling="$2"
		local left="$2" right
		shift 2

		local left_list=
		local right_list=
		local located=1
		local index=0

		is_repos "$left" || // die '$left' "'$left' is not a repo"
		# for left in $dangling; do break; done
		repo_urn_plain_l="$(name_plain "$left")"
		# 15
		/ "${level_name}_l=\"\${pkg_${repo_urn_plain_l}_${level_name}}\""
		# major_15
		/ "left_sublist_name=\"\${level}_\${${level_name}_l}\""
		#
		# mock_number() made _left_is_less= means equal
		# and equal key values merged here
		#
		# /bin/sh: syntax error: bad substitution
		# / "[ \"x`printf '%s' "\${${left_sublist_name}-}" | tr -d "$IFS"`\" != x ]" && {
		# sh: /opt/var/db/kiss/ioraff/modified/llvm: unknown operand
		# / [ "x$(printf '%s' "\${${left_sublist_name}-}" | tr -d "$IFS")" != "x" ] && {
		/ [ "\"x$(printf '%s' "\${${left_sublist_name}-}" | tr -d "$IFS")\"" != "x" ] && {
			/ "$left_sublist_name=\"\${$left_sublist_name} $left\""

			// debug_filter -- / "// log '\$left_sublist name : value' \"$left_sublist_name :${newline}\$(esceval \${$left_sublist_name})\"" &
			#
			# ! list_contains "$left_sublist_name" "$@" || return 0
			# located=0
			return 0
		} ||
			/ "$left_sublist_name=\"$left\""



		# local list_buffer="$@"
		#
		# local sub_list_name semantically equal to riht_sublist_name
		local riht_sublist_name
		# for sub_list_name do
		for riht_sublist_name do
			shift 1
			# for right in $sub_list_name; do break; done
			# for right in $riht_sublist_name; do break; done
			_left_is_less=
			# repo_urn_plain_r="$(name_plain "$right")"
			# / "${level}_r=\"\${pkg_${repo_urn_plain_r}_${level}}\""
			# / "${level_name}_r=\"${right##*_}\""
			/ "${level_name}_r=\"${riht_sublist_name##*_}\""
			# / "riht_sublist_name=\"\${level}_\${${level}_r}\""
			# / "$riht_sublist_name=\"\${$sub_list_name}\""

			// debug_filter -- / "// log '\$riht_sublist name : value' \"$riht_sublist_name :${newline}\$(esceval \${$riht_sublist_name})\"" &

			/ "filter_less _left_is_less \"\${${level_name}_l}\" \"\${${level_name}_r}\""

			# _left_is_less= is filterd by $left_sublist_name
			[ ! -z "${_left_is_less:+x}" ] || // die 'what!!!' "should not appear"
			# [ -z "${_left_is_less:+x}" ] && {
			#   / "$riht_sublist_name=\"\${$riht_sublist_name-} $left\""
			#   / "// war '$riht_sublist_name' \"$(esceval \${$riht_sublist_name})\""
			#   right_list="$riht_sublist_name $@"
			#   break
			# } || {
				[ "${_left_is_less}" -eq "0" ] && {
					left_list="${left_list:+${left_list} }$riht_sublist_name"

					# / "${level}_list=\"\${${level}_list:+\"\${${level}_list} \"}$left_sublist_name\""

					# list_buffer="${list_buffer:+"${list_buffer} "}$left_sublist_name"
					# // war '$list_buffer' "$(esceval $list_buffer)"
				} || {
					right_list="$left_sublist_name $riht_sublist_name $@"
					located=0

					# / "${level}_list=\"$left_sublist_name\${${level}_list:+\" \${${level}_list}\"}\""

					# list_buffer="$left_sublist_name${list_buffer:+" ${list_buffer}"}"
					# // war '$list_buffer' "$(esceval $list_buffer)"
					break
				}
			# }
			: $((index += 1))
		done
		# Without this, the extremely less value will be leaked out for ever
		equ "$located" "0" ||
			right_list="${right_list:+${right_list} }$left_sublist_name"

		/ "${level_name}_list=\"${left_list:+${left_list} }$right_list\""

		# / "${level}_list=\"$list_buffer\""
		// debug_filter -- / "// war '${level_name}_list' \"\$(esceval \${${level_name}_list})\"" &
	}

	// log '$(($# + 1))' "$(($# + 1)) repos"
	// debug '$# in $@' "$# in${newline}$(esceval $@)"

	# "left" is a candidate repo of sub list
	for left do
		// debug_filter -- // log '$left' "$left" &
		triple_locate "major" "$left" $major_list || // die 'triple_locate' "failed"
		shift 1
	done

	// debug_filter -- // log '$major_list' "$(esceval $major_list)" &

	index=0
	for major_index in $major_list; do
		# major_index = [major_18]
		/ "set -- \${$major_index}"
		// debug_filter -- / "// log '$# in $major_index' \"$# in \$(esceval \${$major_index})\"" &
		is_repos "$1" || // die '$1' "'$1' is not a repo"
		repo_urn_plain_l="$(name_plain "$1")"
		# 0
		/ "minor_l=\"\${pkg_${repo_urn_plain_l}_minor}\""
		# major_18_0
		/ "${major_index}_minor_$minor_l=\"$1\""
		/ "minor_list=\"${major_index}_minor_$minor_l\""
		shift 1
		# "left" is a candidate of sub list
		for left do
			// debug_filter -- // log '$left' "$left" &
			/ "triple_locate \"${major_index}_minor\" \"$left\" $minor_list" ||
				// die 'triple_locate' "failed"
		done
		// debug_filter -- / "// log '$minor_list' \"\$(esceval $minor_list)\"" &

		for minor_index in $minor_list; do
			/ "set -- \${$minor_index}"
			# minor_index == major_18_minor_0
			// debug_filter -- / "// log '$# in $minor_index' \"$# in \$(esceval \${$minor_index})\"" &
			is_repos "$1" || // die '$1' "'$1' is not a repo"
			repo_urn_plain_l="$(name_plain "$1")"
			/ "patch_l=\"\${pkg_${repo_urn_plain_l}_patch}\""
			/ "${minor_index}_patch_$patch_l=\"$1\""
			/ "patch_list=\"${minor_index}_patch_$patch_l\""
			shift 1
			# "left" is a candidate of sub list
			for left do
				// debug_filter -- // log '$left' "$left" &
				triple_locate "${minor_index}_patch" "$left" $patch_list ||
				// die 'triple_locate' "failed"
			done
			// debug_filter -- // log '$patch_list' "$(esceval $patch_list)" &
			for patch_index in $patch_list; do
				/ "set -- \${$patch_index}"
				// debug_filter -- / "// log '$# in $patch_index' \"$# in \$(esceval \${$patch_index})\"" &
				is_repos "$1" || // die '$1' "'$1' is not a repo"
				repo_urn_plain_l="$(name_plain "$1")"
				/ "ident_l=\"\${pkg_${repo_urn_plain_l}_ident}\""
				/ "${patch_index}_ident_$ident_l=\"$1\""
				/ "ident_list=\"${patch_index}_ident_$ident_l\""
				shift 1
				# "left" is a candidate of sub list
				for left do
					// debug_filter -- // log '$left' "$left" &
					triple_locate "${patch_index}_ident" "$left" $ident_list ||
					// die 'triple_locate' "failed"
				done
				// debug_filter -- // log '$ident_list' "$(esceval $ident_list)" &
				for ident_index in $ident_list; do
					/ "set -- \${$ident_index}"
					// debug_filter -- / "// log '$# in $ident_index' \"$# in \$(esceval \${$ident_index})\"" &
					is_repos "$1" || // die '$1' "'$1' is not a repo"
					repo_urn_plain_l="$(name_plain "$1")"
					/ "suffix_l=\"\${pkg_${repo_urn_plain_l}_suffix}\""
					/ "${ident_index}_suffix_$suffix_l=\"$1\""
					/ "suffix_list=\"${ident_index}_suffix_$suffix_l\""
					shift 1
					# "left" is a candidate of sub list
					for left do
						// debug_filter -- // log '$left' "$left" &
						triple_locate "${ident_index}_suffix" "$left" $suffix_list ||
						// die 'triple_locate' "failed"
					done
					// debug_filter -- // log '$suffix_list' "$(esceval $suffix_list)" &
					for suffix_index in $suffix_list; do
						/ "set -- \${$suffix_index}"
						// debug_filter -- / "// log '$# in $suffix_index' \"$# in \$(esceval \${$suffix_index})\"" &
						is_repos "$1" || // die '$1' "'$1' is not a repo"
						repo_urn_plain_l="$(name_plain "$1")"
						/ "rel_l=\"\${pkg_${repo_urn_plain_l}_rel}\""
						/ "${suffix_index}_rel_$rel_l=\"$1\""
						/ "rel_list=\"${suffix_index}_rel_$rel_l\""
						shift 1
						# "left" is a candidate of sub list
						for left do
							// debug_filter -- // log '$left' "$left" &
							triple_locate "${suffix_index}_rel" "$left" $rel_list ||
							// die 'triple_locate' "failed"
						done
						// debug_filter -- // log '$rel_list' "$(esceval $rel_list)" &
						for rel_index in $rel_list; do
							/ "set -- \${$rel_index}"
							// debug_filter -- / "// log '$rel_index' \"\$(esceval \${$rel_index})\"" &
							for repo do
								is_repos "$repo" || // die '$repo' "'$repo' is not a repo"
								# repo_urn_plain_l="$(name_plain "$1")"
								equ "$index" "0" && printf "$RS%s" "$repo" ||
									printf "$FS%s" "$repo"
								// debug_filter -- // log '$index' "$index" & sort_id=$!
								// progress "$sort_id" "sorting"
								: $((index += 1))
							done
						done
					done
				done
			done
		done
	done

	for item in $abnormal_list; do
		printf "$FS%s" "$item"
	done

	(
	local end=`date +%s`
	local sort_time=$(expr $end - $start)
	// log '$sort_time' "$sort_time"
	) &

}

pkg_update() {
	_level_2
	# local explicit="$1"
	# shift 1
	local makedeps="$1"
	local deps="$2"
	shift 2
	// log "updating" "repositories"
	[ -n "${makedeps:+x}" ] && [ -n "${deps:+x}" ] &&
	set -- $makedeps $deps ||
	# Create a list of all repositories.
	# Intentional, globbing disabled.
	# shellcheck disable=2046,2086
	{
		local ifs="$IFS";
		local IFS=:;
		set +f;
		for item in $KISS_PATH; do
			[ ! -d "$item" ] || {
				IFS=$newline;
				for elem in $item/*; do
					set -- "$@" "$elem";
				done;
			}
		done;
		IFS="$ifs";
	}

	local top_dir_list=
	local repo_job_list=
	local repo=
	# Update each repository in '$KISS_PATH'.
	for repo do
		local top_dir
		local repo_name="${repo##*/}"
		local repo_target= target_source=
		# Current design, this function is coupled with installation, so no special location repo update
		# [ -n "${repo##*"${db}"*}" ] || repo_target="$repo"
		repo_target="$KISS_ROOT/$db/$repo_name"

		! is_model "$repo" "$repo_target" || target_source="$repo"

		[ -n "${target_source:+x}" ] || {

			local repo_dir= ver_target= rel_target= repo_alias= repo_url= reference_type=

			! // || / `pkg_version "$repo_name" "" "" "$KISS_ROOT/$db" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			END { print "repo_dir=\""$1"\"; ver_target=\""$2"\"; rel_target=\""$3"\"; \
			repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
			printf '%s\n' "return 1"`

			[ -d "$repo_dir/$repo_name" ] &&
			// is_model "$repo_target" "$repo_dir/$repo_name" &&
			target_source="$repo_dir/$repo_name" || {

				local repo_dir_source= ver_source= rel_source= alias_source= url_source= reference_type_source=

				! // || / `pkg_version "$repo_name" "mirror" |
					awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
				END { print "repo_dir_source=\""$1"\"; ver_source=\""$2"\"; rel_source=\""$3"\"; \
				alias_source=\""$4"\"; url_source=\""$5"\"; reference_type_source=\""$6"\"" }' ||
				printf '%s\n' "return 1"`

			}

			[ -n "${repo_dir_source:+x}" ] &&
			[ -d "$repo_dir_source/$repo_name" ] &&
			target_source="$repo_dir_source/$repo_name" || {
				// war '$repo' "'$repo' source not found, and update ignored"
				continue
			}
			[ -z "${repo##*"/"*}" ] || repo="$repo_dir_source/$repo_name"
		}
		// log '$repo' "$repo"
		// log '$repo_target' "$repo_target"
		// log '$target_source' "$target_source"
		local repo_type=
		# if git -C "$target_source" rev-parse 'HEAD@{upstream}' >/dev/null 2>&1; then
		if git -C "$target_source" rev-parse 'HEAD' >/dev/null 2>&1; then
			repo_type="git"

			# Get the Git repository root directory.
			local subm="$(git -C "$target_source" rev-parse --show-superproject-working-tree)"
			top_dir="$(git -C "${subm:-"$target_source"}" rev-parse --show-toplevel)"

			(IFS="$newline" && list_contains "$top_dir" $top_dir_list) ||
				top_dir_list="${top_dir_list:+"${top_dir_list}$newline"}$top_dir"

			(IFS="$newline" && list_contains "$target_source" $repo_job_list) ||
				repo_job_list="${repo_job_list:+"${repo_job_list}$newline"}$target_source"

		elif [ ! -d "$repo_target" ]; then
			// war '$repo_target' "'$repo_target' is not installed"
			continue
		else
			# For -u shell option, we don't want to unset
			# unset repo_type
			{ [ -n "${ver_source:+x}" ] && [ -n "${rel_source:+x}" ]; } || {

				local repo_dir_source= ver_source= rel_source= alias_source= url_source= reference_type_source=

				! // || / `pkg_version "$repo_name" "mirror" |
					awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
				END { print "repo_dir_source=\""$1"\"; ver_source=\""$2"\"; rel_source=\""$3"\"; \
				alias_source=\""$4"\"; url_source=\""$5"\"; reference_type_source=\""$6"\"" }' ||
				printf '%s\n' "return 1"`
			}

			! is_version "$ver_target" || ! is_version "$rel_target" ||
			! is_version "$ver_source" || ! is_version "$rel_source" || {
				local _left_is_less="$(// left_is_less \
				"$repo_name" "$ver_target-$rel_target" "$ver_source-$rel_source")"
				[ -z "$_left_is_less" ] ||
				equ "$_left_is_less" "0" ||
				continue
			}
		fi

		[ "$repo_type" = "git" ] ||
		// pkg_update_repo "$target_source"
	done

	local top_dir
	for top_dir in $top_dir_list; do
		// pkg_update_git "$top_dir"
	done

	# local target_source
	# for target_source in $repo_job_list; do
	#   // pkg_update_repo "$target_source"
	# done

	// pkg_upgrade
}

# $1 repo
# [ -z "${KEEP_DEPRECATED+x}" ] ||
pkg_update_repo() {
	_level_2
	# local repo_type="$1"
	local repo="$1"
	cd "$repo" || // die '$repo' "${repo:+"'${repo}' "}repository inaccessible"

	local repos=
	contains "$repos" "$PWD" || {
		repos="${repos:+"${repos} "}$PWD"

		// log '$PWD' "$PWD"

		# equ "pwd_user" "$LOGNAME" || {
		#   // log 'needs to update from "$user" to' "$pwd_user"
		#   set -- $(// delegate -- as_user "$pwd_user")
		# }
		set --
		local repo_owner="$(// delegate owner "$REPO_ROOT_IMPL")"
		[ "$LOGNAME" = "$repo_owner" ] ||
			set -- "$(// delegate as_user $repo_owner)"

		# arg1: pre-update
		# arg2: need su?
		# arg3: owner
		# env:  PWD is path to repository
		// run_hook pre-update "$#" "$repo_owner"

		// pick_up "$PWD"

		# arg1: post-update
		# env:  PWD is path to repository
		// run_hook post-update
	}
}

pkg_update_git() {
	_level_2
	local repo="$1"
	cd "$repo" || // die '$repo' "${repo:+"'${repo}' "}repository inaccessible"
	// log '$PWD' "$PWD"

	# equ "pwd_user" "$LOGNAME" || {
	#   // log 'needs to update from "$user" to' "$pwd_user"
	#   set -- $(// delegate -- as_user "$pwd_user")
	# }

	set --
	local repo_owner="$(// delegate owner "$REPO_ROOT_IMPL")"
	[ "$LOGNAME" = "$repo_owner" ] ||
	set -- "$(// delegate as_user $repo_owner)"

	# arg1: pre-update
	# arg2: need su?
	# arg3: owner
	# env:  PWD is path to repository
	// run_hook pre-update "$#" "$repo_owner"

	# Display whether or not signature verification is enabled.
	case $("$@" git config --get merge.verifySignatures) in true)
		// war 'signature verification" "enabled'
	esac

	"$@" git pull
	"$@" git submodule update --remote --init -f

	// pick_up "$PWD"

	# arg1: post-update
	# env:  PWD is path to repository
	// run_hook post-update
}

pkg_upgrade() {
	_level_2
	# local explicit="$1"
	# shift 1
	# local makedeps="$1"
	# local deps="$2"
	# shift 2

	local action="upgrade"

	// log "versions" "checking for new package"
	set +f

	local repo_orphans

	for repo_name in "$KISS_ROOT/$db/"*; do set -f
		// pkg_dirs "$action" "$repo_name"
		// pkg_clear "$action" "$repo_urn"


		local repo_dir_pre= ver_pre= rel_pre= alias_pre= url_pre= reference_type_pre=

		! // || / `pkg_version "${repo_name##*/}" "" "" "$KISS_ROOT/$db" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "repo_dir_pre=\""$1"\"; ver_pre=\""$2"\"; rel_pre=\""$3"\"; \
		alias_pre=\""$4"\"; url_pre=\""$5"\"; reference_type_pre=\""$6"\"" }' ||
		printf '%s\n' "return 1"`

		# Detect repository orphans (installed packages with no
		# associated repository).
		case $repo_dir_pre in *"$sys_db/"*)
			repo_orphans="$repo_orphans$newline${repo_name##*/}"
		esac

		local repo_dir= repo_ver= repo_rel= repo_alias= repo_url= reference_type=

		! // || / `pkg_version "${repo_name##*/}" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "repo_dir=\""$1"\"; repo_ver=\""$2"\"; repo_rel=\""$3"\"; \
		repo_alias=\""$4"\"; repo_url=\""$5"\"; reference_type=\""$6"\"" }' ||
		printf '%s\n' "return 1"`

		# Compare installed packages to repository packages.
		equ "$ver_pre-$rel_pre" "$repo_ver-$repo_rel" || {
			set -- "$@" "${repo_name##*/}"

			// log "${repo_name##*/}" "$ver_pre-$rel_pre => $repo_ver-$repo_rel"
		}
	done

	case "$repo_orphans" in *"?"*)
		// war '$repo_orphans packages without repository' "$(esceval $repo_orphans)"
	esac

	local install_on_build=""
	PREFER_CACHE=

	# ! contains "$*" kiss || {
	[ -z "$(// delegate filter_contains "key_filter" "kiss" "$@")" ] || {
		// log "package manager update" "detected"
		// log "the package manager" "will be updated first"

		# // prompt "content" "Upgrade kiss first"
		local content="$(// delegate -- prompt "Upgrade kiss first")"
		! expr "$content" : '[n|N]\+' > /dev/null || return 0

		# // build_all "kiss" "$makedeps" "$deps"
		// pick_up "kiss"

		// log "the package manager" "updated"
		// log "re-run 'kiss update'" "to update your system"
		return 0
	}

	for _ do
		local explicit
		! // || / `pkg_order "$*" |
			awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
		END { print "explicit=\""$1"\"; makedeps=\""$2"\"; deps=\""$3"\"; \
		order=\""$4"\"; redro=\""$5"\"" }' ||
		printf '%s\n' "return 1"`


		# Intentional, globbing disabled.
		# shellcheck disable=2046,2086
		# set -- $order
		set -- $makedeps $deps

		# // prompt "content" "Packages to update ($#): $*"
		local content="$(// delegate -- prompt "Packages to update ($#): $*")"
		! expr "$content" : '[n|N]\+' > /dev/null || continue

		// build_all "$explicit" "$makedeps" "$deps" ||
		// die '$explicit $makedeps $deps' "'$explicit' '$makedeps' '$deps' build_all failed"

		# for repo_urn in $@; do // pkg_install "$repo_urn"; done
		// alter "install" "$@" 2>&1 ||
			// die 'install failed' "$(esceval "$@")"
		// log "all packages" "updated"
		return 0
	done
	set -f
	// log "nothing" "to do"
}

# $1 action
# $2 repo_name_00
# $3 repo_name_01
# ...
# Claen all? "$@" might has multiple packages
clean_all() {
	_level_2
	# Clean up on exit or error. This removes everything related to the build.
	# If _KISS_LVL is (0) we are on the bottom-level process - the entire cache will
	# be removed. If _KISS_LVL is any other value, remove only the tar directory.

	local action="${1-}"
	shift "$(($# >= 1? 1 : $#))"
	# Second parameter is index
	! is_pick "$action" || set -- "$1"

	for repo_urn do
		local repo_name="${repo_urn##*/}"
		repo_name="${repo_name%%@*}"
		[ -n "${repo_name:+x}" ] || // die '$repo_name' "\"$repo_name\" is wrong calculated"
		# https://stackoverflow.com/questions/32107041/how-to-check-if-a-string-only-contains-digits-numerical-characters
		# [ $(expr "x$repo_name" : "x[0-9]*$") -gt 0 ] || continue
		// log '$action' "$action"
		// log '$repo_name' "$repo_name"
		[ -d "$PROC_ROOT" ] || // die '$PROC_ROOT' "$PROC_ROOT"
		// debug '$EXTRACT_ROOT' "$EXTRACT_ROOT"
		// debug '$KISS_DEBUG' "${KISS_DEBUG-}"
		// debug '$_KISS_LVL' "$_KISS_LVL"

		case $action in
			i|install)
				local log_dir="$cache_dir/logs/$repo_name"
				[ -d "$log_dir" ] || \mkdir -p "$log_dir"
				local log_target="$log_dir/build.log"
				: > "$log_target"
				# log_dumped "$log_target" ||
				// log_shift "$log_target" "$user_output"
		esac
		local extract_dir="$EXTRACT_ROOT/$repo_name"
		case ${KISS_DEBUG-}-${_KISS_LVL:-0} in
			-0) [ -z "${PROC_ROOT:+x}" ] || [ "$(standardize "$PROC_ROOT")" = "/proc" ] ||
				// pkg_clear "$action" "$repo_urn" ;;
			-*) [ -z "${EXTRACT_ROOT:+x}" ] || [ "$EXTRACT_ROOT" = "/" ] ||
				[ "$(// delegate -- occurrences "$EXTRACT_ROOT" "/")" -le "1" ] ||
				[ "$(// delegate -- occurrences "$extract_dir" "/")" -le "1" ] ||
				[ ! -d "$extract_dir" ] || [ "$EXTRACT_ROOT" = "/extract" ] ||
				# // as_own "$EXTRACT_ROOT" find "$EXTRACT_ROOT/$repo_name" -mindepth 1 -delete
				for item in $(// as_own "$EXTRACT_ROOT" \
					find "$extract_dir" -mindepth 1); do
					# choices folder items won't accept removing by normal users even it's is owned by the normal user
					// as_usr "root" \rm -rf "$item"; done
		esac
	done
	sync
}

# "$@" :
pkg_help_ext() {
	_level_2
	// debug '$#' "$#"
	// log 'extensions (kiss-*) in' "$(echo $PATH | sed 's/:/\n/g')"
	# // log 'extensions (kiss-*) in $PATH'
	local IFS="$IFS_ORIGIN"
	# set +f
	# local ifs="$IFS"
	# local IFS="$RS"
	# set -- "$@" $(// delegate "$RS" repo_trace "kiss-*" "all" -x "$PATH")
	local list_pre="$(// repo_trace "kiss-*" "all" -x "$PATH")"
	set -- "$@" ${list_pre##*'$RS'}
	# set -- "$@" $(// repo_trace "kiss-*" "all" -x "$PATH")
	// debug '$#' "$#"
	# IFS="$ifs"

	# Intentional, globbing disabled.
	# shellcheck disable=2046,2030,2031
#   while read -r item; do
#       // debug '$item' "$item"
#       set -- "$@" "$item"
#   done << EOF || :
# $(// repo_trace "kiss-*" "all" -x "$PATH")
# EOF
# $(// repo_trace kiss-* "" -x "$PATH")
	// debug '$#' "$#"
	// debug_filter -- // debug '$@' "$(esceval "$@")"
	# ok "$1" || // die 'kiss-*' "$1"

	set +f
	local path
	local path_list=
	local seen=
	# To align descriptions figure out which extension has the longest
	# name by doing a simple 'name > max ? name : max' on the basename
	# of the path with 'kiss-' stripped as well.
	#
	# This also removes any duplicates found in '$PATH', picking the
	# first match.
	for path do
		p="${path#*/kiss-}"
		# pick up files only
		[ ! -d "$path" ] || continue
		// debug '$path' "$path"

		case " $seen " in *" $p "*)
			shift
			continue
			;;
			*) path_list="${path_list:+"${path_list}${newline}"}$path"
		esac

		seen=" $seen $p "
		max="$((${#p} > max ? ${#p}+1 : max))"
	done
	# local ifs="$IFS"
	set -- $path_list
	# local IFS="$newline" set -- $path_list
	# [ "$ifs" = "$IFS" ] || // die '$IFS' "permanently changed"
	// log '$#' "$#"
	// debug_filter -- // debug '$@' "$(esceval "$@")"

	local ifs="$IFS"
	local IFS=\#$IFS

	# Print each extension, grab its description from the second line
	# in the file and align the output based on the above max.
	for path do
		[ ! -z "${path:+x}" ] || continue
		# // log '$path' "$path"
		# path="$(readlink -fn "$path")"
		# realpath can print special characters
		# path="$(realpath "$path")"
		// debug_filter -- // debug '$path' "$path"
		# Open the extension as a file descriptor.
		# exec 3< "$(readlink -fn $path)"
		exec 3< "$path"

		# Grab the second line in the extension.
		{ read -r _ && IFS=\#$IFS read -r _ cmt; } <&3

		# printf "%b->%b %-${max}s %s\\n" "$color_parent" "$color_end" "${path#*/kiss-}" "$cmt"
		// log "${path#*/kiss-}" "$cmt"
	done >&2
	IFS="$ifs"
	set -f
}

trap_on() {
	# _level_0
	# Catch errors and ensure that build files and directories are cleaned
	# up before we die. This occurs on 'Ctrl-C' as well as success and error.
	# trap on_int INT TERM QUIT
	# exec 2>"$ERR_OUTPUT"
	[ -z "${KISS_INNER_PIPE+x}" ] || listen "on_int"
	# trap '// on_int' INT TERM
	trap "// on_exit $KILL_LIST" EXIT
}

on_int() {
	# _level_0
	export KISS_DEBUG=
	// run_hook SIGINT
	exit 1
}

on_exit() {
	# _level_0
	# export KISS_DEBUG=
	# For debugging, we might don't want to delete the crime scene immediately
	# // clean_all "$@"
	// run_hook SIGEXIT
	[ -z "${KISS_INNER_PIPE:+x}" ] || // clean
}

trap_off() {
	_level_0
	# Block being able to abort the script with 'Ctrl-C'. Removes all risk of
	# the user aborting a package install/removal leaving an incomplete package
	# installed.
	trap > "/tmp/${LOGNAME}/trap.txt"
	local sig
	for sig in $( \
			awk 'BEGIN{ RS = "\n"; FS = " " }{print $NF}' \
				< "/tmp/${LOGNAME}/trap.txt")
	do
		// log '$sig' "$sig"
		[ "$sig" != "EXIT" ] && [ "$sig" != "ERR" ] || continue
		// war '$sig' "$(delegate -- format "$sig") is going to be cleared"
		trap '' $sig
	done
	# Will ruin read_line()
	# trap "" INT TERM QUIT PIPE EXIT
}

share_link() {
	_level_2
	[ "$#" -ge "5" ] || // die '$#' "input arguments $# less than 5"
	local body_root_name="$1"
	local anchor_root_name="$2"
	local parent_dir="$3"
	local parent_user="$(// delegate -- owner "$parent_dir")"
	local cache_dir="$4"
	local anchor_folder="$5"

	/ ": \"\${$body_root_name:=\"$parent_dir/$anchor_folder\"}\""
	# / "true \"\${$body_root_name:=\"$parent_dir/$anchor_folder\"}\""
	# / "$body_root_name=\"$parent_dir/$anchor_folder\""
	# local body_root_value="$(/ "printf '%s' \"\$$body_root_name\"")"
	/ "local body_root_value=\$$body_root_name"
	#                   name            value
	// log "$O $body_root_name" "$body_root_value"
	[ "$body_root_value" = "$parent_dir/$anchor_folder" ] ||
	// die "$body_root_name" "$body_root_value"

	[ -d "$body_root_value" ] ||
		// as_usr "$parent_user" /usr/bin/mkdir -p "$body_root_value" ||
		// die 'mkdir' "'$body_root_value' failed"

	/ "$anchor_root_name=\"$cache_dir/$anchor_folder\""
	# local anchor_root_value="$(/ "printf '%s' \"\$$anchor_root_name\"")"
	/ "local anchor_root_value=\$$anchor_root_name"
	#                   name            value
	// log "$I $anchor_root_name" "$anchor_root_value"
	[ "$anchor_root_value" = "$cache_dir/$anchor_folder" ] ||
	// die "$anchor_root_name" "$anchor_root_value"

	{
		[ -L "$anchor_root_value" ] &&
		[ "$body_root_value" = "$(readlink -f "$anchor_root_value")" ]
	} || {
		# Is false link       Is real dir
		[ ! -d "$anchor_root_value" ] || [ -L "$anchor_root_value" ] || {
			# Is real dir
			[ "$(stat -c '%U' "$anchor_root_value")" = "$parent_user" ] ||
			// as_usr "root" /usr/bin/chown -R "$parent_user":users "$anchor_root_value" ||
			// die 'chown' "'$anchor_root_value' failed"

			// as_usr "$parent_user" /usr/bin/rsync -aqz "$anchor_root_value/." "$body_root_value/"
			// as_usr "$parent_user" sync
		}
		{ [ ! -d "$anchor_root_value" ] && [ ! -L "$anchor_root_value" ]; } ||
		// as_usr "root" /usr/bin/rm -rf "$anchor_root_value" ||
		// die 'rm -rf' "'$anchor_root_value' failed"
		ln -sf "$body_root_value" "$anchor_root_value"
	}

	/ "$anchor_root_name=\"$body_root_value\""
}

# package is git or not
# Usage
# local format="$(// delegate -- pkg_format "$repo_urn")"
# The following design is deprecated, because performance
# and problematic info it got if it's not a forcing remote update
pkg_format() {
	_level_2
	local repo_urn="$1"
	// debug '$repo_urn' "$repo_urn"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"
	is_repos "$repo_urn" ||
		repo_urn="$(// delegate -- repo_trace "$repo_name")"

	local format=
	# local reference_type=

	// debug '$repo_name' "$repo_name"
	case "$repo_name" in
		*.tar|*.tar.??|*.tar.???|*.tar.????|*.t?z|*.zip)
			local src_name="${repo_name##*/}"
			src_name="${src_name%\?*}"
			format="${src_name##*.}"
			printf "$RS%s" "$format"
			return 0
	esac

	[ "$scope" != "local_route" ] || { printf "$RS%s" "$format"; return 0; }

	[ ! -f  "$repo_urn/sources" ] ||
	while read -r src_url dest || ok "${src_url%%\#*}"; do
		ok "${src_url%%\#*}" || continue

		local key="${repo_name%%-*}"
		null "${src_url##*"$key"*}" || continue

		// debug '$src_url' "$src_url"
		// debug '$dest' "$dest"
		case $src_url in
			"git+"*)
				[ -n "${src_url##*"$key"*}" ] || {
					format="git"
				} ;;

			*"://"*)
				local src_name="${src_url##*/}"
				src_name="${src_name%\?*}"
				format="${src_name##*.}" ;;

			*)
				local src_name="${src_url##*/}"
				src_name="${src_name%\?*}"
				[ -n "${src_url##*"$key"*}" ] || {
					format="${src_name##*.}"
				} ;;
		esac
		# Use the first element
		break
	done < "$repo_urn/sources"

	// debug '$format' "$format"

	printf "$RS%s" "$format"
}

[ -z "${KEEP_DEPRECATED+x}" ] ||
# Deprecated
repo_resolve() {
	_level_2
	local repo_name
	local repo_urn="$1"
	[ -n "${repo_urn:+x}" ] || // die '$repo_urn' "\"$repo_urn\" is invalid"
	// debug '$repo_urn' "$repo_urn"
	local search_dir="$2"
	// debug '$search_dir' "$search_dir"
	repo_urn="$(standardize "$repo_urn")"
	repo_name="${repo_urn##*/}"
	// debug '$repo_name' "$repo_name"

	[ "$scope" != "repo_trace" ] || { printf "$RS%s$FS%s$FS%s" "$repo_name" "" ""; return 0; }

	local repo_dir
	local repo_urn_output

	[ -n "${repo_urn##*"/"*}" ] ||
	[ ! -d "${repo_urn}" ] ||
	! command -v "$repo_urn/build" > /dev/null 2>&1 ||
	[ ! -f "$repo_urn/version" ] ||
	[ ! -f "$repo_urn/sources" ] ||
	{
		repo_dir="${repo_urn%/*}"
		repo_urn_output="$repo_urn"
		printf "$RS%s$FS%s$FS%s" "$repo_name" "$repo_dir" "$repo_urn_output"
		return 0
	}

	[ -n "${repo_dir:+x}" ] ||
	null "$search_dir" || {
		[ -z "${search_dir##*:*}" ] ||
		[ ! -d "$search_dir/$repo_name" ] || {
			repo_dir="$search_dir"
			repo_urn_output="$repo_dir/$repo_name"
			printf "$RS%s$FS%s$FS%s" "$repo_name" "$repo_dir" "$repo_urn_output"
			return 0
		}

		[ -n "${repo_dir:+x}" ] || {
			# repo_trace will search $sys_db also
			repo_urn_output="$(// delegate -- repo_trace "$repo_name" "" "-d" "$search_dir")"
			repo_dir="${repo_urn_output%/*}"
			printf "$RS%s$FS%s$FS%s" "$repo_name" "$repo_dir" "$repo_urn_output"
			return 0
		}
	}

	[ -n "${repo_dir:+x}" ] ||
	[ -z "${REPO_DIR:+x}" ] ||
	[ ! -d "$REPO_DIR/$repo_name" ] || {
		// debug '$REPO_DIR' "$REPO_DIR"
		repo_dir="$REPO_DIR"
		repo_urn_output="$repo_dir/$repo_name"
		printf "$RS%s$FS%s$FS%s" "$repo_name" "$repo_dir" "$repo_urn_output"
		return 0
	}

	# [ -n "${repo_dir:+x}" ] ||
	# [ -z "${KISS_PATH##*:*}" ] ||
	# [ ! -d "$KISS_PATH/$repo_name" ] || {
	#     // debug '$KISS_PATH' "$KISS_PATH"
	#     repo_dir="$KISS_PATH"
	# }

	[ -n "${repo_dir:+x}" ] || {
		# repo_trace will search $sys_db also
		repo_urn_output="$(// delegate -- repo_trace "$repo_name" "" "-d" "$KISS_PATH")"
		repo_dir="${repo_urn_output%/*}"
		printf "$RS%s$FS%s$FS%s" "$repo_name" "$repo_dir" "$repo_urn_output"
		return 0
	}

	[ -z "${repo_dir:+x}" ] ||
	[ -n "${repo_urn_output:+x}" ] || repo_urn_output="$repo_dir/$repo_name"

	// debug '$repo_dir' "$repo_dir"
	// debug '$repo_urn_output' "$repo_urn_output"

	printf "$RS%s$FS%s$FS%s" "$repo_name" "$repo_dir" "$repo_urn_output"
}

[ -z "${KEEP_DEPRECATED+x}" ] ||
# Deprecated
# Pay attention to name overriding (use local keyword as much as possible)
# When there is an upper-scope variable has the same name with the current
# scope variable, and in the current scope it was defined as local variable,
# the upper-scope variable will not be modiffied
repo_resolve_no_subshell() {
	_level_2
	[ "$1" = "_" ] || [ -z "$1" ] || local repo_name_name="${1#*" "}"
	local repo_urn="$2"
	[ -n "${repo_urn:+x}" ] || // die '$repo_urn' "\"$repo_urn\" is invalid"
	// debug '$repo_urn' "$repo_urn"

	repo_urn="$(standardize "$repo_urn")"
	local repo_name_value="${repo_urn##*/}"
	# // log '$repo_name_value' "$repo_name_value"
	[ -z "${repo_name_name:+x}" ] || {
		/ "$repo_name_name=\"$repo_name_value\""
		/ debug "$repo_name_name" "\"\$$repo_name_name\""
	}

	[ "$scope" != "repo_trace" ] || return 0

	[ "$3" = "_" ] || [ -z "$3" ] || local repo_dir_name="$3"
	[ "$4" = "_" ] || [ -z "$4" ] || local repo_urn_name="$4"

	[ -n "${repo_dir_name:+x}" ] || [ -n "${repo_urn_name:+x}" ] || return 0

	[ -z "${repo_dir_name:+x}" ] ||
	/ "local repo_dir_value=\"\$$repo_dir_name\""
	[ -z "${repo_urn_name:+x}" ] ||
	/ "local repo_urn_value=\"\$$repo_urn_name\""

	if [ -z "${repo_urn##*"/"*}" ] && [ -d "${repo_urn}" ]; then
		{ [ -z "${repo_dir_name:+x}" ] && [ -z "${repo_urn_name:+x}" ]; } ||
		local repo_dir_value="${repo_urn%/*}"
		[ -z "${repo_urn_name:+x}" ] || local repo_urn_value="$repo_urn"
	else
		{ [ -z "${repo_dir_name:+x}" ] && [ -z "${repo_urn_name:+x}" ]; } || {

			# [ -n "${repo_dir_value:+x}" ] ||
			# [ -z "${REPO_DIR:+x}" ] || {
			#     // log '$REPO_DIR' "$REPO_DIR"
			#     local repo_dir_value="$REPO_DIR"
			# }

			# [ -n "${repo_dir_value:+x}" ] ||
			# [ -z "${KISS_PATH##*:*}" ] ||
			# [ ! -d "$KISS_PATH/$repo_name_value" ] || {
			#     // log '$KISS_PATH' "$KISS_PATH"
			#     local repo_dir_value="$KISS_PATH"
			# }

			[ -n "${repo_dir_value:+x}" ] || {
				// repo_urn_value="$(// delegate -- repo_trace \
						"$repo_name_value" "" "-d" "$KISS_PATH")"
				local repo_dir_value="${repo_urn_value%/*}"
			}
		}
		[ -z "${repo_urn_name:+x}" ] ||
		local repo_urn_value="$repo_dir_value/$repo_name_value"
	fi
	[ -z "${repo_dir_name:+x}" ] || {
		// log '$repo_dir_value' "$repo_dir_value"
		/ "$repo_dir_name=\"$repo_dir_value\""
	}
	[ -z "${repo_urn_name:+x}" ] || {
		// log '$repo_urn_value' "$repo_urn_value"
		/ "$repo_urn_name=\"$repo_urn_value\""
	}
}

ccache_pkg() {
	local repo_name="$1"
	case "$cmd_cache" in
		*"ccache")
			# $cmd_cache --max-size 16GB --set-config base_dir=${DESTDIR} hash_dir=false "$@"
			$cmd_cache --max-size "${CCACHE_MAX_SIZE:-"16GB"}" \
				--set-config base_dir=${CCACHE_BASEDIR:="$CCACHE_ROOT/$repo_name"} \
				--set-config hash_dir=false
	esac
}

ccache_global() {
	local ccache_root="$1"
	case "$cmd_cache" in
		*"ccache")

			{
				{
					[ -z "${CCACHE_NOHASHDIR+x}" ]   && [ -z "${CCACHE_HASHDIR+x}" ]
				} || {
					[ ! -z "${CCACHE_NOHASHDIR+x}" ] && [ ! -z "${CCACHE_HASHDIR+x}" ]
				}
			} && CCACHE_HASHDIR=

			{
				[ ! -z "${CCACHE_NOHASHDIR+x}" ] && [ -z "${CCACHE_HASHDIR+x}" ]
			} && {
				: ${CCACHE_NOHASHDIR:=}  && export CCACHE_NOHASHDIR
			} || {
				: ${CCACHE_HASHDIR:=}    && export CCACHE_HASHDIR
			}

			: ${CCACHE_COMPILERCHECK:=content}  && export CCACHE_COMPILERCHECK

			: ${CCACHE_CPP2:=}                  && export CCACHE_CPP2

			: ${CCACHE_INODECACHE:=}            && export CCACHE_INODECACHE

			# CCACHE_BASEDIR:="$ccache_root" will create $repo_name.tmp.* under $ccache_root
			# $cmd_cache --max-size 16GB --set-config base_dir=${DESTDIR} hash_dir=false "$@"
			# $cmd_cache --max-size "${CCACHE_MAX_SIZE:-"16GB"}" \
			#   --set-config base_dir=${CCACHE_BASEDIR:="$ccache_root"} \
			#   --set-config hash_dir=false
	esac
}

# File Hierarchy
#
#  VOLATILE          DEST_ROOT:/working/kiss          db_root:var/db/kiss
#     |                      |                               |
#     |             ______________________           _______________________
#     |             |        |           |           |       |      |      |
#     |         SRC_ROOT ARCHIVE_ROOT PROC_ROOT  REPO_ROOT sys_db choices hooks
#     |                                  |
#     |___________________           ____|_______________________
#     |         |        |           |         |       |        |
# MAKE_ROOT TEMP_ROOT OBJ_ROOT PKG_ROOT EXTRACT_ROOT BIN_ROOT TAR_ROOT
# sys_db ("var/db/installed" based on $KISS_ROOT is the only thing the target
# machine is supposed to get)
init_dirs() {
	local level=0
	[ "$level" -eq "-1" ] ||
	_level_2
	local ppwd="$1"
	shift 1

	# Environment and development
	#
	# Defined in ${LAYOUT_INIT:="/etc/profile.d/share"}
	# MNGR_ROOT  -- package manager root (where this file comes from, optional, for developers)
	#
	# Maintained in $LAYOUT_INIT and kiss-env
	# REPO_ROOT_IMPL -- package repositories root (could be symbol link, readonly except git repo package version updating)
	# Should inside pick_up's searching $KISS_PATH
	#
	# Defined in $LAYOUT_INIT
	# DEST_ROOT  -- package building stages resource root (heavily reading/writting)
	#
	# Defined by kiss manager users like
	# KISS_ROOT=/opt/kiss BOOTSTRAP= kiss
	# KISS_ROOT means TARGET_ROOT, (XHOST_ROOT by Glasnost Linux)
	#
	# Target system
	#
	# Defined in $LAYOUT_INIT
	# REPO_ROOT/db_root -- package deployment configuration root (what target machine should know)
	cmd_mkdir="$(which mkdir)"
	[ -z "${MNGR_ROOT:+x}" ] || // log '$MNGR_ROOT' "$MNGR_ROOT"
	: "${REPO_ROOT_IMPL:?"KISS requires REPO_ROOT_IMPL be set"}" && export REPO_ROOT_IMPL
	// log '$REPO_ROOT_IMPL' "$REPO_ROOT_IMPL"

	# Thinking about DESTDIR
	: "${DEST_ROOT:?"KISS requires DEST_ROOT be set (prefer a normal user's share folder)"}"
	// debug '$DEST_ROOT' "$DEST_ROOT" &
	DEST_ROOT="$(standardize "$DEST_ROOT")" && export DEST_ROOT

	// debug '$DEST_ROOT' "$DEST_ROOT" &
	[ -d "$DEST_ROOT" ] || {
		local des_parent="${DEST_ROOT%/*}"
		[ "$des_parent" != "/" ] || des_parent="/working/kiss"
		// as_own "$des_parent" $cmd_mkdir -p "$DEST_ROOT"
	}

	[ -n "${des_user:+x}" ] ||
	des_user="$(stat -c '%U' "$(readlink -f "$DEST_ROOT")")"

	# proc_volatile="$KISS_TMPDIR/proc"
	: ${VOLATILE:="$KISS_TMPDIR"} && export VOLATILE
	[ -d "$VOLATILE" ] || $cmd_mkdir -p "$VOLATILE"

	# Move to user_log::$SESSION_PPID
	# // cue 'New session' "started at $KISS_PID"

	# Root directory standardization
	# KISS_ROOT means TARGET_ROOT, XHOST_ROOT
	KISS_ROOT=${KISS_ROOT%"${KISS_ROOT##*[!/]}"} && export KISS_ROOT
	kiss_root_user="$(// delegate -- owner "$KISS_ROOT/root")"
	# This allows for automatic setup of a KISS chroot and will
	# do nothing on a normal system.
	[ -d "$KISS_ROOT/" ] ||
		// as_own "$KISS_ROOT/" $cmd_mkdir -p "$KISS_ROOT/" 2>/dev/null || :

	# System package database root -- a formal path, not must a real path
	# But, it might be written in version files. So make it work
	# "/var/db/kiss"
	: "${REPO_ROOT:="/var/db/kiss"}" && export REPO_ROOT
	# For history compatibility ?
	# "var/db/kiss"
	: "${db_root:="${REPO_ROOT#*/}"}" && export db_root
	# : "${db_root:="/var/db"}" && export db_root
	[ -d "$KISS_ROOT/$db_root" ] ||
		# // die '$REPO_ROOT' "'$REPO_ROOT' does not exist"
		// as_own "$KISS_ROOT/" $cmd_mkdir -p "$KISS_ROOT/$db_root"


	# For kiss usage, not final addresses
	# "var/db/kiss/installed"
	: "${db:="$db_root/installed"}"
	# "/var/db/installed"
	: "${sys_db:="/${db}"}"
	[ -d "$KISS_ROOT/$db" ] || // as_own "$KISS_ROOT/" $cmd_mkdir -p "$KISS_ROOT/$db"

	# From this location isolation, we can keep kiss independent to deployed machines
	KISS_REPO="$(readlink -fn "$KISS_ROOT/$REPO_ROOT/main")" && export KISS_REPO
	[ -d "$KISS_REPO" ] || {
		# Link to local development repo root
		# Actually it is a recommended way to avoid maintaining a seperate repo
		# Arbitrary folder name, and maintained in kiss-env
		local real_repo_main="$REPO_ROOT_IMPL/${KISS_REPO##*/}"
		[ -e "$real_repo_main" ] ||
			// die '$real_repo_main' "'$real_repo_main' does not exist${newline}\
			and you should better maintain it manually"

		// as_own "$KISS_ROOT/" \ln -sf "$real_repo_main" "$KISS_ROOT/${REPO_ROOT}/main"
	}

	// log '$KISS_REPO' "$KISS_REPO"
	# For kiss usage, not final addresses
	# "var/db/choices"
	: "${cho_db:="$db_root/choices"}"
	# "$KISS_ROOT/var/db/choices"
	: "${sys_ch:="/${cho_db}"}"
	[ -d "$sys_ch" ] ||
	[ -L "$sys_ch" ] || {
		[ -e "$REPO_ROOT_IMPL/choices" ] ||
		// as_own "$REPO_ROOT_IMPL/" $cmd_mkdir -p "$REPO_ROOT_IMPL/choices"

		// as_own "$KISS_ROOT/" \ln -sf "$REPO_ROOT_IMPL/choices" "$KISS_ROOT/${REPO_ROOT}/"
		# // as_own "$KISS_ROOT/" \mkdir -p "$sys_ch"
	}

	# For kiss usage, not final addresses
	# "var/db/hooks"
	: "${hook_db:="$db_root/hooks"}"
	: "${sys_hk:="/${hook_db}"}"
	[ -d "$sys_hk" ] ||
	[ -L "$sys_hk" ] || {
		[ -e "$REPO_ROOT_IMPL/hooks" ] ||
		// as_own "$REPO_ROOT_IMPL/" $cmd_mkdir -p "$REPO_ROOT_IMPL/hooks"

		// as_own "$KISS_ROOT/" \ln -sf "$REPO_ROOT_IMPL/hooks" "$KISS_ROOT/${REPO_ROOT}/"
	}

	# For kiss usage, not final addresses
	// log '$db' "$db"
	// log '$cho_db' "$cho_db"

	// log '$hook_db' "$hook_db"

	[ -n "${KISS_REPO:+x}" ] ||
	{ [ "$action" != "i" ] && [ "$action" != "install" ]; } ||
	// die '$KISS_REPO' "'$KISS_REPO' should be defined for reverse copying${newline}\
	$KISS_ROOT/$db/repo to the main repo during installation"

	# Top-level cache directory.
	cache_home=${XDG_CACHE_HOME:-"${HOME%"${HOME##*[!/]}"}/.cache"}
	cache_dir=${cache_home%"${cache_home##*[!/]}"}/kiss
	[ -d "$cache_dir" ] || $cmd_mkdir -p "$cache_dir"
	cache_user="$(stat -c '%U' "$cache_dir")"

	# : "${share_src:="$DEST_ROOT/sources"}"
	// share_link "share_src" "SRC_ROOT" "$DEST_ROOT" "$cache_dir" "sources"

	[ -n "${SRC_USER:+x}" ] ||
	SRC_USER="$(stat -c '%U' "$(readlink -f "${SRC_ROOT}")")"
	export SRC_USER
	readonly SRC_USER

	# : "${share_proc:="$DEST_ROOT/proc"}"
	# $cache_dir does not share (user specific logs inside), so share_proc must be a link point
	// share_link "share_proc" "PROC_ROOT" "$DEST_ROOT" "$cache_dir" "proc"
	# Downloaded archives
	# : "${share_archive:="$DEST_ROOT/archive"}"
	// share_link "share_archive" "ARCHIVE_ROOT" "$DEST_ROOT" "$cache_dir" "archive"

	[ ! -L "$PROC_ROOT" ] || {
		PROC_ROOT="$(readlink -f "$PROC_ROOT")";
		[ -d "${PROC_ROOT}" ] || // as_own "${DEST_ROOT%/*}" $cmd_mkdir -p "$PROC_ROOT"
	}

	: ${CCACHE_ROOT="$DEST_ROOT/ccache"} && export CCACHE_ROOT
	[ -d "$CCACHE_ROOT" ] || // as_own "$DEST_ROOT/" $cmd_mkdir -p "$CCACHE_ROOT"

	ccache_global "$CCACHE_ROOT"

	# Temporary cache directories.
	: ${MAKE_ROOT="$VOLATILE/make"}           && export MAKE_ROOT
	: ${TEMP_ROOT="$VOLATILE/buf"}            && export TEMP_ROOT
	: ${OBJ_ROOT="$VOLATILE/objects"}         && export OBJ_ROOT
	# Binary extract (usr, var, etc.)
	# : ${EXTRACT_ROOT:="$PROC_ROOT/extract"} && export EXTRACT_ROOT
	: ${EXTRACT_ROOT:="$VOLATILE/extract"}    && export EXTRACT_ROOT

	# log_dir="$VOLATILE/logs"

	: ${NATIVE_ROOT:="$DEST_ROOT/native"}     && export NATIVE_ROOT
	: ${PKG_ROOT:="$PROC_ROOT/pkg"}           && export PKG_ROOT
	: ${BIN_ROOT="$PROC_ROOT/bin"}            && export BIN_ROOT
	# Generated tar files
	: ${TAR_ROOT="$PROC_ROOT/tar"}            && export TAR_ROOT

	# set +e will bypass the following line and without exit
	# [ -d "${PROC_ROOT}" ] && equ "reset" "$2" && \rm -rf "$PROC_ROOT" && exit 1

	# Using 'as_usr $some_dir_to_be_made_user' of 'as_owner "$some_dir_to_be_made"'
	# all will fail because they pick up the new $some_dir_to_be_made to
	# display content. But that location does not exist yet
	\mkdir -p \
		"$MAKE_ROOT" \
		"$TEMP_ROOT" \
		"$OBJ_ROOT"  \
		"$EXTRACT_ROOT" ||
	// die 'mkdir' "'$MAKE_ROOT', '$TEMP_ROOT', '$OBJ_ROOT', '$EXTRACT_ROOT' failed"
	# "$log_dir" \

	// as_usr "$SRC_USER" \mkdir -p \
		"$PKG_ROOT" \
		"$TAR_ROOT" \
		"$BIN_ROOT" ||
	// die 'mkdir' "'$PKG_ROOT', '$TAR_ROOT', '$BIN_ROOT' failed"

	[ -z "${CROSS_ACTION:+x}" ] || // log '$CROSS_ACTION' "$CROSS_ACTION"
	// log '$LOGNAME'       "$LOGNAME"
	// log '$DEST_ROOT'     "$DEST_ROOT"
	// log '$KISS_ROOT'     "$KISS_ROOT"
	// log '$SRC_ROOT'      "$SRC_ROOT"
	// log '$SRC_USER'      "$SRC_USER"
	// log '$time'          "$time"
	// log '$sys_db'        "$sys_db"
	// log '$KISS_TMPDIR'   "$KISS_TMPDIR"
	// log '$VOLATILE'      "$VOLATILE"
	// log '$_KISS_LVL'     "$_KISS_LVL"

}

pkg_clear() {
	_level_2

	local action="$1"
	local repo_urn="$2"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"

	# // cue '$repo_name' "'$repo_name' clear performed"
	[ -n "${repo_name:+x}" ] || // die '$repo_name' "'$repo_name' should be given"

	# local make_dir="$MAKE_ROOT/$repo_name"
	# Let build functions do it
	# [ -n "${MAKE_ROOT:+x}" ] || // die '$MAKE_ROOT' "should not be empty"
	# [ ! -d "$make_dir" ] || [ "$MAKE_ROOT" = "/" ] || [ "$MAKE_ROOT" = "/make" ] ||
	# [ "$(// delegate -- occurrences "$make_dir" "/")" -le "1" ] ||
	# // as_own "$MAKE_ROOT" find "$make_dir" -mindepth 1 -delete

	[ -n "${TEMP_ROOT:+x}" ] || // die '$TEMP_ROOT' "'$TEMP_ROOT' should be given"

	local temp_dir="$TEMP_ROOT/$repo_name"
	[ ! -d "$temp_dir" ] || [ "$TEMP_ROOT" = "/" ] || [ "$TEMP_ROOT" = "/tmp" ] ||
	[ "$(// delegate -- occurrences "$temp_dir" "/")" -le "1" ] || {
		// cue '$temp_dir' "'$temp_dir' clear performed"
		// as_own "$TEMP_ROOT" find "$temp_dir" -mindepth 1 -delete
	}

	# Istallation might need these pacakges for dependencies
	! is_pick "$action" || return 0

	local pkg_dir="$TEMP_ROOT/$repo_name"
	[ "build" != "$action" ] || [ "b" != "$action" ] ||
	[ ! -d "$pkg_dir" ] || [ "$PKG_ROOT" = "/pkg" ] ||
	empty "$pkg_dir" || {
		// cue '$pkg_dir' "'$pkg_dir' clear performed"
		# // as_own "$PKG_ROOT" find "$PKG_ROOT/$repo_name" -mindepth 1 -delete
		# Directories like this can't be deleted with normal rm
		# '$EXTRACT_ROOT/neovim/var/db/kiss/choices/neovim>usr>bin>c99'
		# rm: can't remove '$EXTRACT_ROOT/neovim/var/db/kiss/choices/neovim>usr>bin>c99': Permission denied
		# for item in $(find "$PKG_ROOT/$repo_name" -type d -mindepth 1 -maxdepth 1); do
		for item in $(// as_own "$PKG_ROOT" \
			find "$pkg_dir" -mindepth 1 -maxdepth 1); do
			# [ ! -e "$item" ] || [ ! -h "$item" ] ||
		// as_own "$item" \rm -rf "$item"; done
	}

	local extract_dir="$EXTRACT_ROOT/$repo_name"
	[ "install" != "$action" ] || [ "i" != "$action" ] ||
	[ ! -d "$extract_dir" ] || [ "$EXTRACT_ROOT" = "/extract" ] ||
	empty "$extract_dir" || {
		// cue '$extract_dir' "'$extract_dir' clear performed"
		# // as_own "$EXTRACT_ROOT" find "$EXTRACT_ROOT/$repo_name" -mindepth 1 -delete
		# for item in $(find "$EXTRACT_ROOT/$repo_name" -type d -mindepth 1 -maxdepth 1); do
		for item in $(// as_own "$EXTRACT_ROOT" \
			find "$extract_dir" -mindepth 1 -maxdepth 1); do
			# choices folder items won't accept removing by normal users even it's is owned by the normal user
			# [ ! -e "$item" ] || [ ! -h "$item" ] ||
		// as_usr "root" \rm -rf "$item"; done
	}

	# For pick_up to do a series of operations, we don't delete the results
	# tar_file in $TAR_ROOT/$repo_name mean building succeeded
	# [ ! -d "$TAR_ROOT/$repo_name" ] || [ "$TAR_ROOT" = "/tar" ] ||
	# find "$TAR_ROOT/$repo_name" -mindepth 1 -delete

	# [ "$SRC_ROOT/$repo_name" = "/$repo_name" ] ||
	# find "$SRC_ROOT/$repo_name"  -mindepth 1 -delete

	# [ ! -d "${KISS_TMPDIR}/proc" ] ||
	# for item in $(\ls -x "${KISS_TMPDIR}/proc"); do [ "$item" = "$repo_name" ] || \rm -rf "${KISS_TMPDIR}/proc/$item"; done
}

# make or point to repo_name related dirs
# $1 action    : args action
# $1 repo_name  : package repo url/uri
pkg_dirs() {
	_level_2

	local action="$1"
	local repo_urn="$2"
	local repo_name="${repo_urn##*/}"
	repo_name="${repo_name%%@*}"

	[ -n "${SRC_USER:+x}" ] ||
		local SRC_USER="$(// delegate owner "$SRC_ROOT")"

	// debug '$repo_name' "$repo_name"
	{
		ok "$log_dir" || // die '$log_dir' "${log_dir:+"${log_dir} "} is not defined"

		[ -d "$PROC_ROOT" ] || // die '$PROC_ROOT' "'$PROC_ROOT' dir does not exist"
		[ ! -z "${repo_name:+x}" ] || // die '$repo_name' "does not exist"

		// ownership "$PKG_ROOT"     "$PKG_ROOT/$repo_name"
		// ownership "$EXTRACT_ROOT" "$EXTRACT_ROOT/$repo_name"
		// ownership "$TAR_ROOT"     "$TAR_ROOT/$repo_name"
		// ownership "$BIN_ROOT"     "$BIN_ROOT/$repo_name"
		// ownership "$SRC_ROOT"     "$SRC_ROOT/$repo_name"
		// ownership "$ARCHIVE_ROOT" "$ARCHIVE_ROOT/$repo_name"
		// ownership "$CCACHE_ROOT"  "$CCACHE_ROOT/$repo_name"

		# // pkg_clear "$action" "$repo_urn"

		mkdir -p \
			"$TEMP_ROOT/$repo_name" \
			"$MAKE_ROOT/$repo_name" \
			"$OBJ_ROOT/$repo_name"

		as_usr "$SRC_USER" mkdir -p \
			"$PKG_ROOT/$repo_name" \
			"$EXTRACT_ROOT/$repo_name" \
			"$TAR_ROOT/$repo_name" \
			"$BIN_ROOT/$repo_name"

		ccache_pkg "$repo_name"

		// log 'dirs initializd' "$repo_urn"
	}

	// debug '$TEMP_ROOT'    "$TEMP_ROOT"
	// debug '$MAKE_ROOT'    "$MAKE_ROOT"
	// debug '$OBJ_ROOT'     "$OBJ_ROOT"
	// debug '$SRC_ROOT'     "$SRC_ROOT"
	// debug '$PKG_ROOT'     "$PKG_ROOT"
	// debug '$EXTRACT_ROOT' "$EXTRACT_ROOT"
	// debug '$TAR_ROOT'     "$TAR_ROOT"
	// debug '$BIN_ROOT'     "$BIN_ROOT"
	// debug '$ARCHIVE_ROOT' "$ARCHIVE_ROOT"

	# printf "$RS%s" "$PROC_ROOT"
}

environment() {
	local key_name="$1"
	local value="$2"
	/ "$key_name=\"\$value\""
	export "$key_name"
}

args() {
	_level_2
	# type is_writable
	// war '$TTY' "$TTY"
	// pipe_report "PID_SAY" "$TTY"
	pipe_state "PID_SAY" "$TTY" && SAY_STATE="" && export SAY_STATE
	[ -t 0 ] || { // war 'fd 0' "recovered"; exec </dev/tty; }
	# [ -t 1 ] || { // war 'fd 1' "recovered"; exec &>/dev/tty; }
	# [ -t 2 ] || { // war 'fd 2' "recovered"; exec &>/dev/tty; }

	# type is_writable
	# /usr/bin/ash: set: line 6291: illegal option -s
	# options_filter
	SHELL_OPTIONS="$(// delegate -- options_filter)"
	export SHELL_OPTIONS

	set "-e$SHELL_OPTIONS"
	// log '$SHELL_OPTIONS' "$SHELL_OPTIONS"
	// log '$-' "$-"

	SESSION_PID="$$"
	// log '$SESSION_PID' "$SESSION_PID"
	# The assignment will stop current process? becuse SESSION_PPID is read only
	# { SESSION_PPID="$PPID"; }
	# // log '$SESSION_PPID' "$SESSION_PPID"

	# Parse script arguments manually. This is rather easy to do in our case
	# since the first argument is always an "action" and the arguments that
	# follow are all package names.
	# kiss_commanda are instructed by CROSS_ACTION
	action="${1-}"
	# [ ! -z "${CROSS_ACTION:+x}" ] && action="$CROSS_ACTION" || {
		shift "$(($# != 0))"
	# }

	// cue '$action' "$action"

	! is_pick "$action" || { select_index="${2-}"; set -- "${1-"${PWD##*/}"}"; }

	[ "$#" -eq "0" ] &&
	{
		[ -z "${action:+x}" ] || [ "$action" = "h" ] || [ "$action" = "a" ] || [ "$action" = "alternatives" ] ||
			// die 'no' "target"
	} || {
		// war '$#' "$#"
		// war '$@' "$(esceval "$@")"
	}
	# pkg_order() needs the following variables to be declared here
	local explicit="$*" makedeps= deps=
	# Ensure that arguments do not contain invalid characters. Wildcards can
	# not be used here as they would conflict with kiss extensions.
	# shellcheck disable=SC1035
	case "$action" in
		"a"|"alternatives")
			case "${1-}" in *\**|*\!*|*"["*|*\ *|*"]"*|*/*|*\>*|*"$newline"*)
				// die 'Invalid argument' "'!*[ ]/\\n' (${1-})"
			esac
		;;

		# b|build|c|checksum|d|download|i|install|l|list|m|manifest|r|remove|u|update)
		b|build|c|checksum|d|download|i|install|l|list|m|manifest|u|update)
			for _arg do case "${action%%"${action#?}"}-$_arg" in
				"i-"*\!*|"i-"*\**|"i-"*"["*|"i-"*\ *|"i-"*"]"*|"i-"*"$newline"*)
					// die 'Invalid argument' "'!*[ ]\\n' ('$_arg')"
					;;

				[!i]-*\!*|[!i]-*\**|[!i]-*"["*|[!i]-*\ *|[!i]-*"]"*|[!i]-*"$newline"*)
				# [!i]-*\]*|[!i]-*/*|[!i]-*"$newline"*)
					// die "Might be wrong usage of argument \
					'!*[ ]/\\n' ('$_arg')." "Use a package name, please."
					;;
			esac done

			# Modified KISS_PATH to readonly
			# # When no arguments are given on the command-line, use the basename
			# # of the current directory as the package name and add the parent
			# # directory to the running process' KISS_PATH.
			# case ${action%%"${action#?}"}-$# in [!l]-0)
			#     export KISS_PATH=${PWD%/*}:$KISS_PATH
			#     set -- "${PWD##*/}"
			# esac

			# Modified KISS_PATH to readonly
			# # Search the installed database first when removing packages. Dependency
			# # files may differ when repositories change. Removal is not dependent on
			# # the state of the repository.
			# case $action in r|remove)
			#     export KISS_PATH=$KISS_ROOT/$db:$KISS_PATH
			# esac

			# !!

			# order -- right is target, left is dependencies
			local order= redro=
			# Order the argument list based on dependence.
			! // || / `pkg_order "$explicit" |
				awk -v rs="$RS" -v fs="$FS" 'BEGIN { FS = fs; RS = rs } \
			END { print "explicit=\""$1"\"; makedeps=\""$2"\"; deps=\""$3"\"; \
			order=\""$4"\"; redro=\""$5"\"" }' ||
			printf '%s\n' "return 1"`

			for repo_urn in $order; do
				// pkg_dirs "$action" "${repo_urn##*/}"
			done

			# ^^

			# Intentional, globbing disabled.
			# shellcheck disable=2046,2086
			# Don't quote it
			# set -- $order
			set -- $makedeps $deps $explicit
	esac

	# depends policy: expl
	#             $deps           $makedeps
	#               
	#               
	# $explicit   $order/$redro   $makedeps
	#
	# Lost $explicit
	# depends policy: raw
	#       $deps            $makedeps
	#         
	#         
	#       $order/$redro    $makedeps
	#         
	#         ------------
	#                   
	#  non $explicit $explicit

	// log '$explicit' "$(esceval "$explicit")"
	// log '$makedeps' "$(esceval "$makedeps")"
	// log '$deps'     "$(esceval "$deps")"

	# Rerun the script as root with a fixed environment if needed. We sadly
	# can't run singular functions as root so this is needed.
	#
	# Intended behavior.
	# shellcheck disable=2030,2031
	[ -z "${KISS_FORCE+x}" ] || // log '$KISS_FORCE' "$KISS_FORCE"

	# _KISS_LVL will increment inside each subshell
	# case $action in a|alternatives|i|install|r|remove)
	#   # null "$action" ||
	#   # equ "$LOGNAME" "$(// delegate -- owner "$KISS_ROOT/")" || {
	#   equ "$LOGNAME" "root" || {
	#       // cue 'subshell' "$action"
	#       case $action in
	#           r|remove)
	#               local redro=
	#               for parameter in "$@"; do
	#                   for item in $(kiss-revdepends "$parameter" |
	#                       awk -F / '{print $1}' 2> /dev/null)
	#                   do
	#                       redro="${redro} $item"
	#                   done
	#               done
	#               set -- $redro "$@"
	#               // subshell_all "$action" "$@" ;;
	#           *)
	#               // subshell_all "$action" "$@"
	#       esac
	#       return 0
	#   }
	# esac

	# Need to increment _KISS_LVL here to ensure we don't wipe the cache
	# early by non-asroot invocations.
	# : $((_KISS_LVL += 1))
	# export _KISS_LVL
	# // log '$_KISS_LVL' "$_KISS_LVL [in args \"$action\"]"

	# Clear temporary files

	# This will cancell the process on busybox 1.35.0-2
	# when the variables have definition and set -e
	# [ -z "$KISS_DEBUG" ] || // log '$KISS_DEBUG' "$KISS_DEBUG"
	# null "$KISS_DEBUG" || // log '$KISS_DEBUG' "$KISS_DEBUG"
	# This will recover the process
	# [ -z "$KISS_DEBUG" ] || {
	# :
	# // log '$KISS_DEBUG' "$KISS_DEBUG"
	# }

	[ "$#" -eq "0" ] && {
		[ -z "${action:+x}" ] || [ "$action" = "h" ] || [ "$action" = "a" ] || [ "$action" = "alternatives" ] ||
		// die 'no' "target"
	} || { // cue '$action' "$action"; // war '$@' "$(esceval "$@")"; }
	[ -z "${KISS_DEBUG+x}" ] || // log '$KISS_DEBUG' "$KISS_DEBUG"

	# Actions can be abbreviated to their first letter. This saves keystrokes
	# once you memorize the commands.
	case "$action" in
		a|alternatives)
			# // pkg_alternatives "$@" ;;
			// alter "alternatives" "$@" 2>&1 ||
			// die 'alternatives failed' "$(esceval "$@")"
				;;
		ar|archive)
			// alter "archive" "$@" 2>&1 ||
			// die 'archiving failed' "$(esceval "$@")"
				;;
		maint)
			// alter "maintain" "$@" 2>&1 ||
			// die 'maintaining failed' "$(esceval "$@")"
				;;
		b|build)
			// build_all "$explicit" "$makedeps" "$deps" ||
			// die '$explicit $makedeps $deps' "'$explicit' '$makedeps' '$deps' build_all failed"
			;;
		c|checksum)
			for repo_name do // pkg_checksum "$repo_name"; done ;;
		d|download)
			for repo_name do
				local repo_name_plain="$(name_plain "$repo_name")"
				[ -n "$(/ echo \${synchronized_${repo_name_plain}-})" ] ||
				// pkg_download "$repo_name"
			done ;;
		h|help-ext)
			// pkg_help_ext "$@" ;;
		i|install)
			for repo_urn do
				local repo_name="${repo_urn##*/}"
				(! list_contains "$repo_urn" $makedeps) || {
					is_repos "$sys_db/$repo_name" && # ||
					# is_model "$repo_urn" "$sys_db/${repo_urn##*/}" "mirror"
					continue || {
						(
						export KISS_FORCE=
						// alter "install" "$repo_urn" 2>&1
						) ||
						// die "$repo_urn installation" "failed"
						continue
					}
				}
				local target_repo="$KISS_ROOT/$db/$repo_name"
				is_repos "$target_repo" && {
					[ -z "${repo_urn##*"$KISS_ROOT/$db"*}" ] ||
					is_model "$repo_urn" "$target_repo" "mirror"
				} &&
					(! list_contains "$repo_urn" $explicit) ||
				// alter "install" "$repo_urn" 2>&1 ||
					// die "$repo_urn installation" "failed"
			done
			# // alter "install" "$@" 2>&1 || :
			;;
		l|list)
			for repo_urn do // list_version "$repo_urn"; done ;;
		m|manifest)
			for repo_urn do
				// list_version "$repo_urn"
				[ ! -f "$KISS_ROOT/$db/${repo_urn##*/}/manifest" ] ||
				cat "$KISS_ROOT/$db/${repo_urn##*/}/manifest" 2>/dev/null || :
			done ;;
		p|pick)
			// pick_up "$explicit" "$select_index" ;;
		r|remove)
			local redro=
			local parameter
			for parameter in "$@"; do
				local item
				for item in $(kiss-revdepends "$parameter" |
					awk -F / '{print $1}' 2> /dev/null)
				do
					redro="${redro} $item"
				done
			done
			set -- $redro "$@"

			for repo_urn in "$@"; do
				// alter "remove" "$repo_urn"
				// die "$repo_urn removing" "failed"
			done
				;;
			# // alter "remove" "$@" 2>&1 || : ;;
		s|search)
			for repo_urn; do
				for item in $(// delegate -- repo_trace "$repo_urn" all -d); do
					// log "$repo_urn" "$item"
				done
			done ;;
		u|update)
			// pkg_update $makedeps $deps ;;
		U|upgrade)
			// pkg_upgrade ;;
		v|version)
			// version_installed "${1-}" ;;
		'')
			# // log 'kiss [a|b|c|d|i|l|m|r|s|u|U|v]' '[pkg]...'
			// log '[a|b|c|d|h|i|l|m|o|p|r|s|u|U|v] [pkg]...'
			// log 'a|alternatives' 'List and swap alternatives'
			// log 'b|build'        'Build packages'
			// log 'c|checksum'     'Generate checksums'
			// log 'd|download'     'Download sources'
			// log 'h|help'         "See all actions"
			// log 'i|install'      'Install packages'
			// log 'l|list'         'List installed packages'
			// log 'm|manifest'     'Package manifest'
			// log 'o|owns'         'Package ownership reverse search'
			// log 'p|pick'         'Query and pick up a package'
			// log 'r|remove'       'Remove packages'
			// log 's|search'       'Search for packages'
			// log 'u|update'       'Update the system and repositories'
			// log 'U|upgrade'      'Update the system'
			// log 'v|version'      'Package version'

			# // log '\nRun "kiss [H|help-ext]" to see all actions\n'
			;;

		*)
			# _KISS_LVL is readonly.The package manager should aware the level value
			# corresponding to the host instance (level 0).
			// debug '$#' "$#"
			[ -z "${2:+x}" ] || // debug '$2-$#' "$2-$#"

			local kiss_command="$( \
				// delegate -- repo_trace "kiss-$action*" "" -x "$PATH")"
			ok "$kiss_command" ||
			{ // war "kiss-$action*" "does not exist"; return 0; }
			// cue '$kiss_command' "$kiss_command"

			// debug '$sys_db' "$sys_db"
			// debug '$kiss_command' "$kiss_command"

			# Don't shut off the log function here
			# // kill_pipe 'PID_LOG' "$PID_LOG"
			# // kill_pipe 'PID_SAY' "$PID_SAY"

				# PID_SAY="$PID_SAY" \

			# Like this
			# /usr/bin/kiss-manifest $@
			# _KISS_LVL=1 "$kiss_command" "$@"
			# SHELL_OPTIONS="e$(printf '%s' "$-")" \
			set +f
			SHELL_OPTIONS="$(// delegate -- options_filter)"
			export SHELL_OPTIONS
			# env \
			#   SHELL_OPTIONS="$SHELL_OPTIONS" \
			#   _KISS_LVL="$_KISS_LVL" \
			#   CROSS_ACTION="$CROSS_ACTION" \
			#   SESSION_PPID="$SESSION_PPID" \
			#   SESSION_PID="$SESSION_PID" \
			#   "$kiss_command" "$@" || :

				# PID_LOG="$PID_LOG" \

				# _KISS_LVL=\"$_KISS_LVL\" \
				# SESSION_PPID=\"$SESSION_PPID\" \
				# SESSION_PID=\"$SESSION_PID\" \
			local env_variables=" SHELL_OPTIONS=\"$SHELL_OPTIONS\" CROSS_ACTION=\"$CROSS_ACTION\" "

			[ -z "${KISS_AS_LIBRARY:+x}" ] ||
				env_variables="$env_variables KISS_AS_LIBRARY=\"$KISS_AS_LIBRARY\" "

			/ "$env_variables . \"$kiss_command\" $@ 2>&1" || :
			# pid_external="$!"
	esac

	[ "$PWD" = "$ppwd" ] || {
		// log 'test' "test_06"
		// log '$ppwd' "$ppwd"
		// log '$PWD' "$PWD"
		cd "$ppwd"
	}

	[ ! -z "${action:+x}" ] ||
	// cue 'usage' "action repo_urn_00 repo_name_01 ..."

}

# Need a nicer way of detecting architecture
determine_arch() {
	_level_2
	local _arch="$($cmd_elf -a -W "$1" | grep 'Machine:')"
	local _endian="$($cmd_elf -a -W "$1" | grep 'Data:')"

	case "$_arch $_endian" in
		*AArch64*little*)   arch="aarch64-linux-musl";;
		*AArch64*big*)      arch="aarch64_be-linux-musl";;
		*ARM*)              arch="armv7-linux-musleabihf";;
		*Intel*80386*)      arch="i686-linux-musl";;
		*PowerPC64*little*) arch="powerpc64le-linux-musl";;
		*PowerPC64*big*)    arch="powerpc64-linux-musl";;
		*PowerPC*little*)   arch="powerpcle-linux-musl";;
		*PowerPC*big*)      arch="powerpc-linux-musl";;
		*X86-64*)           arch="x86_64-linux-musl";;
		*RISC-V*)           arch="riscv64-linux-musl";;
		*)
			// die 'Unknown architecture' "$_arch / $_endian"
			;;
	esac

	printf "$RS%s" $arch
}

cross_flags() {
	_level_2

	# KISS_XBUILD_TRIPLE="$(clang -print-target-triple | sed 's/-unknown//')" ||
	# KISS_XBUILD_TRIPLE="$(cc -dumpmachine | sed 's/-unknown//')" ||
	# [ -n "${KISS_XBUILD_TRIPLE:+x}" ] ||
	KISS_XBUILD_TRIPLE="${KISS_XHOST_TRIPLE:-"$(// delegate -- determine_arch "/usr/bin/bzip2")"}"
	export KISS_XBUILD_TRIPLE
	KISS_XHOST_TRIPLE="${KISS_XHOST_TRIPLE:-"$(// delegate -- determine_arch "$KISS_ROOT/usr/bin/bzip2")"}"
	export KISS_XHOST_TRIPLE

	# set -f

	local ifs="$IFS"
	local IFS=$'-'

	set +f
	set -f -- $KISS_XBUILD_TRIPLE
	export KISS_XBUILD_ARCH="$1"
	export KISS_XBUILD_SYS="$2"
	export KISS_XBUILD_ABI="$3"

	set +f
	set -f -- $KISS_XHOST_TRIPLE
	export KISS_XHOST_ARCH="$1"
	export KISS_XHOST_SYS="$2"
	export KISS_XHOST_ABI="$3"

	IFS="$ifs"
	# Default is set -f ?
	# set +f

	# Flags used for pkg-config
	export PKG_CONFIG_PATH=
	export PKG_CONFIG_LIBDIR="${KISS_ROOT}"/usr/lib/pkgconfig:"${KISS_ROOT}"/usr/share/pkgconfig
	export PKG_CONFIG_SYSROOT_DIR="${KISS_ROOT}"

	# Don't carry over flags if this is a cross build
	[ -z ${KISS_ROOT:+x} ] || {
		unset CFLAGS
		unset CXXFLAGS
		unset LDFLAGS
	}

	# Allow setting of chroot-specific cflags
	flagfile="$KISS_ROOT/etc/os-buildflags"
	[ ! -f "$flagfile" ] || . "$flagfile"
	local cc="$(which cc)"
	local cxx="$(which c++)"
	: "${cc:="/usr/lib/ccache/bin/cc"}"   && export cc
	: "${cxx:="/usr/lib/ccache/bin/c++"}" && export cxx
	# Set the compiler target architecture
	if [ -z "${KISS_ROOT:+x}" ]; then
		# Local build. Allow user-set CFLAGS as per normal KISS, or override them in /etc/os-buildflags
		export  CC="${CC:-"$cc"}"
		export CXX="${CXX:-"$cxx"}"
	else
		# Cross build. CFLAGS will always come from $KISS_ROOT/etc/os-buildflags
		flags="--target=$KISS_XHOST_TRIPLE --sysroot=${KISS_ROOT} -fPIC"
		export   CFLAGS="$flags ${CFLAGS-}"
		export CXXFLAGS="$flags ${CXXFLAGS-}"
		export  LDFLAGS="--sysroot=$KISS_ROOT ${LDFLAGS-}"
		# llvm won't accept $CC with flages
		# export       CC="$cc $CFLAGS"
		export       CC="$cc"
		# llvm won't accept $CXX with flages
		# export      CXX="$cxx $CXXFLAGS"
		export      CXX="$cxx"
	fi
}

repo_setup() {
	_level_2
	# Set variables which help with cross building
	if [ -z "${KISS_BINREPO:+x}" ]; then
		// cross_flags

		# Bin repo will be "local" for normal builds, for chroot builds
		# it will be the last part of $KISS_ROOT appended with md5sum of
		# the full $KISS_ROOT path. This keeps packages built for different
		# root directories in separate directories.
		local lastbit="${KISS_ROOT##*/}"
		if null "$lastbit"; then
			binrepo="local"
		else
			binrepo="${lastbit}_$(echo "$KISS_ROOT" | md5sum | cut -c1-32)"
		fi
	else
		binrepo="$KISS_BINREPO"
	fi
}

pre_args() {
	_level_2

	pipe_all

	[ -t 0 ] || // die 'fd 0' "does not work"

	// init_info

	# http://mywiki.wooledge.org/BashFAQ/105
	# Globally disable globbing and enable exit-on-error.

	# Moved to kiss/share
	# https://unix.stackexchange.com/questions/151771/getting-wrong-lineno-for-a-trapped-function

	// log '$-' "$-"
	# [ -n "${SHELL_OPTIONS:+x}" ] ||
	SHELL_OPTIONS="$(// delegate -- options_filter)"
	export SHELL_OPTIONS

	// log '$SHELL_OPTIONS' "$SHELL_OPTIONS"
	set "-e$SHELL_OPTIONS"

	// log '$-' "$-"

	# printf '%s %s\n' '$-' "$- [kiss]"
	# printf '%s %s\n' 'set -o' "[kiss]"
	# set -o
	# read -r

	type_include "is_writable" "function" ||
	// die 'function' "'is_writable' is not defined"

	# Store the original working directory to ensure that relative paths
	# passed by the user on the command-line properly resolve to locations
	# in the filesystem.
	ppwd="$PWD"

	# Store the date and time of script invocation to be used as the name of
	# the log files the package manager creates during builds.
	time="$(date +%Y-%m-%d-%H:%M)"

	# Moved to kiss/share
	# Never know when you're gonna need one of these.
#     newline="
# "
	# Defaults for environment variables.
	: "${KISS_COMPRESS:="gz"}" && export KISS_COMPRESS
	# : "${SESSION_PPID:="$(pid_parent "${PPID}")"}"
	# : "${KISS_PID:=$$}"
	: "${_KISS_LVL:="0"}"
	: "${CROSS_ACTION:=""}"

	: "${KISS_REPO:?"KISS requires KISS_REPO to be set"}"
	: "${REPO_BASE:="$(readlink -fn "$KISS_REPO/base")"}"
	REPO_URL="$(as_own "$KISS_REPO" git -C "$KISS_REPO" remote -v | grep "fetch" | awk '{print $2}')"
	export REPO_URL
	export SESSION_PPID

	: ${PREFER_CACHE:=} && export PREFER_CACHE

	: ${EXPLICIT_POLICY:="expl"} && export EXPLICIT_POLICY

	# Moved to kiss/share
# : "${IFS=" $(printf '%s' "t" | tr 't' "\\t")
# "}"

	readonly IFS_ORIGIN
	readonly EXPLICIT_POLICY
	readonly KISS_PATH
	readonly KISS_STRIP
	readonly KISS_CHOICE
	readonly SESSION_PPID
	readonly _KISS_LVL
	# readonly KISS_FORCE
	# readonly KISS_DEBUG

	[ -z "${KISS_FORCE+x}" ]  || export KISS_FORCE
	[ -z "${KISS_CHOICE+x}" ] || export KISS_CHOICE
	[ -z "${KISS_COLOR+x}" ]  || export KISS_COLOR

	# Only after thie line, logs might work
	# Moved to kiss/share
	// user_log

	[ -t 0 ] || // die 'fd 0' "does not work"
	// debug_filter -- // log '$@' "$(esceval "$@")"
	// debug '$COLOR_PARENT' "$COLOR_PARENT"
	// debug '$COLOR_CHILD'  "$COLOR_CHILD"
	// debug '$COLOR_END'    "$COLOR_END"

	# local content="$(// delegate -- prompt "Test prompt in kiss")"
	# ! expr "$content" : '[n|N]\+' > /dev/null || return 0
	# // war '$content' "$content"

	# Figure out which sha256 utility is available.
	cmd_sha=${KISS_CHK:-"$( \
		command -v /usr/bin/openssl   ||
		command -v /usr/bin/sha256sum ||
		command -v /usr/bin/sha256    ||
		command -v /usr/bin/shasum    ||
		command -v /usr/bin/digest
	)"} || // die 'sha256' "utility not found"

	# Figure out which download utility is available.
	cmd_get=${KISS_GET:-"$( \
		command -v /usr/bin/aria2c ||
		command -v /usr/bin/axel   ||
		command -v /usr/bin/curl   ||
		command -v /usr/bin/wget   ||
		command -v /usr/bin/wget2
	)"} || // die 'download utility' "not found (aria2c, axel, curl, wget, wget2)"

	[ -t 0 ] || // die 'fd 0' "does not work"

	// init_dirs "$ppwd"

	// repo_setup

	# Catch errors and ensure that build files and directories are cleaned
	# up before we die. This occurs on 'Ctrl-C' as well as success and error.
	# trap clean_all EXIT INT
	[ -z "${IS_KISS+x}" ] || {
		trap_print "trap_status" "INT|TERM|QUIT|PIPE|EXIT"
		[ -n "$trap_status" ] || {
			# printf '%s %s\n' 'trap' "definitions at $LINENO"
			// war 'trap' "definitions $(delegate -- format "before") trap_on"
			trap
		}
	}
	// trap_on "$@"
	[ -z "${IS_KISS+x}" ] || {
		trap_print "trap_status" "INT|TERM|QUIT|PIPE|EXIT"
		[ -n "$trap_status" ] || {
			# printf '%s %s\n' 'trap' "definitions at $LINENO"
			// war 'trap' "definitions $(delegate -- format "after") trap_on"
			trap
		}
	}

	# For transfering to sub processes
	# "\\$newline" made readability
	ENV_VARIABLES="AR=\"${AR:-ar}\" "
	ENV_VARIABLES="$ENV_VARIABLES CC=\"${CC:-cc}\" "
	ENV_VARIABLES="$ENV_VARIABLES CXX=\"${CXX:-c++}\" "
	ENV_VARIABLES="$ENV_VARIABLES CFLAGS=\"${CFLAGS:-" -O3 -pipe -fPIC "}\" "
	ENV_VARIABLES="$ENV_VARIABLES CXXFLAGS=\"${CXXFLAGS:-" -O3 -pipe -fPIC "}\" "
	ENV_VARIABLES="$ENV_VARIABLES LDFLAGS=\"${LDFLAGS-}\" "
	ENV_VARIABLES="$ENV_VARIABLES NM=\"${NM:-nm}\" "
	ENV_VARIABLES="$ENV_VARIABLES RANLIB=\"${RANLIB:-ranlib}\" "
	ENV_VARIABLES="$ENV_VARIABLES DEST_ROOT=\"$DEST_ROOT\" "
	# RUSTFLAGS='-Clink-arg=-Wl,--dynamic-linker=/usr/lib/libc.so'
	ENV_VARIABLES="$ENV_VARIABLES RUSTFLAGS=\"--remap-path-prefix=$PWD=. -Clinker=rust-lld ${RUSTFLAGS-}\" "
	ENV_VARIABLES="$ENV_VARIABLES GOFLAGS=\"-trimpath -modcacherw ${GOFLAGS-}\" "
	ENV_VARIABLES="$ENV_VARIABLES GOPATH=\"${GOPATH:-"$PWD/go"}\" "
	ENV_VARIABLES="$ENV_VARIABLES PATH=\"${GOPATH:-"$PWD/go"}/bin:$PATH\" "
	ENV_VARIABLES="$ENV_VARIABLES KISS_ROOT=\"$KISS_ROOT\" "
	ENV_VARIABLES="$ENV_VARIABLES KISS_XHOST_ARCH=\"$KISS_XHOST_ARCH\" "
	ENV_VARIABLES="$ENV_VARIABLES KISS_XBUILD_ARCH=\"$KISS_XHOST_ARCH\" "
	ENV_VARIABLES="$ENV_VARIABLES CHOST=\"$KISS_XHOST_TRIPLE\" "
	ENV_VARIABLES="$ENV_VARIABLES CBUILD=\"$KISS_XBUILD_TRIPLE\" "
	ENV_VARIABLES="$ENV_VARIABLES KISS_XHOST_ABI=\"$KISS_XHOST_ABI\" "
	ENV_VARIABLES="$ENV_VARIABLES KISS_XBUILD_ABI=\"$KISS_XBUILD_ABI\" "
	ENV_VARIABLES="$ENV_VARIABLES KISS_XHOST_TRIPLE=\"$KISS_XHOST_ARCH-linux-$KISS_XHOST_ABI\" "
	ENV_VARIABLES="$ENV_VARIABLES KISS_XBUILD_TRIPLE=\"$KISS_XBUILD_ARCH-linux-$KISS_XBUILD_ABI\" "
	ENV_VARIABLES="$ENV_VARIABLES SESSION_PID=\"$SESSION_PID\" "
	ENV_VARIABLES="$ENV_VARIABLES KISS_PID=\"$KISS_PID\" "
	ENV_VARIABLES="$ENV_VARIABLES SHELL_OPTIONS=\"$SHELL_OPTIONS\" "
	ENV_VARIABLES="$ENV_VARIABLES KISS_REPO=\"$KISS_REPO\" "
	ENV_VARIABLES="$ENV_VARIABLES REPO_BASE=\"$REPO_BASE\" "
	ENV_VARIABLES="$ENV_VARIABLES SRC_ROOT=\"$SRC_ROOT\" "
	ENV_VARIABLES="$ENV_VARIABLES PKG_ROOT=\"$PKG_ROOT\" "
	ENV_VARIABLES="$ENV_VARIABLES CCACHE_ROOT=\"$CCACHE_ROOT\" "
	ENV_VARIABLES="$ENV_VARIABLES NATIVE_ROOT=\"$NATIVE_ROOT\" "
	ENV_VARIABLES="$ENV_VARIABLES MAKE_ROOT=\"$MAKE_ROOT\" "
	ENV_VARIABLES="$ENV_VARIABLES OBJ_ROOT=\"$OBJ_ROOT\" "
	ENV_VARIABLES="$ENV_VARIABLES XBPS_CROSS_BASE=\"$KISS_ROOT\" "
	ENV_VARIABLES="$ENV_VARIABLES KISS_COMPRESS=\"$KISS_COMPRESS\" "
	ENV_VARIABLES="$ENV_VARIABLES USE_SAY_PIPE=\"$USE_SAY_PIPE\" "
	ENV_VARIABLES="$ENV_VARIABLES MNGR_ROOT=\"$MNGR_ROOT\" "
	ENV_VARIABLES="$ENV_VARIABLES REPO_ROOT_IMPL=\"$REPO_ROOT_IMPL\" "
	# This means a definition
	ENV_VARIABLES="$ENV_VARIABLES KISS_ALTER_AS_LIBRARY=\"\" "

	# Not always supposed to bedefined, and if you are sure you want to define it, set it to ""
	# ENV_VARIABLES="$ENV_VARIABLES KISS_AS_LIBRARY=\"\" "
	# ENV_VARIABLES="$ENV_VARIABLES DEBUG_AT_BACKGROUND=\"$DEBUG_AT_BACKGROUND\" "
	# ENV_VARIABLES="$ENV_VARIABLES KISS_FORCE=\"$KISS_FORCE\" "
	#
	# Set it manually for specific $action
	# ENV_VARIABLES="$ENV_VARIABLES CROSS_ACTION=\"${CROSS_ACTION:-"$action"}\" "
	#
	# Just a demo
	# Set it manually for specific repo
	# ENV_VARIABLES="$ENV_VARIABLES DESTDIR=\"$PKG_ROOT/$repo_name\" "
	# environment "DESTDIR" "$PKG_ROOT/$repo_name"
	#
	# Recommendation for out-of-source build
	# OUTPUT_DIR="$OBJ_ROOT/$repo_name"
	#
	# ENV_VARIABLES="$ENV_VARIABLES REPO_DIR=\"$REPO_DIR\" "
	# environment "REPO_DIR" "$REPO_DIR"
	export ENV_VARIABLES
	readonly ENV_VARIABLES
	// log '$ENV_VARIABLES' "$ENV_VARIABLES"
}

main() {
	____

	[ -z "${KISS_DEBUG:+x}" ] || local pid_list=

	# // pre_args

	// args "$@"

	// log 'test' "test_07"
	# Logs have been written/shifted in "real time" (on subshell_all)
	# [ -n "${LOG_PERMANENT_ALL_DONE:+x}" ] || // log_shift_all "$user_output" "$@"

	# This line will be terminated by kill_subtree and log_shift_all will be blocked
	# // as_own "$log_dir" rm -f -- "$user_output"
	sync

	// log 'test' "test_08"
	# Do it in trap
	# // as_own "$log_dir" rm -f -- "$pipe_log"
	# // as_own "$log_dir" rm -f -- "$pipe_say"
	# [ ! -p "$pipe_log" ] || // die '$pipe_log' "$pipe_log"
	# [ ! -p "$pipe_say" ] || // die '$pipe_say' "$pipe_say"

	[ -z "${KISS_DEBUG:+x}" ] || {
		local item
		for item in $pid_list; do
			// debug_filter -- printf "%s %s\n" '$pid_list item' "$item"
			# kill -s SIGTERM "$item";
		done
		# "help jobs"
		// debug_filter -- printf '%s\n' "$(jobs -l)"
	}

	# trap 'kill -USR1 "\$SESSION_PID"; exit' INT TERM QUIT PIPE

	#         for trap_name in INT TERM  QUIT PIPE EXIT; do
	#             trap " \
	# printf '%s %s\n' \"trap\" \"at line $LINENO\"; \
	# // war '$trap_name' \"triggered in \\\"$FUNCNAME\\\"\"; \
	# // kill_all \"{kiss}\" \"${0##*/}\"; \
	# ! pid_alive \"$SESSION_PID\" || kill -USR1 \"$SESSION_PID\"; \
	# " $trap_name
	#         done

	# Mute the "Terminated" message? Mainly thinking about what went wrong with the desing, I think
	# trap "exit" 1
	# trap 'exit' 9

	// log '$SESSION_PID' "$SESSION_PID"
	// log '$PPID' "$PPID"
	// log '$SESSION_PPID' "$SESSION_PPID"
	# // log '$KISS_PID' "$KISS_PID"
	[ -z "${KISS_INNER_PIPE:+x}" ] || {
		# [ -z "${USE_SAY_PIPE+x}" ] ||
		[ -z "${PID_SAY:+x}" ] || // log '$PID_SAY' "${PID_SAY-}"
		[ -z "${PID_LOG:+x}" ] || // log '$PID_LOG' "${PID_LOG-}"
	}
	# [ "$SESSION_PPID" -ne "$PPID" ] ||
	# [ "$_KISS_LVL" -ne "0" ] || {
		# // log 'clean_all' "$(esceval "$@")"
		# clean_all needs to write log or debug message to user_output
		# // clean_all "$@"

		# Shut off the log/cue function
		# // log '$PID_SAY' "$PID_SAY will be killed"
		# // log '$(pstree -p "$KISS_PID")' "$(pstree -p "$KISS_PID")"

		# Considering no kill on normal processes
		# // kill_pipe 'PID_SAY' "$PID_SAY"

		# ! pid_alive "$PID_SAY" || kill -TERM "$PID_SAY"
		# (sleep 1 && ! pid_alive "$PID_SAY" || // war '$PID_SAY' "'$PID_SAY' killing failed") &

		# // log '$(pstree -p "$KISS_PID")' "$(pstree -p "$KISS_PID")"
		# // log '$PID_LOG' "$PID_LOG will be killed"
		# // log '$(pstree -p "$KISS_PID")' "$(pstree -p "$KISS_PID")"

		# // kill_pipe 'PID_LOG' "$PID_LOG"

		# ! pid_alive "$PID_LOG" || kill -TERM "$PID_LOG"
		# (sleep 1 && ! pid_alive "$PID_LOG" || // war '$PID_LOG' "'$PID_LOG' killing failed") &

		# // log '$(pstree -p "$KISS_PID")' "$(pstree -p "$KISS_PID")"

		# trap "kill 0" EXIT
		# trap "kill $(jobs -p)" EXIT
		# kill 0/$KISS_PID in this way (as root user) will reboot the system
		# trap 'as_usr "root" kill $KISS_PID' EXIT
		# set -E; trap \'trace_line "$LINENO" "$lineno_scope" "$func_name" "$scope"\' ERR;
		# trap 'printf "%s\n" "ERROR on EXIT"; kill 0 || // kill_subtree "$KISS_PID"' EXIT
		# trap 'trace_line "$LINENO" "${lineno_scope:-"$LINENO"}" "$func_name" "${scope:-"kiss"}"' EXIT
		# trap 'kill 0 || // kill_subtree "$KISS_PID"' EXIT

		# trap 'pkill -P "$PPID" || // kill_subtree "$KISS_PID"' EXIT

		# kill 0 ||
		# // kill_tree "$KISS_PID" > /dev/null 2>&1
		# // kill $(pstree -p "$KISS_PID" | sed 's/(/\n(/g' | grep '(' | sed 's/(\(.*\)).*/\1/' | tr "\n" " ")
		# pkill -P "$PPID" || // kill_subtree "$KISS_PID"

	[ -z "${KISS_INNER_PIPE:+x}" ] || {
		# trap ' \
		# // kill_pipe "PID_SAY" "$PID_SAY"; \
		# // kill_pipe "PID_LOG" "$PID_LOG"' INT EXIT TERM
		# trap " \
		# kill -TERM \"$PID_SAY\"; \
		# kill -TERM \"$PID_LOG\"" INT EXIT TERM

		# trap ' \
		# // pipe_cancel "PID_SAY"; \
		# // pipe_cancel "PID_LOG"; exit' EXIT
		# trap "// kill_all $*" EXIT
		[ -z "${IS_KISS+x}" ] || {
			trap_print "trap_status" "INT|TERM|QUIT|PIPE|EXIT"
			[ -n "$trap_status" ] || {
				# printf '%s %s\n' 'trap' "definitions at $LINENO"
				// war 'trap' "definitions"
				trap
			}
		}
		# trap '// kill_subtree "$PPID"' INT EXIT TERM

		# [ "$SESSION_PPID" -ne "$KISS_PID" ] || kill 0 || // kill_subtree "$KISS_PID"
		# [ "$SESSION_PPID" -eq "$PPID" ] || kill 0 || // kill_subtree "$PPID"
		# [ "$SESSION_PPID" -ne "$PPID" ] || // kill_tree "$KISS_PID" > /dev/null 2>&1
		# [ "$SESSION_PPID" -eq "$PPID" ] || // kill_tree "$KISS_PID" > /dev/null 2>&1
	}
	# }

	[ -z "${KISS_DEBUG:+x}" ] || {
		// debug_filter -- printf '%s\n' "pstree at _KISS_LVL $_KISS_LVL at $KISS_PID"
		for pid in $(pstree -p "$KISS_PID" | sed 's/(/\n(/g' | grep '(' | sed 's/(\(.*\)).*/\1/'); do
			// debug_filter -- printf '%s %s\n' "_KISS_LVL $_KISS_LVL" "$pid"
		done
	}

	[ -z "${pid_external:+x}" ] ||
	! pid_alive "$pid_external" || {    # // kill_subtree "$pid_external"
		# [ -z "${KISS_DEBUG:+x}" ] ||
		// debug_filter -- printf '%s \n' "pid list of \$pid_external == $pid_external"
		for pid in $(pstree -p "$pid_external" | sed 's/(/\n(/g' | grep '(' | sed 's/(\(.*\)).*/\1/' | tr "\n" " "); do
			// debug_filter -- printf '%s \n' "\$pid_external child $pid"
			# kill_tree "$pid" true > /dev/null 2>&1
		done
		# // kill $(pstree -p "$pid_external" | sed 's/(/\n(/g' | grep '(' | sed 's/(\(.*\)).*/\1/' | tr "\n" " ")
	}

	[ -z "${KISS_INNER_PIPE:+x}" ] || {
		# [ -z "${USE_SAY_PIPE+x}" ] ||
		// debug_filter -- printf '%s %s\n' '$PID_SAY' "${PID_SAY-}"
		// debug_filter -- printf '%s %s\n' '$PID_LOG' "${PID_LOG-}"
	}
	// log 'test' "test_09"
	# // log '$0' "$0"
	// log '$$ : $0' "$(delegate -- format "$$") : $0"
	// log '$_KISS_LVL' "$_KISS_LVL"
	// log '$LOGNAME' "$LOGNAME"
	# shift 1
	# stty susp 'kill-name "$@"'
	# trap 'kill-name "$@"' TSTP

	# trap ' \
	# // kill_pipe "PID_SAY" "$PID_SAY"; \
	# // kill_pipe "PID_LOG" "$PID_LOG"' TSTP

	[ "$SESSION_PPID" -ne "$PPID" ] ||
		[ "$_KISS_LVL" -ne "0" ] || {
		[ -z "${KISS_INNER_PIPE:+x}" ] || {
			// debug_filter -- printf '%s %s\n' '$PID_SAY' "${PID_SAY-}"
			// debug_filter -- printf '%s %s\n' '$PID_LOG' "${PID_LOG-}"
		}
		# // pipe_cancel "PID_SAY"
		# // pipe_cancel "PID_LOG"
	}
	# ! pid_alive "$PID_SAY" || kill -TERM "$PID_SAY"
	# ! pid_alive "$PID_LOG" || kill -TERM "$PID_LOG"

	// log 'test' "test_10"
	[ -n "${KISS_AS_LIBRARY+x}" ] || // trap_off
	// log 'test' "test_11"
	return 0
}

# How to change user:
# doas login $USER
# The following methond won't work
# su - $USER

# kiss is the biggest repeatly reloading component
# These functions should not override other functions defined previously
function_define() {
	{ is_alias "$1" || is_function "$1"; } &&
	// war "$1" "already has a definition" ||
	/ "$1() ( set -e; // args \"$2\" \"\$@\" || interrupt; )"
	# / "$1() ( set -e; // pre_args && args \"$2\" \"\$@\" || interrupt; )"
	# / "alias $1='( // args \"$2\" \"\$@\"; )'"
}

alter() {
	_level_2
	action="$1"; shift 1;
	// log '$#' "$#"
	// log '$LOGNAME' "$LOGNAME"
	// log '$@' "$(esceval "$@")"
	[ "$(whoami)" = "root" ] && {
		. /usr/bin/kiss-alter
		# // pre_args && subshell_all "$action" "$@" 2>&1
		// subshell_all "$action" "$@" 2>&1 ||
			// die "$action failed" "$(esceval "$@")"
		:
	} || {
		local color_parent_origin="$color_parent" color_parent="$COLOR_BOOT"
		local color_child_origin="$color_child"   color_child="$COLOR_HIGH"
		local color_line_origin="$color_line"     color_line="$color_parent"
		# // cue 'kiss' "initializing"
		out "$say_pipe" "$log_pipe" \
			"${lineno_scope-"0"}" "$lineno" "kiss" "initializing"
		local color_line="$color_line_origin"
		local color_child="$color_child_origin"
		local color_parent="$color_parent_origin"
		# local env_variables=" RUSTFLAGS=\"--remap-path-prefix=${PWD=.} -Clinker=rust-lld ${RUSTFLAGS-}\" "
		# env_variables="$env_variables KISS_XHOST_ARCH=\"$KISS_XHOST_ARCH\" "
		# env_variables="$env_variables KISS_XBUILD_ARCH=\"$KISS_XHOST_ARCH\" "
		# env_variables="$env_variables CHOST=\"${KISS_XHOST_TRIPLE}\" "
		# env_variables="$env_variables CBUILD=\"${KISS_XBUILD_TRIPLE}\" "
		# env_variables="$env_variables KISS_XHOST_ABI=\"$KISS_XHOST_ABI\" "
		# env_variables="$env_variables KISS_XBUILD_ABI=\"$KISS_XBUILD_ABI\" "
		# env_variables="$env_variables KISS_XHOST_TRIPLE=\"$KISS_XHOST_ARCH-linux-$KISS_XHOST_ABI\" "
		# env_variables="$env_variables KISS_XBUILD_TRIPLE=\"$KISS_XBUILD_ARCH-linux-$KISS_XBUILD_ABI\" "
		# env_variables="$env_variables DEST_ROOT=\"$DEST_ROOT\" "
		# env_variables="$env_variables KISS_COMPRESS=\"$KISS_COMPRESS\" "
		# env_variables="$env_variables KISS_ROOT=\"$KISS_ROOT\" "
		# env_variables="$env_variables KISS_REPO=\"$KISS_REPO\" "
		# env_variables="$env_variables SESSION_PID=\"$SESSION_PID\" "
		# env_variables="$env_variables KISS_PID=\"$KISS_PID\" "
		# env_variables="$env_variables CROSS_ACTION=\"${CROSS_ACTION:-"$action"}\" "
		# env_variables="$env_variables SHELL_OPTIONS=\"$SHELL_OPTIONS\" "
		# env_variables="$env_variables REPO_BASE=\"$REPO_BASE\" "
		# env_variables="$env_variables REPO_DIR=\"$REPO_DIR\" "
		# env_variables="$env_variables SRC_ROOT=\"$SRC_ROOT\" "
		# env_variables="$env_variables MAKE_ROOT=\"$MAKE_ROOT\" "
		# env_variables="$env_variables OBJ_ROOT=\"$OBJ_ROOT\" "
		# env_variables="$env_variables DESTDIR=\"$PKG_ROOT/$repo_name\" "
		# [ -z "${DEBUG_AT_BACKGROUND+x}" ] || {
		#   env_variables="$env_variables DEBUG_AT_BACKGROUND=\"$DEBUG_AT_BACKGROUND\" "
		# }
		# [ -z "${KISS_FORCE+x}" ] || {
		#   env_variables="$env_variables KISS_FORCE=\"$KISS_FORCE\" "
		# }
		# env_variables="$env_variables KISS_ALTER_AS_LIBRARY=\"\" "

		operation_dir="$KISS_ROOT"
		[ "$action" != "archive" ] || operation_dir="$REPO_ROOT_IMPL"
		local dial_chain="as_own \"$operation_dir/\" env \
			$ENV_VARIABLES /usr/bin/kiss \"$action\" "
		for argument do
			dial_chain="$dial_chain \"$argument\""
		done
		! // || / "$dial_chain" ||
		# ! // || / "as_own \"$operation_dir/\" env \
		# 	$ENV_VARIABLES /usr/bin/kiss \"$action\" $*" ||
			// die "$action failed" "$(esceval "$@")"

		# // as_own "$KISS_ROOT/" \
		#   KISS_ALTER_AS_LIBRARY="${KISS_ALTER_AS_LIBRARY-}" \
		#   KISS_AS_LIBRARY="${KISS_AS_LIBRARY-}" \
		#   SHELL_OPTIONS="$SHELL_OPTIONS" \
		#   KISS_TMPDIR="$KISS_TMPDIR" \
		#   MNGR_ROOT="$MNGR_ROOT" \
		#   ERR_OUTPUT="$ERR_OUTPUT" \
		#   INIT_OUTPUT="$INIT_OUTPUT" \
		#   USER_OUTPUT="$USER_OUTPUT" \
		#   RUSTFLAGS="--remap-path-prefix=${PWD=.} -Clinker=rust-lld ${RUSTFLAGS-}" \
		#   KISS_XHOST_ARCH="$KISS_XHOST_ARCH" \
		#   KISS_XBUILD_ARCH="$KISS_XHOST_ARCH" \
		#   CHOST="${KISS_XHOST_TRIPLE}" \
		#   CBUILD="${KISS_XBUILD_TRIPLE}" \
		#   KISS_XHOST_ABI="$KISS_XHOST_ABI" \
		#   KISS_XBUILD_ABI="$KISS_XBUILD_ABI" \
		#   KISS_XHOST_TRIPLE="$KISS_XHOST_ARCH-linux-$KISS_XHOST_ABI" \
		#   KISS_XBUILD_TRIPLE="$KISS_XBUILD_ARCH-linux-$KISS_XBUILD_ABI" \
		#   DEST_ROOT="$DEST_ROOT" \
		#   KISS_COMPRESS="$KISS_COMPRESS" \
		#   KISS_ROOT="$KISS_ROOT" \
		#   KISS_REPO="$KISS_REPO" \
		#   SESSION_PID="$SESSION_PID" \
		#   KISS_PID="$KISS_PID" \
		#   CROSS_ACTION="${CROSS_ACTION:-"$action"}" \
		#   SHELL_OPTIONS="$SHELL_OPTIONS" \
		#   REPO_BASE="$REPO_BASE" \
		#   REPO_DIR="$REPO_DIR" \
		#   SRC_ROOT="$SRC_ROOT" \
		#   MAKE_ROOT="$MAKE_ROOT" \
		#   OBJ_ROOT="$OBJ_ROOT" \
		#   DESTDIR="$PKG_ROOT/$repo_name" \
		#   /usr/bin/kiss "$action" "$@"
	}
}

a() { alter "alternatives" "$@" || // die "alternatives failed" "$(esceval "$@")"; }
r() { alter "remove" "$@" || // die "removing failed" "$(esceval "$@")"; }
i() { alter "install" "$@" || // die "installation failed" "$(esceval "$@")"; }
archive() { alter "archive" "$@" || // die "archiving failed" "$(esceval "$@")"; }
maint() { set -e; alter "maintain" "$@" || // die "maintaining failed" "$(esceval "$@")"; }
# // function_define "alternatives" "a"
# // function_define "i"            "i"
# // function_define "remove"       "r"

// function_define "b"            "b"
// function_define "checksum"     "c"
// function_define "download"     "d"
// function_define "f"            "find"
// function_define "help"         "h"
// function_define "k"            "kill"
// function_define "list"         "l"
// function_define "manifest"     "m"
// function_define "pick"         "p"
// function_define "search"       "s"
// function_define "update"       "u"
// function_define "upgrade"      "U"
// function_define "v"            "v"
// function_define "o"            "owns"
// function_define "link"         "link"
// function_define "bup"          "bup"
// function_define "chroot"       "chroot"
// function_define "cconf"        "cmake-config"
// function_define "dep"          "depends"
// function_define "fork"         "fork"
// function_define "genpkg"       "genpkg"
// function_define "maintainer"   "maintainer"
// function_define "mconf"        "meson-config"
// function_define "new"          "new"
// function_define "orphans"      "orphans"
// function_define "preferred"    "preferred"
// function_define "revdepends"   "revdepends"
// function_define "rst"          "reset"
// function_define "sz"           "size"

alias_define() {
	{ is_alias "$1" || is_function "$1"; } &&
	// war "$1" "already has a definition" || / "alias $1='$2'"
}

# // alias_define "a"    "alternatives"
# // alias_define "r"    "remove"

// alias_define "c"    "checksum"
// alias_define "d"    "download"
// alias_define "h"    "help"
// alias_define "l"    "list"
// alias_define "m"    "manifest"
// alias_define "p"    "pick"
// alias_define "s"    "search"
// alias_define "u"    "update"
// alias_define "U"    "upgrade"
// alias_define "orph" "orphans"
// alias_define "pref" "preferred"
// alias_define "rdep" "revdepends"

# If you still wanna /usr/bin/kiss, use it like this:
# unset KISS_AS_LIBRARY; KISS_FORCE= sh /usr/bin/kiss p runit

# We have to overwrite kiss() in ${SHARE_PREFIX:-/mnt}/init/env
# Usage: kiss l acl
# Output will print to original screen where kiss initialized
# kiss() { // args "$@"; }

# type is_writable

! is_alias "kiss" || unalias kiss
# kiss() ( set -e; // pre_args && args "$@" || interrupt; )
kiss() ( set -e; // args "$@" || interrupt; )

# FATAL: ENV values in the shell environment wil ruin cmake, etc.
[ -z "${ENV:+x}" ] || unset ENV

set -e
// pre_args
# : "${lineno="$((LINENO + 4))"}"
# : "${lineno_scope="$lineno"}"
[ -z "${KISS_AS_LIBRARY+x}" ] && {
	# alias kiss=' // args "$@" '
	! // || main "$@" || :
} || {
	# alias kiss=' KISS_AS_LIBRARY= SHELL_OPTIONS=$SHELL_OPTIONS // args "$@" '
	# ( set -e; // pre_args && args "$@" || interrupt; )
	( set -e; // args "$@" || interrupt; )
}

# Redirecting the errors output. But it will break subshell messages like:
# // as_usr "root" env PATH="$PATH" ... '/usr/bin/kiss'
# trap won't be inherited by sub processes
exec 2>"$ERR_OUTPUT"

# vi:   set filetype=sh syntax=sh :
# vim:  set filetype=sh syntax=sh :
# nvim: set filetype=sh syntax=sh :





